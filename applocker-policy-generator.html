<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AppLocker Policy Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #ffffff;
            color: #333;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #ffffff;
        }

        header {
            background: #1e3a8a;
            color: white;
            padding: 12px 20px;
            margin-bottom: 0;
            border-radius: 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        header .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        header h1 {
            font-size: 1.2em;
            margin: 0;
            font-weight: 600;
            letter-spacing: 0.3px;
        }

        header p {
            font-size: 0.85em;
            margin: 0;
            opacity: 0.9;
            margin-left: 15px;
        }

        .nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #1e3a8a;
            color: white;
        }

        .btn-primary:hover {
            background: #1e40af;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
        }

        .import-method-btn {
            transition: all 0.2s;
        }

        .import-method-btn.active {
            background: #1e3a8a;
            color: white;
        }

        .import-method-btn.active:hover {
            background: #1e40af;
        }

        .import-section {
            transition: opacity 0.2s;
        }

        .card {
            background: white;
            border-radius: 4px;
            padding: 12px 15px;
            margin-bottom: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            border: 1px solid #e5e7eb;
        }

        .card h2 {
            margin-bottom: 10px;
            color: #1e3a8a;
            border-bottom: 2px solid #1e3a8a;
            padding-bottom: 6px;
            font-size: 1.3em;
        }

        .card h3 {
            margin: 10px 0 6px 0;
            color: #555;
            font-size: 1.1em;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            font-weight: normal;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        .table tr:hover {
            background: #f8f9fa;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .badge-success {
            background: #d4edda;
            color: #155724;
        }

        .badge-danger {
            background: #f8d7da;
            color: #721c24;
        }

        .badge-warning {
            background: #fff3cd;
            color: #856404;
        }

        .badge-info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .badge-low {
            background: #d4edda;
            color: #155724;
        }

        .badge-medium {
            background: #fff3cd;
            color: #856404;
        }

        .badge-high {
            background: #f8d7da;
            color: #721c24;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            overflow: auto;
        }

        .modal-content {
            background: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 8px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .alert {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #0c5460;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border-left: 4px solid #ffc107;
        }

        .alert-danger {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }

        .layer-card {
            border-left: 4px solid #1e3a8a;
            margin-bottom: 10px;
        }
        
        .layer-card .card {
            padding: 12px 15px;
        }

        .layer-card.baseline {
            border-left-color: #28a745;
        }

        .layer-card.deviating {
            border-left-color: #ffc107;
        }

        .layer-card.high-risk {
            border-left-color: #dc3545;
        }

        .layer-card.drag-over {
            background: #f0f9ff;
            border-left-color: #3b82f6;
            border-left-width: 6px;
            box-shadow: 0 4px 12px rgba(30, 58, 138, 0.2);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .summary-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .summary-item .value {
            font-size: 1.6em;
            font-weight: bold;
            color: #1e3a8a;
        }

        .summary-item .label {
            color: #666;
            font-size: 0.85em;
            margin-top: 3px;
        }

        .hidden {
            display: none;
        }

        .rules-list {
            margin-top: 10px;
        }
        
        .rules-list-header {
            margin-bottom: 8px;
        }

        .rule-item {
            padding: 8px 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 6px;
            border-left: 3px solid #1e3a8a;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .rule-item:hover {
            background: #eff6ff;
            border-left-color: #1e40af;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .rule-item.expanded {
            background: #ffffff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            border-left-color: #1e3a8a;
            border-left-width: 4px;
        }

        .rule-item.dragging {
            opacity: 0.5;
            cursor: move;
        }

        .rule-item[draggable="true"] {
            cursor: move;
        }

        .drag-handle {
            cursor: move !important;
            user-select: none;
            color: #999;
            font-size: 1.2em;
            padding: 2px 4px;
        }

        .drag-handle:hover {
            color: #1e3a8a;
        }

        .rule-drop-zone {
            min-height: 8px;
            margin: 4px 0;
            border: 2px dashed transparent;
            border-radius: 4px;
            transition: all 0.2s;
            position: relative;
        }
        
        .rule-drop-zone:hover {
            border-color: #cbd5e1;
            background: #f8fafc;
        }

        .rule-drop-zone.drag-over {
            border-color: #1e3a8a;
            background: #eff6ff;
            min-height: 40px;
            box-shadow: 0 0 10px rgba(30, 58, 138, 0.3);
            border-width: 2px;
            border-style: dashed;
        }

        .rules-list.drag-over {
            background: #f0f9ff;
            box-shadow: inset 0 0 10px rgba(30, 58, 138, 0.2);
            border: 2px dashed #3b82f6;
        }

        .rule-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
        }

        .rule-item-header strong {
            color: #1e3a8a;
            font-size: 0.95em;
        }

        .rule-item-details {
            font-size: 0.85em;
            color: #666;
            margin-top: 3px;
            line-height: 1.4;
        }

        .rule-xml-expanded {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0;
            margin-top: 0;
        }

        .rule-item.expanded .rule-xml-expanded {
            max-height: 1000px;
            padding: 10px;
            margin-top: 8px;
            border-top: 2px solid #e0e0e0;
        }

        .rule-xml-content {
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e3e;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            margin-bottom: 6px;
        }

        .rule-xml-actions {
            display: flex;
            gap: 8px;
            margin-top: 6px;
        }

        .rule-xml-actions button {
            cursor: pointer;
        }

        .rule-xml-toggle {
            font-size: 0.8em;
            color: #1e3a8a;
            margin-top: 3px;
            display: flex;
            align-items: center;
            gap: 4px;
            user-select: none;
        }

        .rule-item.expanded .rule-xml-toggle::before {
            content: '‚ñº ';
        }

        .rule-xml-toggle::before {
            content: '‚ñ∂ ';
            font-size: 0.7em;
            transition: transform 0.2s;
        }

        .rule-xml-expanded * {
            pointer-events: auto;
        }

        .rule-edit-form {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            padding: 0;
            margin-top: 0;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .rule-item.editing .rule-edit-form {
            max-height: 2000px;
            padding: 12px;
            margin-top: 8px;
            border-top: 2px solid #1e3a8a;
        }

        .rule-edit-form .form-group {
            margin-bottom: 10px;
        }

        .rule-edit-form .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
            font-size: 0.9em;
        }

        .rule-edit-form .form-group input,
        .rule-edit-form .form-group select,
        .rule-edit-form .form-group textarea {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .rule-edit-form .form-group textarea {
            resize: vertical;
            min-height: 50px;
        }

        .rule-edit-form .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .rule-edit-form .form-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }

        .rule-edit-form .rule-type-section {
            background: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            border-left: 3px solid #1e3a8a;
        }

        .rule-edit-form .rule-type-section h4 {
            margin: 0 0 8px 0;
            color: #1e3a8a;
            font-size: 0.95em;
        }

        .exceptions-list {
            margin: 10px 0;
        }

        .exception-item {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
            align-items: center;
        }

        .exception-item input {
            flex: 1;
        }

        .rule-actions {
            display: flex;
            gap: 4px;
            margin-top: 6px;
        }

        .rule-actions button {
            padding: 4px 10px;
            font-size: 0.8em;
        }

        .rule-item-header {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .rule-actions {
            z-index: 10;
            position: relative;
        }

        .rule-edit-form {
            z-index: 5;
        }

        .rule-edit-form * {
            pointer-events: auto;
        }

        .rules-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px;
            background: #f0f4ff;
            border-radius: 4px;
            margin-bottom: 10px;
            transition: background 0.2s;
            user-select: none;
        }

        .rules-list-header:hover {
            background: #e7f3ff;
        }

        .rules-list-header strong {
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .rules-list-header::before {
            content: '‚ñ∂ ';
            font-size: 0.8em;
            transition: transform 0.2s;
        }

        .rules-list-header.expanded::before {
            content: '‚ñº ';
        }

        .rules-list-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .rules-list-container.expanded {
            max-height: 10000px;
        }

        .wizard-step {
            display: none;
        }

        .wizard-step.active {
            display: block;
        }

        .wizard-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .guidance-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .guidance-box h4 {
            margin-bottom: 10px;
            color: #1976D2;
        }

        .option-card {
            border: 2px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-card:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .option-card.selected {
            border-color: #667eea;
            background: #e7f3ff;
        }

        .option-card .option-label {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .drop-zone {
            border: 3px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s;
            margin: 20px 0;
        }

        .drop-zone:hover {
            background: #e7f3ff;
            border-color: #5568d3;
        }

        .drop-zone.dragover {
            background: #d1ecf1;
            border-color: #28a745;
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .extracted-info {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }

        .extracted-info h4 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .info-item {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border-left: 3px solid #667eea;
        }

        .info-item label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .info-item input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
        }

        .info-item-code {
            background: #f4f4f4;
            padding: 8px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin-top: 5px;
            word-break: break-all;
        }

        .file-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #e7f3ff;
            border-radius: 4px;
            margin: 10px 0;
        }

        .file-info-name {
            font-weight: bold;
            color: #667eea;
        }

        .file-info-size {
            color: #666;
            font-size: 0.9em;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div style="display: flex; align-items: center;">
                    <h1>AppLocker Policy Generator</h1>
                </div>
            </div>
        </header>

        <!-- Dashboard View -->
        <div id="dashboard-view">
            <div class="nav">
                <button class="btn btn-primary" onclick="showCreatePolicy()">Create New Policy</button>
                <button class="btn btn-info" onclick="showImportPolicyFromDashboard()" style="background: #17a2b8; color: white;">üì• Import Policy</button>
                <button class="btn btn-secondary" onclick="loadPolicies()">Refresh</button>
            </div>

            <div class="card">
                <h2>Policies</h2>
                <div id="policies-list"></div>
            </div>
        </div>

        <!-- Policy View -->
        <div id="policy-view" class="hidden">
            <div class="nav">
                <button class="btn btn-secondary" onclick="showDashboard()">‚Üê Back to Dashboard</button>
                <button class="btn btn-primary" onclick="showAddLayer()">Add Application Layer</button>
                <button class="btn btn-success" onclick="validatePolicy()">Validate Policy</button>
                <button class="btn btn-info" onclick="showImportPolicy()" style="background: #17a2b8; color: white;">üì• Import Policy</button>
                <button class="btn btn-warning" onclick="showExport()">Export Policy</button>
            </div>

            <div class="card">
                <h2 id="policy-name-header"></h2>
                <div id="policy-summary" class="summary-grid"></div>
            </div>

            <div id="layers-container"></div>
        </div>

        <!-- Create Policy Modal -->
        <div id="create-policy-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('create-policy-modal')">&times;</span>
                <h2>Create New Policy</h2>
                <form id="create-policy-form">
                    <div class="form-group">
                        <label>Policy Name *</label>
                        <input type="text" id="policy-name" required>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="policy-description"></textarea>
                    </div>
                    <div class="form-group">
                        <label>System Classes *</label>
                        <div class="checkbox-group" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
                            <label><input type="checkbox" name="system-class" value="workstations"> Workstations</label>
                            <label><input type="checkbox" name="system-class" value="servers"> Servers</label>
                            <label><input type="checkbox" name="system-class" value="vdi"> VDI</label>
                            <label><input type="checkbox" name="system-class" value="kiosk"> Kiosk/Public Access</label>
                            <label><input type="checkbox" name="system-class" value="pos"> Point of Sale (POS)</label>
                            <label><input type="checkbox" name="system-class" value="developer"> Developer Workstations</label>
                            <label><input type="checkbox" name="system-class" value="terminal_server"> Terminal Servers / RDS</label>
                            <label><input type="checkbox" name="system-class" value="domain_controller"> Domain Controllers</label>
                            <label><input type="checkbox" name="system-class" value="file_server"> File Servers</label>
                            <label><input type="checkbox" name="system-class" value="web_server"> Web Servers</label>
                            <label><input type="checkbox" name="system-class" value="database_server"> Database Servers</label>
                            <label><input type="checkbox" name="system-class" value="jump_server"> Jump Servers / Bastion</label>
                            <label><input type="checkbox" name="system-class" value="medical"> Medical Devices / Healthcare</label>
                            <label><input type="checkbox" name="system-class" value="ics"> Industrial Control (ICS/SCADA)</label>
                            <label><input type="checkbox" name="system-class" value="testing"> Testing/QA Systems</label>
                            <label><input type="checkbox" name="system-class" value="print_server"> Print Servers</label>
                            <label><input type="checkbox" name="system-class" value="app_server"> Application Servers</label>
                        </div>
                        <small style="display: block; margin-top: 5px; color: #666;">Each system class will receive a hardened baseline template optimized for its use case</small>
                    </div>
                    <div class="form-group">
                        <label>System Count</label>
                        <input type="number" id="system-count" min="1">
                    </div>
                    <div class="form-group">
                        <label>Organization</label>
                        <input type="text" id="organization">
                    </div>
                    <button type="submit" class="btn btn-primary">Create Policy</button>
                </form>
            </div>
        </div>

        <!-- Add Layer Modal -->
        <div id="add-layer-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('add-layer-modal')">&times;</span>
                <h2>Add Application Layer</h2>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
                    <p style="margin: 0 0 10px 0; color: #666;">Choose how you want to add the application layer:</p>
                    <div style="display: flex; gap: 10px;">
                        <button type="button" class="btn btn-primary" onclick="showSingleFileUpload()" id="single-file-btn" style="flex: 1;">üìÑ Single File Upload</button>
                        <button type="button" class="btn btn-secondary" onclick="showFolderHashImport()" id="folder-hash-btn" style="flex: 1;">üì¶ Folder Hash Import</button>
                    </div>
                </div>
                
                <!-- Single File Upload Section -->
                <div id="single-file-section">
                <!-- Step 1: File Upload -->
                <div id="step-upload" class="wizard-step active">
                    <div class="form-group">
                        <label>Application Name *</label>
                        <input type="text" id="app-name" required>
                    </div>
                    <div class="form-group">
                        <label>Vendor *</label>
                        <input type="text" id="app-vendor" required>
                    </div>
                    <div class="form-group">
                        <label>Drop executable file here or click to browse</label>
                        <div class="drop-zone" id="drop-zone" onclick="document.getElementById('file-input').click()">
                            <div class="drop-zone-icon">üìÅ</div>
                            <div><strong>Drag & Drop EXE file here</strong></div>
                            <div style="margin-top: 10px; color: #666;">or click to browse</div>
                            <input type="file" id="file-input" accept=".exe,.dll,.msi,.appx" style="display: none;">
                        </div>
                    </div>
                    <div id="file-info-container" style="display: none;">
                        <div class="file-info">
                            <div>
                                <div class="file-info-name" id="file-name"></div>
                                <div class="file-info-size" id="file-size"></div>
                            </div>
                            <button type="button" class="btn btn-danger" onclick="clearFile()" style="padding: 5px 10px;">Remove</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Install Path (optional - will be extracted from file if available)</label>
                        <input type="text" id="install-path" placeholder="e.g., %PROGRAMFILES%\AppName\*">
                    </div>
                    <div class="form-group">
                        <label>Version (optional)</label>
                        <input type="text" id="app-version" placeholder="e.g., 16.0.0.0">
                    </div>
                    <div class="form-group">
                        <label>Business Justification *</label>
                        <textarea id="business-justification" required></textarea>
                    </div>
                    <button type="button" class="btn btn-primary" onclick="processFile()" id="process-btn" disabled>Extract Information</button>
                </div>

                <!-- Step 2: Rule Options Selection -->
                <div id="step-options" class="wizard-step">
                    <h3>Extracted Information</h3>
                    <p>Select which rule types you want to generate for this application:</p>
                    
                    <div id="extracted-info-container"></div>
                    
                    <div class="form-group" style="margin-top: 20px;">
                        <label>
                            <input type="checkbox" id="generate-exe" checked> Generate EXE rules
                        </label>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="generate-dll" checked> Generate DLL rules
                        </label>
                    </div>
                    
                    <div style="margin-top: 20px; display: flex; gap: 10px;">
                        <button type="button" class="btn btn-secondary" onclick="backToUpload()">‚Üê Back</button>
                        <button type="button" class="btn btn-primary" onclick="createLayerFromOptions()">Create Layer</button>
                    </div>
                </div>
                </div>
                
                <!-- Folder Hash Import Section -->
                <div id="folder-hash-section" style="display: none;">
                    <div style="margin-bottom: 20px; padding: 15px; background: #e7f3ff; border-left: 4px solid #667eea; border-radius: 4px;">
                        <h3 style="margin-top: 0; color: #333;">Purpose</h3>
                        <p style="margin-bottom: 10px; color: #333;">This feature allows you to bulk import entire folders of files and automatically generate AppLocker HASH rules for each file. This is particularly useful when you need to add hash-based rules for multiple unsigned files (e.g., DLLs, EXEs) from a folder structure.</p>
                        
                        <h3 style="margin-top: 15px; color: #333;">How to Use</h3>
                        <ol style="margin-bottom: 0; padding-left: 20px; color: #333;">
                            <li style="margin-bottom: 8px;"><strong>Prepare your files:</strong> Create a ZIP archive containing the folder structure with files you want to add to AppLocker. <strong>All files in subfolders are automatically processed</strong> - you can include nested folder structures of any depth, and all files will be found and processed recursively.</li>
                            <li style="margin-bottom: 8px;"><strong>Select the ZIP file:</strong> Click "Choose File" and select your ZIP archive.</li>
                            <li style="margin-bottom: 8px;"><strong>Review files:</strong> The tool will automatically scan the ZIP (including all subfolders), calculate SHA-256 hashes, and detect file categories. Only AppLocker-supported file types (EXE, DLL, SCRIPT, MSI, APPX, CHM, HTA) will be processed. Unsupported files will be listed separately and skipped. The full path (including subfolder structure) is shown for each file.</li>
                            <li style="margin-bottom: 8px;"><strong>Select files to import:</strong> Review the list of detected files, grouped by category. Use "Select All" or individually check/uncheck files you want to include.</li>
                            <li style="margin-bottom: 8px;"><strong>Configure rule action:</strong> Choose whether the imported rules should ALLOW or DENY execution.</li>
                            <li style="margin-bottom: 8px;"><strong>Name your layer:</strong> Enter a descriptive name for the new layer (e.g., "Bulk Import - DLLs - 2024-01-15").</li>
                            <li style="margin-bottom: 8px;"><strong>Add business justification:</strong> Provide a reason for this bulk import.</li>
                            <li style="margin-bottom: 8px;"><strong>Import:</strong> Click "Import Selected Files as New Layer" to create HASH rules for all selected files in a new layer.</li>
                        </ol>
                        
                        <p style="margin-top: 15px; margin-bottom: 0; color: #666; font-size: 0.9em;"><strong>Note:</strong> File categories are automatically detected from file extensions with exact matching. Files with unsupported extensions will be skipped automatically. All files in subfolders (at any nesting level) are automatically discovered and processed.</p>
                    </div>
                    
                    <div class="form-group">
                        <label>Select ZIP File</label>
                        <input type="file" id="zip-file-input" accept=".zip" onchange="handleZipFileSelect(this)">
                        <small style="display: block; margin-top: 5px; color: #666;">Select a ZIP file containing your folder structure with files to create hash rules for</small>
                    </div>
                    
                    <div id="zip-file-list-section" style="display: none; margin-top: 20px;"></div>
                    
                    <div id="zip-processing-status" style="display: none; margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 4px;">
                        <p style="margin: 0;"><strong>Processing ZIP file...</strong> Please wait while we extract and analyze the files.</p>
                    </div>
                    
                    <div id="zip-import-error" style="display: none; margin-top: 15px; padding: 10px; background: #f8d7da; border-radius: 4px; color: #721c24;">
                        <p style="margin: 0;" id="zip-error-message"></p>
                    </div>
                    
                    <div class="form-group" style="margin-top: 20px;">
                        <label>Layer Name *</label>
                        <input type="text" id="zip-layer-name" placeholder="e.g., Bulk Import - DLLs - 2024-01-15" required>
                    </div>
                    
                    <div class="form-group">
                        <label>Rule Action *</label>
                        <select id="zip-rule-action" onchange="if(zipFileData.length > 0) displayZipFileList()">
                            <option value="ALLOW">ALLOW</option>
                            <option value="DENY">DENY</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Business Justification *</label>
                        <textarea id="zip-business-justification" placeholder="Business justification for this bulk import layer" style="min-height: 60px;" required>Bulk import of files from ZIP archive. Rules created to control execution of unsigned files.</textarea>
                    </div>
                    
                    <button class="btn btn-primary" onclick="importZipFiles()" id="zip-import-btn" disabled style="margin-top: 15px;">Import Selected Files as New Layer</button>
                </div>
            </div>
        </div>

        <!-- Analysis Results Modal -->
        <div id="analysis-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('analysis-modal')">&times;</span>
                <h2>Application Analysis</h2>
                <div id="analysis-results"></div>
            </div>
        </div>

        <!-- Validation Results Modal -->
        <div id="validation-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('validation-modal')">&times;</span>
                <h2>Policy Validation Results</h2>
                <div id="validation-results"></div>
            </div>
        </div>

        <!-- Import Policy Modal -->
        <div id="import-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('import-modal')">&times;</span>
                <h2>Import AppLocker Policy</h2>
                <p style="margin-bottom: 15px; color: #666;">Import an existing AppLocker policy XML. Rules will be added as a new layer.</p>
                
                <!-- Import Method Toggle -->
                <div style="display: flex; gap: 8px; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">
                    <button type="button" class="btn btn-secondary import-method-btn active" onclick="switchImportMethod('file')" id="import-method-file" style="flex: 1; padding: 8px;">üìÅ Upload File</button>
                    <button type="button" class="btn btn-secondary import-method-btn" onclick="switchImportMethod('paste')" id="import-method-paste" style="flex: 1; padding: 8px;">üìã Paste XML</button>
                </div>

                <!-- File Upload Section -->
                <div id="import-file-section" class="import-section">
                    <div class="form-group">
                        <label>Select AppLocker Policy XML File</label>
                        <input type="file" id="import-file-input" accept=".xml" onchange="handleImportFileSelect(this)">
                        <small style="display: block; margin-top: 5px; color: #666;">Select an AppLocker policy XML file exported from Group Policy or Intune</small>
                    </div>
                </div>

                <!-- Paste XML Section -->
                <div id="import-paste-section" class="import-section" style="display: none;">
                    <div class="form-group">
                        <label>Paste AppLocker Policy XML</label>
                        <textarea id="import-xml-text" placeholder="Paste your AppLocker policy XML here..." style="min-height: 200px; font-family: 'Courier New', monospace; font-size: 0.9em;" oninput="handleImportTextPaste(this)"></textarea>
                        <small style="display: block; margin-top: 5px; color: #666;">Paste the XML content from an AppLocker policy file</small>
                    </div>
                </div>

                <!-- Preview Section -->
                <div id="import-preview" style="display: none; margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <h4 style="margin-bottom: 10px;">Import Preview</h4>
                    <div id="import-preview-content"></div>
                </div>

                <!-- Layer Configuration -->
                <div class="form-group" style="margin-top: 15px;">
                    <label>Layer Name</label>
                    <input type="text" id="import-layer-name" placeholder="e.g., Imported Policy - 2024-01-15" value="">
                </div>
                <div class="form-group">
                    <label>Business Justification</label>
                    <textarea id="import-business-justification" placeholder="Business justification for this imported layer" style="min-height: 60px;"></textarea>
                </div>
                <button class="btn btn-primary" onclick="importPolicy()" id="import-btn" disabled>Import as New Layer</button>
                <div id="import-error" style="display: none; margin-top: 10px; padding: 10px; background: #f8d7da; color: #721c24; border-radius: 4px;"></div>
            </div>
        </div>

        <!-- ZIP Import Modal -->
        <div id="zip-import-modal" class="modal">
            <div class="modal-content" style="max-width: 90%; max-height: 90vh; overflow-y: auto;">
                <span class="close" onclick="closeModal('zip-import-modal')">&times;</span>
                <h2>Folder Hash Import</h2>
                <div style="margin-bottom: 20px; padding: 15px; background: #e7f3ff; border-left: 4px solid #667eea; border-radius: 4px;">
                    <h3 style="margin-top: 0; color: #333;">Purpose</h3>
                    <p style="margin-bottom: 10px; color: #333;">This feature allows you to bulk import entire folders of files and automatically generate AppLocker HASH rules for each file. This is particularly useful when you need to add hash-based rules for multiple unsigned files (e.g., DLLs, EXEs) from a folder structure.</p>
                    
                    <h3 style="margin-top: 15px; color: #333;">How to Use</h3>
                    <ol style="margin-bottom: 0; padding-left: 20px; color: #333;">
                        <li style="margin-bottom: 8px;"><strong>Prepare your files:</strong> Create a ZIP archive containing the folder structure with files you want to add to AppLocker. <strong>All files in subfolders are automatically processed</strong> - you can include nested folder structures of any depth, and all files will be found and processed recursively.</li>
                        <li style="margin-bottom: 8px;"><strong>Select the ZIP file:</strong> Click "Choose File" and select your ZIP archive.</li>
                        <li style="margin-bottom: 8px;"><strong>Review files:</strong> The tool will automatically scan the ZIP (including all subfolders), calculate SHA-256 hashes, and detect file categories. Only AppLocker-supported file types (EXE, DLL, SCRIPT, MSI, APPX, CHM, HTA) will be processed. Unsupported files will be listed separately and skipped. The full path (including subfolder structure) is shown for each file.</li>
                        <li style="margin-bottom: 8px;"><strong>Select files to import:</strong> Review the list of detected files, grouped by category. Use "Select All" or individually check/uncheck files you want to include.</li>
                        <li style="margin-bottom: 8px;"><strong>Configure rule action:</strong> Choose whether the imported rules should ALLOW or DENY execution.</li>
                        <li style="margin-bottom: 8px;"><strong>Name your layer:</strong> Enter a descriptive name for the new layer (e.g., "Bulk Import - DLLs - 2024-01-15").</li>
                        <li style="margin-bottom: 8px;"><strong>Add business justification:</strong> Provide a reason for this bulk import.</li>
                        <li style="margin-bottom: 8px;"><strong>Import:</strong> Click "Import Selected Files as New Layer" to create HASH rules for all selected files in a new layer.</li>
                    </ol>
                    
                    <p style="margin-top: 15px; margin-bottom: 0; color: #666; font-size: 0.9em;"><strong>Note:</strong> File categories are automatically detected from file extensions with exact matching. Files with unsupported extensions will be skipped automatically. All files in subfolders (at any nesting level) are automatically discovered and processed.</p>
                </div>
                
                <div class="form-group">
                    <label>Select ZIP File</label>
                    <input type="file" id="zip-file-input" accept=".zip" onchange="handleZipFileSelect(this)">
                    <small style="display: block; margin-top: 5px; color: #666;">Select a ZIP file containing your folder structure with files to create hash rules for</small>
                </div>

                <div class="form-group">
                    <label>Rule Action</label>
                    <select id="zip-rule-action" onchange="if(zipFileData.length > 0) displayZipFileList()">
                        <option value="ALLOW" selected>ALLOW</option>
                        <option value="DENY">DENY</option>
                    </select>
                    <small style="display: block; margin-top: 5px; color: #666;">Select the action for all imported rules</small>
                </div>

                <!-- File List Section -->
                <div id="zip-file-list-section" style="display: none; margin-top: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3>Files in ZIP (<span id="zip-file-count">0</span>)</h3>
                        <div>
                            <button class="btn btn-secondary" onclick="selectAllZipFiles()" style="margin-right: 5px;">Select All</button>
                            <button class="btn btn-secondary" onclick="deselectAllZipFiles()">Deselect All</button>
                        </div>
                    </div>
                    <div id="zip-file-list" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #f8f9fa;">
                        <!-- Files will be listed here -->
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: #e7f3ff; border-radius: 4px;">
                        <strong>Selected:</strong> <span id="zip-selected-count">0</span> files
                    </div>
                </div>

                <!-- Processing Status -->
                <div id="zip-processing-status" style="display: none; margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 4px;">
                    <div id="zip-processing-text">Processing files...</div>
                    <div style="margin-top: 10px;">
                        <div style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden;">
                            <div id="zip-progress-bar" style="background: #667eea; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="zip-progress-text" style="margin-top: 5px; text-align: center; font-size: 0.9em; color: #666;">0%</div>
                    </div>
                </div>

                <!-- Layer Configuration -->
                <div class="form-group" style="margin-top: 15px;">
                    <label>Layer Name</label>
                    <input type="text" id="zip-layer-name" placeholder="e.g., Bulk Import - DLLs - 2024-01-15" value="">
                </div>
                <div class="form-group">
                    <label>Business Justification</label>
                    <textarea id="zip-business-justification" placeholder="Business justification for this bulk import layer" style="min-height: 60px;">Bulk import of files from ZIP archive. Rules created to control execution of unsigned files.</textarea>
                </div>
                <button class="btn btn-primary" onclick="importZipFiles()" id="zip-import-btn" disabled>Import Selected Files as New Layer</button>
                <div id="zip-import-error" style="display: none; margin-top: 10px; padding: 10px; background: #f8d7da; color: #721c24; border-radius: 4px;"></div>
            </div>
        </div>

        <!-- Export Modal -->
        <div id="export-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('export-modal')">&times;</span>
                <h2>Export Policy</h2>
                <div class="form-group">
                    <label>Export Format</label>
                    <select id="export-format">
                        <option value="group_policy">Group Policy XML</option>
                        <option value="intune">Intune JSON</option>
                        <option value="text">Text Summary</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Enforcement Mode</label>
                    <select id="export-enforcement-mode">
                        <option value="Enabled" selected>Enabled (Enforce rules)</option>
                        <option value="AuditOnly">AuditOnly (Log only, don't block)</option>
                        <option value="NotConfigured">NotConfigured (Disabled)</option>
                    </select>
                    <small style="display: block; margin-top: 5px; color: #666;">Applies to all RuleCollections in the exported policy</small>
                </div>
                <div class="form-group" id="export-layer-preservation-group" style="display: none;">
                    <label>
                        <input type="checkbox" id="export-preserve-layers" checked>
                        Preserve Layer Structure
                    </label>
                    <small style="display: block; margin-top: 5px; color: #666;">Include layer metadata in XML comments. Layers will be restored when reimporting. (AppLocker ignores comments, so this doesn't affect policy functionality)</small>
                </div>
                <button class="btn btn-primary" onclick="exportPolicy()">Export</button>
            </div>
        </div>

        <!-- Layer Export Modal -->
        <div id="layer-export-modal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal('layer-export-modal')">&times;</span>
                <h2>Export Layer</h2>
                <div id="layer-export-info" style="margin-bottom: 15px;"></div>
                <div class="form-group">
                    <label>Export Format</label>
                    <select id="layer-export-format">
                        <option value="group_policy">Group Policy XML</option>
                        <option value="intune">Intune JSON</option>
                        <option value="text">Text Summary</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Enforcement Mode</label>
                    <select id="layer-export-enforcement-mode">
                        <option value="Enabled" selected>Enabled (Enforce rules)</option>
                        <option value="AuditOnly">AuditOnly (Log only, don't block)</option>
                        <option value="NotConfigured">NotConfigured (Disabled)</option>
                    </select>
                    <small style="display: block; margin-top: 5px; color: #666;">Applies to all RuleCollections in the exported layer</small>
                </div>
                <button class="btn btn-primary" onclick="exportLayerFromModal()">Export</button>
            </div>
        </div>

    </div>

    <script>
        // Data Storage (using localStorage)
        const STORAGE_KEY = 'applocker_policies';
        let currentPolicyId = null;
        let policies = [];

        // Initialize
        function init() {
            loadPolicies();
        }

        // Load policies from localStorage
        function loadPolicies() {
            const stored = localStorage.getItem(STORAGE_KEY);
            policies = stored ? JSON.parse(stored) : [];
            renderPoliciesList();
        }

        // Save policies to localStorage
        function savePolicies() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(policies));
        }

        // Generate UUID
        function generateId() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Render policies list
        function renderPoliciesList() {
            const container = document.getElementById('policies-list');
            if (policies.length === 0) {
                container.innerHTML = '<p>No policies yet. Create your first policy to get started.</p>';
                return;
            }

            let html = '<table class="table"><thead><tr><th>Policy Name</th><th>System Classes</th><th>Layers</th><th>Rules</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
            policies.forEach(policy => {
                const layerCount = policy.layers ? policy.layers.length : 0;
                const ruleCount = policy.layers ? policy.layers.reduce((sum, layer) => sum + (layer.rules ? layer.rules.length : 0), 0) : 0;
                html += `
                    <tr>
                        <td><strong>${escapeHtml(policy.policy_name)}</strong></td>
                        <td>${policy.system_classes ? policy.system_classes.join(', ') : 'N/A'}</td>
                        <td>${layerCount}</td>
                        <td>${ruleCount}</td>
                        <td><span class="badge badge-info">${policy.status || 'DRAFT'}</span></td>
                        <td>
                            <button class="btn btn-primary" onclick="viewPolicy('${policy.policy_id}')" style="padding: 5px 10px; font-size: 12px;">View</button>
                            <button class="btn btn-danger" onclick="deletePolicy('${policy.policy_id}')" style="padding: 5px 10px; font-size: 12px;">Delete</button>
                        </td>
                    </tr>
                `;
            });
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Show dashboard
        function showDashboard() {
            document.getElementById('dashboard-view').classList.remove('hidden');
            document.getElementById('policy-view').classList.add('hidden');
            currentPolicyId = null;
        }

        // Show create policy modal
        function showCreatePolicy() {
            document.getElementById('create-policy-modal').style.display = 'block';
            document.getElementById('create-policy-form').reset();
        }

        // Create policy
        document.getElementById('create-policy-form').addEventListener('submit', function(e) {
            e.preventDefault();
            const systemClasses = Array.from(document.querySelectorAll('input[name="system-class"]:checked')).map(cb => cb.value);
            
            if (systemClasses.length === 0) {
                alert('Please select at least one system class');
                return;
            }

            const policy = {
                policy_id: generateId(),
                policy_name: document.getElementById('policy-name').value,
                description: document.getElementById('policy-description').value,
                system_classes: systemClasses,
                system_count: parseInt(document.getElementById('system-count').value) || null,
                organization: document.getElementById('organization').value || null,
                status: 'DRAFT',
                created_at: new Date().toISOString(),
                layers: []
            };

            // Generate baseline layer(s) based on system classes
            // If multiple system classes, generate a baseline for each (or merge if similar)
            const baselineLayers = generateBaselineLayers(policy.policy_id, systemClasses);
            baselineLayers.forEach(layer => {
                policy.layers.push(layer);
            });

            policies.push(policy);
            savePolicies();
            closeModal('create-policy-modal');
            viewPolicy(policy.policy_id);
        });

        // Generate baseline layers based on system classes (hardened templates)
        function generateBaselineLayers(policyId, systemClasses) {
            if (!systemClasses || systemClasses.length === 0) {
                // Default to standard workstation baseline if no classes specified
                return [generateBaselineForSystemClass(policyId, 'workstations', 'BASELINE')];
            }

            // Group similar system classes to avoid duplicate baselines
            const classGroups = groupSystemClasses(systemClasses);
            const layers = [];

            classGroups.forEach((group, index) => {
                const primaryClass = group[0];
                const layerName = group.length === 1 
                    ? `BASELINE: ${getSystemClassName(primaryClass)}`
                    : `BASELINE: ${group.map(c => getSystemClassName(c)).join(' / ')}`;
                
                layers.push(generateBaselineForSystemClass(policyId, primaryClass, layerName));
            });

            return layers;
        }

        // Group similar system classes to share baselines
        function groupSystemClasses(classes) {
            // Server types that can share similar baselines
            const serverGroup = ['servers', 'file_server', 'web_server', 'database_server', 'app_server', 'print_server'];
            const hasServerType = classes.some(c => serverGroup.includes(c));
            
            const groups = [];
            const processed = new Set();

            // Group server types together
            if (hasServerType) {
                const serverClasses = classes.filter(c => serverGroup.includes(c) && !processed.has(c));
                if (serverClasses.length > 0) {
                    groups.push(serverClasses);
                    serverClasses.forEach(c => processed.add(c));
                }
            }

            // Each other class gets its own baseline
            classes.forEach(c => {
                if (!processed.has(c)) {
                    groups.push([c]);
                    processed.add(c);
                }
            });

            return groups;
        }

        // Get display name for system class
        function getSystemClassName(classValue) {
            const names = {
                'workstations': 'Workstations',
                'servers': 'Servers',
                'vdi': 'VDI',
                'kiosk': 'Kiosk',
                'pos': 'POS',
                'developer': 'Developer',
                'terminal_server': 'Terminal Server',
                'domain_controller': 'Domain Controller',
                'file_server': 'File Server',
                'web_server': 'Web Server',
                'database_server': 'Database Server',
                'jump_server': 'Jump Server',
                'medical': 'Medical',
                'ics': 'ICS/SCADA',
                'testing': 'Testing/QA',
                'print_server': 'Print Server',
                'app_server': 'Application Server'
            };
            return names[classValue] || classValue;
        }

        // Detect and resolve rule conflicts
        function detectAndResolveConflicts(rules) {
            const resolvedRules = [];
            const conflicts = [];
            
            // Normalize paths for comparison (handle wildcards and environment variables)
            function normalizePath(path) {
                if (!path) return '';
                // Normalize slashes and case, but preserve environment variable format
                let normalized = path.replace(/\\/g, '/').toLowerCase();
                // Normalize common environment variables
                normalized = normalized.replace(/%windir%/gi, '%windir%');
                normalized = normalized.replace(/%programfiles%/gi, '%programfiles%');
                normalized = normalized.replace(/%programfiles\(x86\)%/gi, '%programfiles(x86)%');
                normalized = normalized.replace(/%appdata%/gi, '%appdata%');
                normalized = normalized.replace(/%localappdata%/gi, '%localappdata%');
                normalized = normalized.replace(/%temp%/gi, '%temp%');
                normalized = normalized.replace(/%tmp%/gi, '%tmp%');
                normalized = normalized.replace(/%userprofile%/gi, '%userprofile%');
                return normalized;
            }
            
            // Check if two paths conflict (would match the same files)
            // Returns true if the paths would match overlapping sets of files
            function pathsConflict(path1, path2) {
                const norm1 = normalizePath(path1);
                const norm2 = normalizePath(path2);
                
                // Exact match
                if (norm1 === norm2) return true;
                
                // Universal wildcards match everything (except what's in exceptions)
                if (norm1 === '*' || norm1 === '*/*' || norm1 === '*\\*' || norm1 === '*/*/*') return true;
                if (norm2 === '*' || norm2 === '*/*' || norm2 === '*\\*' || norm2 === '*/*/*') return true;
                
                // If both end with wildcard, check if they're in the same directory
                if (norm1.endsWith('/*') && norm2.endsWith('/*')) {
                    const dir1 = norm1.substring(0, norm1.length - 2);
                    const dir2 = norm2.substring(0, norm2.length - 2);
                    // Same directory = conflict
                    if (dir1 === dir2) return true;
                    // One is parent of other = conflict (e.g., %WINDIR%\* and %WINDIR%\System32\*)
                    if (dir1.startsWith(dir2 + '/') || dir1.startsWith(dir2 + '\\')) return true;
                    if (dir2.startsWith(dir1 + '/') || dir2.startsWith(dir1 + '\\')) return true;
                }
                
                // If one is a parent wildcard and the other is a child, they conflict
                // e.g., %WINDIR%\* conflicts with %WINDIR%\System32\*
                if (norm1.endsWith('/*') && !norm2.endsWith('/*')) {
                    if (norm2.startsWith(norm1.substring(0, norm1.length - 2))) return true;
                }
                if (norm2.endsWith('/*') && !norm1.endsWith('/*')) {
                    if (norm1.startsWith(norm2.substring(0, norm2.length - 2))) return true;
                }
                
                return false;
            }
            
            // Check if a path matches an exception
            function pathMatchesException(path, exceptions) {
                if (!exceptions || exceptions.length === 0) return false;
                return exceptions.some(exp => pathsConflict(path, exp.path || exp));
            }
            
            // Check if two rules conflict
            function rulesConflict(rule1, rule2) {
                // Must be same file category
                if (rule1.file_category !== rule2.file_category) return false;
                
                // Must have opposite actions
                if (rule1.action === rule2.action) return false;
                
                // PATH rules: check path conflicts
                if (rule1.rule_type === 'PATH' && rule2.rule_type === 'PATH') {
                    const path1 = rule1.path;
                    const path2 = rule2.path;
                    
                    // Check if paths conflict
                    if (!pathsConflict(path1, path2)) return false;
                    
                    // If DENY rule has exceptions, check if ALLOW path matches exception
                    if (rule1.action === 'DENY' && rule1.exceptions) {
                        if (pathMatchesException(path2, rule1.exceptions)) {
                            return false; // No conflict, ALLOW is in exception list
                        }
                    }
                    if (rule2.action === 'DENY' && rule2.exceptions) {
                        if (pathMatchesException(path1, rule2.exceptions)) {
                            return false; // No conflict, ALLOW is in exception list
                        }
                    }
                    
                    return true;
                }
                
                // PUBLISHER rules: check publisher conflicts
                if (rule1.rule_type === 'PUBLISHER' && rule2.rule_type === 'PUBLISHER') {
                    if (rule1.publisher_name && rule2.publisher_name) {
                        // Same publisher with opposite actions
                        if (rule1.publisher_name === rule2.publisher_name) {
                            // Check if product/file names conflict
                            const prod1 = rule1.publisher_product || '*';
                            const prod2 = rule2.publisher_product || '*';
                            const file1 = rule1.publisher_file || '*';
                            const file2 = rule2.publisher_file || '*';
                            
                            // If both are wildcards or match, conflict
                            if ((prod1 === '*' || prod2 === '*' || prod1 === prod2) &&
                                (file1 === '*' || file2 === '*' || file1 === file2)) {
                                return true;
                            }
                        }
                    }
                }
                
                // PATH vs PUBLISHER: Generally don't conflict unless path is very specific
                // This is more complex, so we'll be conservative
                return false;
            }
            
            // Helper to check if two rules are duplicates (same rule added twice)
            function isDuplicate(rule1, rule2) {
                if (rule1.rule_type !== rule2.rule_type) return false;
                if (rule1.action !== rule2.action) return false;
                if (rule1.file_category !== rule2.file_category) return false;
                
                if (rule1.rule_type === 'PATH') {
                    return normalizePath(rule1.path) === normalizePath(rule2.path);
                } else if (rule1.rule_type === 'PUBLISHER') {
                    return rule1.publisher_name === rule2.publisher_name &&
                           (rule1.publisher_product || '*') === (rule2.publisher_product || '*') &&
                           (rule1.publisher_file || '*') === (rule2.publisher_file || '*');
                } else if (rule1.rule_type === 'HASH') {
                    return rule1.hash_sha256 === rule2.hash_sha256;
                }
                return false;
            }
            
            // Process rules and detect conflicts
            rules.forEach((rule, index) => {
                let shouldSkip = false;
                
                // Check against already resolved rules
                for (let i = 0; i < resolvedRules.length; i++) {
                    // Check for duplicates first
                    if (isDuplicate(rule, resolvedRules[i])) {
                        shouldSkip = true;
                        break;
                    }
                    
                    // Check for conflicts
                    if (rulesConflict(rule, resolvedRules[i])) {
                        conflicts.push({
                            rule1: rule.rule_name,
                            rule2: resolvedRules[i].rule_name,
                            type: 'conflict'
                        });
                        
                        // Priority: DENY rules take precedence over ALLOW for same path
                        // More specific paths take precedence over wildcards
                        const rule1IsDeny = rule.action === 'DENY';
                        const rule2IsDeny = resolvedRules[i].action === 'DENY';
                        const rule1IsWildcard = rule.path === '*' || rule.path === '*\\*' || rule.path === '*/*';
                        const rule2IsWildcard = resolvedRules[i].path === '*' || resolvedRules[i].path === '*\\*' || resolvedRules[i].path === '*/*';
                        
                        if (rule1IsDeny && !rule2IsDeny) {
                            // Replace ALLOW with DENY
                            resolvedRules[i] = rule;
                            shouldSkip = true;
                        } else if (!rule1IsDeny && rule2IsDeny) {
                            // Keep DENY, skip ALLOW
                            shouldSkip = true;
                        } else if (!rule1IsWildcard && rule2IsWildcard) {
                            // More specific path takes precedence
                            resolvedRules[i] = rule;
                            shouldSkip = true;
                        } else if (rule1IsWildcard && !rule2IsWildcard) {
                            // Keep more specific, skip wildcard
                            shouldSkip = true;
                        } else {
                            // Both same type, keep first one (DENY preferred if both same)
                            shouldSkip = true;
                        }
                        break;
                    }
                }
                
                // If no conflict or duplicate, add the rule
                if (!shouldSkip) {
                    resolvedRules.push(rule);
                }
            });
            
            return {
                rules: resolvedRules,
                conflicts: conflicts
            };
        }

        // Generate hardened baseline for specific system class
        function generateBaselineForSystemClass(policyId, systemClass, layerName) {
            let rules = [];

            switch(systemClass) {
                case 'kiosk':
                    rules = generateKioskBaseline();
                    break;
                case 'pos':
                    rules = generatePOSBaseline();
                    break;
                case 'developer':
                    rules = generateDeveloperBaseline();
                    break;
                case 'terminal_server':
                    rules = generateTerminalServerBaseline();
                    break;
                case 'domain_controller':
                    rules = generateDomainControllerBaseline();
                    break;
                case 'jump_server':
                    rules = generateJumpServerBaseline();
                    break;
                case 'medical':
                    rules = generateMedicalBaseline();
                    break;
                case 'ics':
                    rules = generateICSBaseline();
                    break;
                case 'testing':
                    rules = generateTestingBaseline();
                    break;
                case 'servers':
                case 'file_server':
                case 'web_server':
                case 'database_server':
                case 'app_server':
                case 'print_server':
                    rules = generateServerBaseline(systemClass);
                    break;
                case 'vdi':
                    rules = generateVDIBaseline();
                    break;
                case 'workstations':
                default:
                    rules = generateWorkstationBaseline();
                    break;
            }

            // Detect and resolve conflicts
            const conflictResult = detectAndResolveConflicts(rules);
            const resolvedRules = conflictResult.rules;
            
            // Log conflicts if any (for debugging)
            if (conflictResult.conflicts.length > 0) {
                console.log(`Resolved ${conflictResult.conflicts.length} conflict(s) in ${layerName}:`, conflictResult.conflicts);
            }
            
            return {
                layer_id: generateId(),
                policy_id: policyId,
                layer_type: 'BASELINE',
                layer_name: layerName,
                layer_precedence: 0,
                is_locked: true,
                deviates_from_baseline: false,
                business_justification: `Hardened baseline for ${getSystemClassName(systemClass)} systems`,
                rules: resolvedRules.map(rule => ({
                    rule_id: generateId(),
                    ...rule,
                    user_or_group_sid: rule.user_or_group_sid || 'S-1-1-0',
                    exceptions: rule.exceptions || (rule.rule_type === 'PATH' ? [] : undefined),
                    created_at: new Date().toISOString()
                }))
            };
        }

        // Helper function to generate standard exceptions for %WINDIR% rules
        // These paths are writable by users/attackers and should be blocked even if %WINDIR% is allowed
        function getWindowsSystemExceptions() {
            return [
                { path: '%System32%\\Microsoft\\Crypto\\RSA\\MachineKeys\\*' },
                { path: '%System32%\\spool\\drivers\\color\\*' },
                { path: '%System32%\\Tasks\\*' },
                { path: '%WinDir%\\Tasks\\*' },
                { path: '%WinDir%\\Temp\\*' },
                { path: '%System32%\\Com\\dmp\\*' },
                { path: '%System32%\\FxsTmp\\*' },
                { path: '%System32%\\spool\\*' },
                { path: '%WinDir%\\tracing\\*' },
                // .NET Framework temporary directories (user-writable in some configurations)
                { path: '%WINDIR%\\Microsoft.NET\\*' }
            ];
        }

        // Helper function to generate Microsoft's recommended blocklist
        // NOTE: We do NOT block powershell.exe, rundll32.exe, or regsvr32.exe from system paths
        // as they are required for Windows Update, Group Policy, Control Panel, and system maintenance
        //
        // CRITICAL LIMITATIONS:
        // 1. .NET 4.0+ DLL Rules: AppLocker DLL rules do NOT work for .NET 4.0+ assemblies.
        //    Microsoft broke DLL rule enforcement in .NET 4.0+. Use WDAC or .NET assembly signing instead.
        // 2. Windows 11 24H2 PowerShell Script Enforcement: On Windows 11 24H2 (before May 2025 patches),
        //    AppLocker Script rules fail to enforce Constrained Language Mode. PowerShell scripts run
        //    fully unrestricted. Ensure May 2025 Windows patches are applied before deployment.
        function generateMicrosoftBlocklist() {
            return [
                // Microsoft's Official Blocklist - EXE LOLBins (selective blocking)
                // These DENY rules override ALLOW rules, but we allow system paths for critical tools
                // CRITICAL: mshta.exe allows inline script execution via command-line (e.g., mshta.exe vbscript:...)
                // Block entirely with NO exceptions per Microsoft/NSA recommendation.
                // Attackers use C:\Windows\System32\mshta.exe (the legitimate binary) with inline exploits.
                { rule_name: 'Block mshta.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\mshta.exe', business_justification: ' Microsoft blocklist - HTML Application host (blocks inline script execution bypass, NO EXCEPTIONS)' },
                // CRITICAL: wscript.exe and cscript.exe can execute inline scripts via command-line (bypasses Script rules)
                // Block entirely with NO exceptions per Microsoft/NSA recommendation.
                // NOTE: This may break enterprise apps that use VBScript/JScript. If needed, allow from System32
                // and rely on Script rules to block user-writable script files (see alternative approach below).
                { rule_name: 'Block wscript.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\wscript.exe', business_justification: ' Microsoft blocklist - Windows Script Host (blocks inline script execution bypass, NO EXCEPTIONS - may break VBScript-dependent apps)' },
                { rule_name: 'Block cscript.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\cscript.exe', business_justification: ' Microsoft blocklist - Windows Script Host (blocks inline script execution bypass, NO EXCEPTIONS - may break JScript-dependent apps)' },
                { rule_name: 'Block msbuild.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\msbuild.exe', business_justification: ' Microsoft blocklist - Project compiler' },
                { rule_name: 'Block wmic.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\wmic.exe', business_justification: ' Microsoft blocklist - WMI command-line', exceptions: [{ path: '%WINDIR%\\System32\\wbem\\wmic.exe' }] },
                // PowerShell: Block from user paths but allow from system directory (required for Windows Update, GP)
                { rule_name: 'Block PowerShell from User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\powershell.exe', business_justification: ' Block PowerShell from user-writable paths', exceptions: [{ path: '%WINDIR%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe' }, { path: '%WINDIR%\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe' }] },
                { rule_name: 'Block PowerShell ISE from User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\powershell_ise.exe', business_justification: ' Block PowerShell ISE from user-writable paths', exceptions: [{ path: '%WINDIR%\\System32\\WindowsPowerShell\\v1.0\\powershell_ise.exe' }, { path: '%WINDIR%\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell_ise.exe' }] },
                // rundll32.exe and regsvr32.exe: Block from user paths but allow from system (required for Control Panel, printers, software installation)
                { rule_name: 'Block rundll32.exe from User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\rundll32.exe', business_justification: ' Block rundll32 from user-writable paths', exceptions: [{ path: '%WINDIR%\\System32\\rundll32.exe' }, { path: '%WINDIR%\\SysWOW64\\rundll32.exe' }] },
                { rule_name: 'Block regsvr32.exe from User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\regsvr32.exe', business_justification: ' Block regsvr32 from user-writable paths', exceptions: [{ path: '%WINDIR%\\System32\\regsvr32.exe' }, { path: '%WINDIR%\\SysWOW64\\regsvr32.exe' }] },
                { rule_name: 'Block regasm.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\regasm.exe', business_justification: ' Microsoft blocklist - .NET assembly registration tool' },
                { rule_name: 'Block regsvcs.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\regsvcs.exe', business_justification: ' Microsoft blocklist - .NET service registration tool' },
                { rule_name: 'Block installutil.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\installutil.exe', business_justification: ' Microsoft blocklist - .NET installer utility' },
                { rule_name: 'Block ieexec.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\ieexec.exe', business_justification: ' Microsoft blocklist - .NET ClickOnce launcher' },
                // cmd.exe: Block from user paths but allow from system (required for many system operations)
                { rule_name: 'Block cmd.exe from User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\cmd.exe', business_justification: ' Block cmd.exe from user-writable paths', exceptions: [{ path: '%WINDIR%\\System32\\cmd.exe' }, { path: '%WINDIR%\\SysWOW64\\cmd.exe' }] },
                { rule_name: 'Block wsl.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\wsl.exe', business_justification: ' Microsoft blocklist - WSL bypass' },
                { rule_name: 'Block bash.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\bash.exe', business_justification: ' Microsoft blocklist - WSL bypass' },
                { rule_name: 'Block windbg.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\windbg.exe', business_justification: ' Microsoft blocklist - Debugging tool' },
                { rule_name: 'Block cdb.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\cdb.exe', business_justification: ' Microsoft blocklist - Debugging tool' },
                { rule_name: 'Block ntsd.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\ntsd.exe', business_justification: ' Microsoft blocklist - Debugging tool' },
                { rule_name: 'Block forfiles.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\forfiles.exe', business_justification: ' Microsoft blocklist - File enumeration tool', exceptions: [{ path: '%WINDIR%\\System32\\forfiles.exe' }] },
                // Additional critical LOLBins (Microsoft recommends 40+)
                { rule_name: 'Block presentationhost.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\presentationhost.exe', business_justification: ' Microsoft blocklist - XAML browser, .NET ClickOnce bypass' },
                { rule_name: 'Block msxsl.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\msxsl.exe', business_justification: ' Microsoft blocklist - XSLT processor, script execution' },
                { rule_name: 'Block te.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\te.exe', business_justification: ' Microsoft blocklist - Test Execution, WinDbg component' },
                { rule_name: 'Block csi.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\csi.exe', business_justification: ' Microsoft blocklist - C# Interactive, .NET REPL' },
                { rule_name: 'Block rcsi.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\rcsi.exe', business_justification: ' Microsoft blocklist - Roslyn C# compiler REPL' },
                { rule_name: 'Block dnx.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\dnx.exe', business_justification: ' Microsoft blocklist - .NET execution environment' },
                { rule_name: 'Block odbcconf.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\odbcconf.exe', business_justification: ' Microsoft blocklist - ODBC config, DLL loader', exceptions: [{ path: '%WINDIR%\\System32\\odbcconf.exe' }] },
                { rule_name: 'Block pcalua.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\pcalua.exe', business_justification: ' Microsoft blocklist - Program Compatibility Assistant, UAC bypass', exceptions: [{ path: '%WINDIR%\\System32\\pcalua.exe' }] },
                { rule_name: 'Block atbroker.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\atbroker.exe', business_justification: ' Microsoft blocklist - Assistive Technology, UAC bypass', exceptions: [{ path: '%WINDIR%\\System32\\atbroker.exe' }] },
                { rule_name: 'Block diskshadow.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\diskshadow.exe', business_justification: ' Microsoft blocklist - Volume Shadow Copy, code execution', exceptions: [{ path: '%WINDIR%\\System32\\diskshadow.exe' }] },
                { rule_name: 'Block esentutl.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\esentutl.exe', business_justification: ' Microsoft blocklist - ESE database utility, file copy bypass', exceptions: [{ path: '%WINDIR%\\System32\\esentutl.exe' }] },
                // Block hh.exe (HTML Help) to prevent CHM-based script execution attacks
                { rule_name: 'Block hh.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\hh.exe', business_justification: ' Block HTML Help executable (prevents CHM-based script execution attacks)', exceptions: [{ path: '%WINDIR%\\System32\\hh.exe' }] },
                // Additional critical LOLBins (Microsoft recommends 40+)
                { rule_name: 'Block presentationhost.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\presentationhost.exe', business_justification: ' Microsoft blocklist - XAML browser, .NET ClickOnce bypass' },
                { rule_name: 'Block msxsl.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\msxsl.exe', business_justification: ' Microsoft blocklist - XSLT processor, script execution' },
                { rule_name: 'Block te.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\te.exe', business_justification: ' Microsoft blocklist - Test Execution, WinDbg component' },
                { rule_name: 'Block csi.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\csi.exe', business_justification: ' Microsoft blocklist - C# Interactive, .NET REPL' },
                { rule_name: 'Block rcsi.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\rcsi.exe', business_justification: ' Microsoft blocklist - Roslyn C# compiler REPL' },
                { rule_name: 'Block dnx.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\dnx.exe', business_justification: ' Microsoft blocklist - .NET execution environment' },
                { rule_name: 'Block odbcconf.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\odbcconf.exe', business_justification: ' Microsoft blocklist - ODBC config, DLL loader', exceptions: [{ path: '%WINDIR%\\System32\\odbcconf.exe' }] },
                { rule_name: 'Block pcalua.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\pcalua.exe', business_justification: ' Microsoft blocklist - Program Compatibility Assistant, UAC bypass', exceptions: [{ path: '%WINDIR%\\System32\\pcalua.exe' }] },
                { rule_name: 'Block atbroker.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\atbroker.exe', business_justification: ' Microsoft blocklist - Assistive Technology, UAC bypass', exceptions: [{ path: '%WINDIR%\\System32\\atbroker.exe' }] },
                { rule_name: 'Block diskshadow.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\diskshadow.exe', business_justification: ' Microsoft blocklist - Volume Shadow Copy, code execution', exceptions: [{ path: '%WINDIR%\\System32\\diskshadow.exe' }] },
                { rule_name: 'Block esentutl.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\esentutl.exe', business_justification: ' Microsoft blocklist - ESE database utility, file copy bypass', exceptions: [{ path: '%WINDIR%\\System32\\esentutl.exe' }] },
                { rule_name: 'Block certutil.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\certutil.exe', business_justification: ' Microsoft blocklist - Certificate utility (often abused)', exceptions: [{ path: '%WINDIR%\\System32\\certutil.exe' }] },
                { rule_name: 'Block bitsadmin.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\bitsadmin.exe', business_justification: ' Microsoft blocklist - BITS admin tool', exceptions: [{ path: '%WINDIR%\\System32\\bitsadmin.exe' }] },
                { rule_name: 'Block msiexec.exe', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*\\msiexec.exe', business_justification: ' Block msiexec from user-writable paths', exceptions: [{ path: '%WINDIR%\\System32\\msiexec.exe' }, { path: '%WINDIR%\\SysWOW64\\msiexec.exe' }] },
                
                // Microsoft's Official Blocklist - DLL LOLBins
                { rule_name: 'Block davsvc.dll', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '*\\davsvc.dll', business_justification: ' Microsoft blocklist - WebDAV' },
                { rule_name: 'Block webclnt.dll', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '*\\webclnt.dll', business_justification: ' Microsoft blocklist - WebDAV' },
                // DLL side-loading protection - block known hijackable DLLs from user paths
                { rule_name: 'Block mscoree.dll side-loading', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '*\\mscoree.dll', business_justification: ' Block .NET CLR loader DLL side-loading', exceptions: [{ path: '%WINDIR%\\System32\\mscoree.dll' }, { path: '%WINDIR%\\SysWOW64\\mscoree.dll' }] },
                { rule_name: 'Block cryptbase.dll side-loading', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '*\\cryptbase.dll', business_justification: ' Block Crypto API DLL side-loading', exceptions: [{ path: '%WINDIR%\\System32\\cryptbase.dll' }, { path: '%WINDIR%\\SysWOW64\\cryptbase.dll' }] },
                { rule_name: 'Block sspicli.dll side-loading', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '*\\sspicli.dll', business_justification: ' Block Security Support Provider DLL side-loading', exceptions: [{ path: '%WINDIR%\\System32\\sspicli.dll' }, { path: '%WINDIR%\\SysWOW64\\sspicli.dll' }] },
            ];
        }

        // Standard Workstation Baseline
        function generateWorkstationBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'OS functionality', exceptions: [
                    { path: '%System32%\\Microsoft\\Crypto\\RSA\\MachineKeys\\*' },
                    { path: '%System32%\\spool\\drivers\\color\\*' },
                    { path: '%System32%\\Tasks\\*' },
                    { path: '%WinDir%\\Tasks\\*' },
                    { path: '%WinDir%\\Temp\\*' },
                    { path: '%System32%\\Com\\dmp\\*' },
                    { path: '%System32%\\FxsTmp\\*' },
                    { path: '%System32%\\spool\\*' },
                    { path: '%WinDir%\\tracing\\*' }
                ]},
                { rule_name: 'Allow Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Standard application location' },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: '32-bit application location' },
                
                // Security Guidance: Block execution from all user-writable paths by default
                { rule_name: 'Deny APPDATA', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block execution from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block execution from user-writable paths' },
                { rule_name: 'Deny TEMP', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block execution from temporary paths' },
                { rule_name: 'Deny TMP', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TMP%\\*', business_justification: ' Block execution from temporary paths' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block execution from Downloads folder' },
                { rule_name: 'Deny Desktop', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ' Block execution from Desktop folder' },
                { rule_name: 'Deny PUBLIC', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ' Block execution from Public folder' },
                // Note: INetCache (%LOCALAPPDATA%\Microsoft\Windows\INetCache\*) is already covered by
                // the %LOCALAPPDATA%\* deny rule above. Explicit INetCache rule removed for policy cleanliness.
                // Note: Removable media blocking is better handled via Group Policy Device Control
                // A wildcard deny rule would break network shares, mapped drives, and other fixed disks
                
                // Windows System - DLL (Essential Eight ML3 requirement - DLL rules from day one)
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'OS functionality', exceptions: [
                    { path: '%System32%\\Microsoft\\Crypto\\RSA\\MachineKeys\\*' },
                    { path: '%System32%\\spool\\drivers\\color\\*' },
                    { path: '%System32%\\Tasks\\*' },
                    { path: '%WinDir%\\Tasks\\*' },
                    { path: '%WinDir%\\Temp\\*' },
                    { path: '%System32%\\Com\\dmp\\*' },
                    { path: '%System32%\\FxsTmp\\*' },
                    { path: '%System32%\\spool\\*' },
                    { path: '%WinDir%\\tracing\\*' }
                ]},
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Standard application location' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: '32-bit application location' },
                
                // Security Guidance: Block DLLs from user-writable paths (prevent DLL injection/side-loading)
                { rule_name: 'Deny APPDATA DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block DLL injection from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block DLL side-loading from user-writable paths' },
                { rule_name: 'Deny TEMP DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block DLL loading from temporary paths' },
                { rule_name: 'Deny TMP DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%TMP%\\*', business_justification: ' Block DLL loading from temporary paths' },
                { rule_name: 'Deny Downloads DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block DLL loading from Downloads folder' },
                { rule_name: 'Deny Desktop DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ' Block DLL loading from Desktop folder' },
                { rule_name: 'Deny PUBLIC DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ' Block DLL loading from Public folder' },
                
                // Scripts - Security Guidance: Block scripts from user-writable paths
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny APPDATA Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block scripts from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block scripts from user-writable paths' },
                { rule_name: 'Deny TEMP Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block scripts from temporary paths' },
                { rule_name: 'Deny TMP Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TMP%\\*', business_justification: ' Block scripts from temporary paths' },
                { rule_name: 'Deny Downloads Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block scripts from Downloads folder' },
                { rule_name: 'Deny Desktop Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ' Block scripts from Desktop folder' },
                { rule_name: 'Deny PUBLIC Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ' Block scripts from Public folder' },
                
                // MSI
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'OS functionality' },
                { rule_name: 'Deny APPDATA MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block installers from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block installers from user-writable paths' },
                { rule_name: 'Deny TEMP MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block installers from temporary paths' },
                { rule_name: 'Deny Downloads MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block installers from Downloads folder' },
                
                // APPX
                { rule_name: 'Allow Windows Store Apps', rule_type: 'PATH', file_category: 'APPX', action: 'ALLOW', path: '%PROGRAMFILES%\\WindowsApps\\*', business_justification: 'Windows Store applications' },
                
                // CHM - Note: CHM files are controlled via Exe RuleCollection in AppLocker
                // Redundant deny rules removed: hh.exe is already blocked from user paths, and EXE rules
                // already block execution from %APPDATA% and %USERPROFILE%\Downloads
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'OS functionality - Allow legitimate Windows help files', exceptions: getWindowsSystemExceptions() },
                
                // HTA - Security Guidance: Block all HTA files (high risk)
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: ' HTA files are high risk - block all execution' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Kiosk/Public Access Baseline (Highly Restrictive)
        function generateKioskBaseline() {
            const rules = [
                // Windows System - EXE (minimal, with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System Only', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\System32\\*', business_justification: 'Kiosk: Allow only Windows system executables', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*', business_justification: 'Kiosk: Block all user applications' },
                
                // Security Guidance: Block execution from all user-writable paths by default
                { rule_name: 'Deny APPDATA', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block execution from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block execution from user-writable paths' },
                { rule_name: 'Deny TEMP', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block execution from temporary paths' },
                { rule_name: 'Deny TMP', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TMP%\\*', business_justification: ' Block execution from temporary paths' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block execution from Downloads folder' },
                { rule_name: 'Deny Desktop', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ' Block execution from Desktop folder' },
                { rule_name: 'Deny PUBLIC', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ' Block execution from Public folder' },
                { rule_name: 'Deny Removable Media', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '*', business_justification: 'Kiosk: Block removable media', exceptions: [{ path: '%WINDIR%\\System32\\*' }] },
                { rule_name: 'Deny Internet Browsers', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*browser*.exe', business_justification: 'Kiosk: Block internet browsers' },
                
                // DLL - Essential Eight ML3 requirement (DLL rules from day one)
                { rule_name: 'Allow Windows System DLL Only', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\System32\\*', business_justification: 'Kiosk: Allow only Windows system DLLs', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny APPDATA DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block DLL injection from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block DLL side-loading from user-writable paths' },
                { rule_name: 'Deny TEMP DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block DLL loading from temporary paths' },
                { rule_name: 'Deny TMP DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%TMP%\\*', business_justification: ' Block DLL loading from temporary paths' },
                { rule_name: 'Deny Downloads DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block DLL loading from Downloads folder' },
                { rule_name: 'Deny Desktop DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ' Block DLL loading from Desktop folder' },
                { rule_name: 'Deny PUBLIC DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ' Block DLL loading from Public folder' },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Kiosk: Block user DLLs' },
                
                // Scripts - Deny all
                { rule_name: 'Deny All Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '*', business_justification: 'Kiosk: Block all script execution', exceptions: [{ path: '%WINDIR%\\System32\\*' }] },
                
                // MSI - Deny all
                { rule_name: 'Deny All MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '*', business_justification: 'Kiosk: Block all installations', exceptions: [{ path: '%WINDIR%\\*' }] },
                
                // APPX - Deny all
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'Kiosk: Block all Store apps', exceptions: [{ path: '%PROGRAMFILES%\\WindowsApps\\Microsoft.Windows.*' }] },
                
                // CHM/HTA - Deny all
                { rule_name: 'Deny All CHM', rule_type: 'PATH', file_category: 'CHM', action: 'DENY', path: '*', business_justification: 'Kiosk: Block CHM files' },
                // Scripts - Security Guidance: Block scripts from user-writable paths
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Kiosk: OS functionality' },
                { rule_name: 'Deny APPDATA Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block scripts from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block scripts from user-writable paths' },
                { rule_name: 'Deny TEMP Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block scripts from temporary paths' },
                { rule_name: 'Deny TMP Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TMP%\\*', business_justification: ' Block scripts from temporary paths' },
                { rule_name: 'Deny Downloads Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block scripts from Downloads folder' },
                { rule_name: 'Deny Desktop Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ' Block scripts from Desktop folder' },
                { rule_name: 'Deny PUBLIC Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ' Block scripts from Public folder' },
                
                // MSI
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Kiosk: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny APPDATA MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: ' Block installers from user-writable paths' },
                { rule_name: 'Deny LOCALAPPDATA MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ' Block installers from user-writable paths' },
                { rule_name: 'Deny TEMP MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%TEMP%\\*', business_justification: ' Block installers from temporary paths' },
                { rule_name: 'Deny Downloads MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ' Block installers from Downloads folder' },
                
                // APPX
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'Kiosk: Block Store apps' },
                
                // CHM - Note: CHM files are controlled via Exe RuleCollection in AppLocker
                // Redundant deny rules removed: hh.exe is already blocked from user paths, and EXE rules
                // already block execution from %APPDATA% and %USERPROFILE%\Downloads
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Kiosk: OS functionality - Allow legitimate Windows help files', exceptions: getWindowsSystemExceptions() },
                
                // HTA - Security Guidance: Block all HTA files (high risk)
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: ' HTA files are high risk - block all execution' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Point of Sale (POS) Baseline (PCI-DSS Focused)
        function generatePOSBaseline() {
            const rules = [
                // Windows System - EXE
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'POS: OS functionality' },
                { rule_name: 'Deny Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*', business_justification: 'POS: Block general applications', exceptions: [{ path: '%PROGRAMFILES%\\POS*\\*' }, { path: '%PROGRAMFILES%\\Payment*\\*' }] },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'POS: PCI-DSS - Block user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'POS: PCI-DSS - Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'POS: PCI-DSS - Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'POS: PCI-DSS - Block downloads' },
                { rule_name: 'Deny Internet Browsers', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*browser*.exe', business_justification: 'POS: PCI-DSS - Block browsers' },
                { rule_name: 'Deny File Sharing', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*share*.exe', business_justification: 'POS: PCI-DSS - Block file sharing' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'POS: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'POS: PCI-DSS - Block user DLLs' },
                
                // Scripts - Deny all except Windows
                { rule_name: 'Allow Windows Scripts Only', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'POS: Allow only Windows scripts', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'POS: PCI-DSS - Block user scripts' },
                
                // MSI - Deny all
                { rule_name: 'Deny All MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '*', business_justification: 'POS: PCI-DSS - Block installations', exceptions: [{ path: '%WINDIR%\\*' }] },
                
                // APPX - Deny all
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'POS: PCI-DSS - Block Store apps' },
                
                // CHM/HTA - Deny all
                { rule_name: 'Deny All CHM', rule_type: 'PATH', file_category: 'CHM', action: 'DENY', path: '*', business_justification: 'POS: PCI-DSS - Block CHM' },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'POS: PCI-DSS - Block HTA' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Developer Workstation Baseline (More Permissive for Dev Tools)
        function generateDeveloperBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Developer: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Developer: Standard application location' },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Developer: 32-bit application location' },
                { rule_name: 'Allow Dev Tools in User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%LOCALAPPDATA%\\Programs\\*', business_justification: 'Developer: Allow dev tools (VS Code, Git, etc.)' },
                { rule_name: 'Deny Temp Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Developer: Block temp execution', exceptions: [{ path: '%TEMP%\\*\\node_modules\\*' }] },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'Developer: Block downloads execution' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Developer: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Developer: Standard application location' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Developer: 32-bit application location' },
                { rule_name: 'Allow Dev Tools DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%LOCALAPPDATA%\\Programs\\*', business_justification: 'Developer: Allow dev tool DLLs' },
                
                // Scripts - More permissive
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Developer: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Project Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%USERPROFILE%\\Projects\\*', business_justification: 'Developer: Allow project scripts' },
                { rule_name: 'Allow Dev Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%LOCALAPPDATA%\\Programs\\*', business_justification: 'Developer: Allow dev tool scripts' },
                { rule_name: 'Deny Temp Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Developer: Block temp scripts' },
                
                // MSI - Allow for dev tools
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Developer: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny User MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Developer: Block user MSI' },
                
                // APPX
                { rule_name: 'Allow Windows Store Apps', rule_type: 'PATH', file_category: 'APPX', action: 'ALLOW', path: '%PROGRAMFILES%\\WindowsApps\\*', business_justification: 'Developer: Windows Store applications' },
                
                // CHM/HTA
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Developer: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'Developer: Block HTA files' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Terminal Server / RDS Baseline
        function generateTerminalServerBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Terminal Server: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Terminal Server: Standard application location' },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Terminal Server: 32-bit application location' },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Terminal Server: Block user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'Terminal Server: Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Terminal Server: Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'Terminal Server: Block downloads' },
                { rule_name: 'Deny Local Installation', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\AppData\\Local\\*\\*install*.exe', business_justification: 'Terminal Server: Block local installations' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Terminal Server: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Terminal Server: Standard application location' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Terminal Server: 32-bit application location' },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Terminal Server: Block user DLLs' },
                
                // Scripts
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Terminal Server: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Terminal Server: Block user scripts' },
                { rule_name: 'Deny Temp Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Terminal Server: Block temp scripts' },
                
                // MSI - Deny user installations
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Terminal Server: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Terminal Server: Block user installations' },
                
                // APPX
                { rule_name: 'Allow Windows Store Apps', rule_type: 'PATH', file_category: 'APPX', action: 'ALLOW', path: '%PROGRAMFILES%\\WindowsApps\\*', business_justification: 'Terminal Server: Windows Store applications' },
                
                // CHM/HTA
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Terminal Server: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'Terminal Server: Block HTA files' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Domain Controller Baseline (Highly Restrictive)
        function generateDomainControllerBaseline() {
            const rules = [
                // Windows System - EXE (Windows only, with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System Only', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\System32\\*', business_justification: 'Domain Controller: Allow only Windows system executables', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*', business_justification: 'Domain Controller: Block all applications' },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Domain Controller: Block all user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'Domain Controller: Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Domain Controller: Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'Domain Controller: Block downloads' },
                
                // DLL (Windows only)
                { rule_name: 'Allow Windows System DLL Only', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\System32\\*', business_justification: 'Domain Controller: Allow only Windows system DLLs', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Domain Controller: Block user DLLs' },
                
                // Scripts - Deny all except Windows
                { rule_name: 'Allow Windows Scripts Only', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\System32\\*', business_justification: 'Domain Controller: Allow only Windows scripts', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Domain Controller: Block user scripts' },
                
                // MSI - Deny all
                { rule_name: 'Deny All MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '*', business_justification: 'Domain Controller: Block all installations', exceptions: [{ path: '%WINDIR%\\*' }] },
                
                // APPX - Deny all
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'Domain Controller: Block Store apps' },
                
                // CHM/HTA - Deny all
                { rule_name: 'Deny All CHM', rule_type: 'PATH', file_category: 'CHM', action: 'DENY', path: '*', business_justification: 'Domain Controller: Block CHM' },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'Domain Controller: Block HTA' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Jump Server / Bastion Host Baseline (Highly Restrictive)
        function generateJumpServerBaseline() {
            const rules = [
                // Windows System - EXE
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Jump Server: OS functionality' },
                { rule_name: 'Allow Management Tools Only', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*\\*RDP*.exe', business_justification: 'Jump Server: Allow RDP clients' },
                { rule_name: 'Allow SSH Clients', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*\\*ssh*.exe', business_justification: 'Jump Server: Allow SSH clients' },
                { rule_name: 'Deny All Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*', business_justification: 'Jump Server: Block general applications', exceptions: [{ path: '%PROGRAMFILES%\\*\\*RDP*.exe' }, { path: '%PROGRAMFILES%\\*\\*ssh*.exe' }, { path: '%PROGRAMFILES%\\*\\*putty*.exe' }] },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Jump Server: Block user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'Jump Server: Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Jump Server: Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'Jump Server: Block downloads' },
                { rule_name: 'Deny Internet Browsers', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*browser*.exe', business_justification: 'Jump Server: Block browsers' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Jump Server: OS functionality' },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Jump Server: Block user DLLs' },
                
                // Scripts - Deny all except Windows
                { rule_name: 'Allow Windows Scripts Only', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Jump Server: Allow only Windows scripts' },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Jump Server: Block user scripts' },
                
                // MSI - Deny all
                { rule_name: 'Deny All MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '*', business_justification: 'Jump Server: Block installations', exceptions: [{ path: '%WINDIR%\\*' }] },
                
                // APPX - Deny all
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'Jump Server: Block Store apps' },
                
                // CHM/HTA - Deny all
                { rule_name: 'Deny All CHM', rule_type: 'PATH', file_category: 'CHM', action: 'DENY', path: '*', business_justification: 'Jump Server: Block CHM' },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'Jump Server: Block HTA' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Medical Devices / Healthcare Baseline (HIPAA Focused)
        function generateMedicalBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Medical: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Medical Device Software', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Medical: Allow medical device software', exceptions: [{ path: '%PROGRAMFILES%\\*\\*browser*.exe' }] },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Medical: 32-bit application location' },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Medical: HIPAA - Block user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'Medical: HIPAA - Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'Medical: HIPAA - Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'Medical: HIPAA - Block downloads' },
                { rule_name: 'Deny Internet Browsers', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*browser*.exe', business_justification: 'Medical: HIPAA - Block browsers' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Medical: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Medical: Medical device DLLs' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Medical: 32-bit application location' },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Medical: HIPAA - Block user DLLs' },
                
                // Scripts
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Medical: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Medical: HIPAA - Block user scripts' },
                
                // MSI - Deny all
                { rule_name: 'Deny All MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '*', business_justification: 'Medical: HIPAA - Block installations', exceptions: [{ path: '%WINDIR%\\*' }] },
                
                // APPX - Deny all
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'Medical: HIPAA - Block Store apps' },
                
                // CHM/HTA - Deny all
                { rule_name: 'Deny All CHM', rule_type: 'PATH', file_category: 'CHM', action: 'DENY', path: '*', business_justification: 'Medical: HIPAA - Block CHM' },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'Medical: HIPAA - Block HTA' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Industrial Control Systems (ICS/SCADA) Baseline
        function generateICSBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'ICS: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow ICS Software Only', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'ICS: Allow ICS/SCADA software', exceptions: [{ path: '%PROGRAMFILES%\\*\\*browser*.exe' }, { path: '%PROGRAMFILES%\\*\\*email*.exe' }] },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'ICS: 32-bit application location' },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'ICS: Block user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'ICS: Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'ICS: Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'ICS: Block downloads' },
                { rule_name: 'Deny Internet Browsers', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*browser*.exe', business_justification: 'ICS: Block browsers (air-gapped)' },
                { rule_name: 'Deny Email Clients', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PROGRAMFILES%\\*\\*email*.exe', business_justification: 'ICS: Block email clients' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'ICS: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'ICS: ICS software DLLs' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'ICS: 32-bit application location' },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'ICS: Block user DLLs' },
                
                // Scripts
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'ICS: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'ICS: Block user scripts' },
                
                // MSI - Deny all
                { rule_name: 'Deny All MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '*', business_justification: 'ICS: Block installations', exceptions: [{ path: '%WINDIR%\\*' }] },
                
                // APPX - Deny all
                { rule_name: 'Deny All APPX', rule_type: 'PATH', file_category: 'APPX', action: 'DENY', path: '*', business_justification: 'ICS: Block Store apps' },
                
                // CHM/HTA - Deny all
                { rule_name: 'Deny All CHM', rule_type: 'PATH', file_category: 'CHM', action: 'DENY', path: '*', business_justification: 'ICS: Block CHM' },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'ICS: Block HTA' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Testing/QA Systems Baseline (More Permissive)
        function generateTestingBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Testing: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Testing: Standard application location' },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Testing: 32-bit application location' },
                { rule_name: 'Allow Test Tools', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%LOCALAPPDATA%\\Programs\\*', business_justification: 'Testing: Allow test automation tools' },
                { rule_name: 'Allow Test Directories', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%USERPROFILE%\\Tests\\*', business_justification: 'Testing: Allow test executables' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'Testing: Block downloads execution' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Testing: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'Testing: Standard application location' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'Testing: 32-bit application location' },
                { rule_name: 'Allow Test DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%USERPROFILE%\\Tests\\*', business_justification: 'Testing: Allow test DLLs' },
                
                // Scripts - More permissive
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Testing: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Test Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%USERPROFILE%\\Tests\\*', business_justification: 'Testing: Allow test scripts' },
                { rule_name: 'Allow Automation Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%LOCALAPPDATA%\\Programs\\*', business_justification: 'Testing: Allow automation scripts' },
                
                // MSI
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Testing: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny User MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'Testing: Block user MSI' },
                
                // APPX
                { rule_name: 'Allow Windows Store Apps', rule_type: 'PATH', file_category: 'APPX', action: 'ALLOW', path: '%PROGRAMFILES%\\WindowsApps\\*', business_justification: 'Testing: Windows Store applications' },
                
                // CHM/HTA
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'Testing: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'Testing: Block HTA files' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // Server Baseline (Generic for all server types)
        function generateServerBaseline(serverType) {
            const serverName = getSystemClassName(serverType);
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: `${serverName}: OS functionality`, exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: `${serverName}: Standard application location` },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: `${serverName}: 32-bit application location` },
                
                // Security Guidance: Block execution from all user-writable paths by default
                { rule_name: 'Deny APPDATA', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: ` Block execution from user-writable paths` },
                { rule_name: 'Deny LOCALAPPDATA', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ` Block execution from user-writable paths` },
                { rule_name: 'Deny TEMP', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: ` Block execution from temporary paths` },
                { rule_name: 'Deny TMP', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TMP%\\*', business_justification: ` Block execution from temporary paths` },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ` Block execution from Downloads folder` },
                { rule_name: 'Deny Desktop', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ` Block execution from Desktop folder` },
                { rule_name: 'Deny PUBLIC', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ` Block execution from Public folder` },
                
                // DLL - Essential Eight ML3 requirement (DLL rules from day one)
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: `${serverName}: OS functionality`, exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: `${serverName}: Standard application location` },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: `${serverName}: 32-bit application location` },
                
                // Security Guidance: Block DLLs from user-writable paths (prevent DLL injection/side-loading)
                { rule_name: 'Deny APPDATA DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: ` Block DLL injection from user-writable paths` },
                { rule_name: 'Deny LOCALAPPDATA DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ` Block DLL side-loading from user-writable paths` },
                { rule_name: 'Deny TEMP DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%TEMP%\\*', business_justification: ` Block DLL loading from temporary paths` },
                { rule_name: 'Deny TMP DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%TMP%\\*', business_justification: ` Block DLL loading from temporary paths` },
                { rule_name: 'Deny Downloads DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ` Block DLL loading from Downloads folder` },
                { rule_name: 'Deny Desktop DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ` Block DLL loading from Desktop folder` },
                { rule_name: 'Deny PUBLIC DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ` Block DLL loading from Public folder` },
                
                // Scripts - Security Guidance: Block scripts from user-writable paths
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: `${serverName}: OS functionality`, exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny APPDATA Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: ` Block scripts from user-writable paths` },
                { rule_name: 'Deny LOCALAPPDATA Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ` Block scripts from user-writable paths` },
                { rule_name: 'Deny TEMP Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TEMP%\\*', business_justification: ` Block scripts from temporary paths` },
                { rule_name: 'Deny TMP Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TMP%\\*', business_justification: ` Block scripts from temporary paths` },
                { rule_name: 'Deny Downloads Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ` Block scripts from Downloads folder` },
                { rule_name: 'Deny Desktop Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%USERPROFILE%\\Desktop\\*', business_justification: ` Block scripts from Desktop folder` },
                { rule_name: 'Deny PUBLIC Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%PUBLIC%\\*', business_justification: ` Block scripts from Public folder` },
                
                // MSI
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: `${serverName}: OS functionality` },
                { rule_name: 'Deny APPDATA MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: ` Block installers from user-writable paths` },
                { rule_name: 'Deny LOCALAPPDATA MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: ` Block installers from user-writable paths` },
                { rule_name: 'Deny TEMP MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%TEMP%\\*', business_justification: ` Block installers from temporary paths` },
                { rule_name: 'Deny Downloads MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: ` Block installers from Downloads folder` },
                
                // APPX
                { rule_name: 'Allow Windows Store Apps', rule_type: 'PATH', file_category: 'APPX', action: 'ALLOW', path: '%PROGRAMFILES%\\WindowsApps\\*', business_justification: 'Windows Store applications' },
                
                // CHM - Note: CHM files are controlled via Exe RuleCollection in AppLocker
                // Redundant deny rules removed: hh.exe is already blocked from user paths, and EXE rules
                // already block execution from %APPDATA% and %USERPROFILE%\Downloads
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: `${serverName}: OS functionality - Allow legitimate Windows help files`, exceptions: getWindowsSystemExceptions() },
                
                // HTA - Security Guidance: Block all HTA files (high risk)
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: ' HTA files are high risk - block all execution' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // VDI Baseline
        function generateVDIBaseline() {
            const rules = [
                // Windows System - EXE (with exceptions for writable subdirectories)
                { rule_name: 'Allow Windows System', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'VDI: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'VDI: Standard application location' },
                { rule_name: 'Allow Program Files (x86)', rule_type: 'PATH', file_category: 'EXE', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'VDI: 32-bit application location' },
                { rule_name: 'Deny All User Paths', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'VDI: Block user-writable paths' },
                { rule_name: 'Deny Local AppData', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%LOCALAPPDATA%\\*', business_justification: 'VDI: Block local app data' },
                { rule_name: 'Deny Temp', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%TEMP%\\*', business_justification: 'VDI: Block temporary execution' },
                { rule_name: 'Deny Downloads', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\Downloads\\*', business_justification: 'VDI: Block downloads' },
                { rule_name: 'Deny Local Installation', rule_type: 'PATH', file_category: 'EXE', action: 'DENY', path: '%USERPROFILE%\\AppData\\Local\\*\\*install*.exe', business_justification: 'VDI: Block local installations' },
                
                // DLL
                { rule_name: 'Allow Windows System DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'VDI: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Allow Program Files DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES%\\*', business_justification: 'VDI: Standard application location' },
                { rule_name: 'Allow Program Files (x86) DLL', rule_type: 'PATH', file_category: 'DLL', action: 'ALLOW', path: '%PROGRAMFILES(X86)%\\*', business_justification: 'VDI: 32-bit application location' },
                { rule_name: 'Deny All User DLL', rule_type: 'PATH', file_category: 'DLL', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'VDI: Block user DLLs' },
                
                // Scripts
                { rule_name: 'Allow Windows Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'VDI: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'VDI: Block user scripts' },
                { rule_name: 'Deny Temp Scripts', rule_type: 'PATH', file_category: 'SCRIPT', action: 'DENY', path: '%TEMP%\\*', business_justification: 'VDI: Block temp scripts' },
                
                // MSI
                { rule_name: 'Allow Windows MSI', rule_type: 'PATH', file_category: 'MSI', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'VDI: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All User MSI', rule_type: 'PATH', file_category: 'MSI', action: 'DENY', path: '%APPDATA%\\*', business_justification: 'VDI: Block user installations' },
                
                // APPX
                { rule_name: 'Allow Windows Store Apps', rule_type: 'PATH', file_category: 'APPX', action: 'ALLOW', path: '%PROGRAMFILES%\\WindowsApps\\*', business_justification: 'VDI: Windows Store applications' },
                
                // CHM/HTA
                { rule_name: 'Allow Windows CHM', rule_type: 'PATH', file_category: 'CHM', action: 'ALLOW', path: '%WINDIR%\\*', business_justification: 'VDI: OS functionality', exceptions: getWindowsSystemExceptions() },
                { rule_name: 'Deny All HTA', rule_type: 'PATH', file_category: 'HTA', action: 'DENY', path: '*', business_justification: 'VDI: Block HTA files' },
            ];
            
            // Add Microsoft's recommended blocklist
            rules.push(...generateMicrosoftBlocklist());
            
            return rules;
        }

        // View policy
        function viewPolicy(policyId) {
            currentPolicyId = policyId;
            const policy = policies.find(p => p.policy_id === policyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }

            document.getElementById('dashboard-view').classList.add('hidden');
            document.getElementById('policy-view').classList.remove('hidden');

            document.getElementById('policy-name-header').textContent = policy.policy_name;
            
            // Render summary
            const layerCount = policy.layers ? policy.layers.length : 0;
            const ruleCount = policy.layers ? policy.layers.reduce((sum, layer) => sum + (layer.rules ? layer.rules.length : 0), 0) : 0;
            const deviatingLayers = policy.layers ? policy.layers.filter(l => l.deviates_from_baseline).length : 0;
            
            document.getElementById('policy-summary').innerHTML = `
                <div class="summary-item">
                    <div class="value">${layerCount}</div>
                    <div class="label">Layers</div>
                </div>
                <div class="summary-item">
                    <div class="value">${ruleCount}</div>
                    <div class="label">Total Rules</div>
                </div>
                <div class="summary-item">
                    <div class="value">${deviatingLayers}</div>
                    <div class="label">Deviations</div>
                </div>
                <div class="summary-item">
                    <div class="value">${policy.system_classes ? policy.system_classes.length : 0}</div>
                    <div class="label">System Classes</div>
                </div>
            `;

            // Render layers
            renderLayers(policy);
        }

        // Render layers
        function renderLayers(policy) {
            const container = document.getElementById('layers-container');
            if (!policy.layers || policy.layers.length === 0) {
                container.innerHTML = '<div class="card"><p>No layers yet. Add an application layer to get started.</p></div>';
                return;
            }

            // Sort layers: app layers by precedence, baseline always last (for visual display only)
            const sortedLayers = [...policy.layers].sort((a, b) => {
                const aIsBaseline = a.layer_type === 'BASELINE';
                const bIsBaseline = b.layer_type === 'BASELINE';
                
                // If both are baseline or both are not baseline, sort by precedence
                if (aIsBaseline === bIsBaseline) {
                    return a.layer_precedence - b.layer_precedence;
                }
                
                // Baseline always goes last visually
                return aIsBaseline ? 1 : -1;
            });

            let html = '';
            sortedLayers.forEach(layer => {
                const isBaseline = layer.layer_type === 'BASELINE';
                const isDeviating = layer.deviates_from_baseline;
                const riskLevel = layer.deviation_risk_level;
                
                let cardClass = 'layer-card';
                if (isBaseline) cardClass += ' baseline';
                else if (riskLevel === 'HIGH') cardClass += ' high-risk';
                else if (isDeviating) cardClass += ' deviating';

                html += `<div class="card ${cardClass}" ondrop="handleRuleDrop(event, '${layer.layer_id}')" ondragover="handleRuleDragOver(event)" ondragleave="handleRuleDragLeave(event)">`;
                html += `<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">`;
                html += `<div style="flex: 1;">`;
                html += `<h3 style="margin: 0 0 5px 0;">`;
                html += `<span id="layer-name-display-${layer.layer_id}">${escapeHtml(layer.layer_name)}</span>`;
                html += ` ${isBaseline ? '<span class="badge badge-success">BASELINE</span>' : ''} ${isDeviating ? `<span class="badge badge-${riskLevel?.toLowerCase() || 'warning'}">DEVIATION: ${riskLevel || 'UNKNOWN'}</span>` : ''}`;
                html += `</h3>`;
                if (!isBaseline) {
                    html += `<p style="margin: 5px 0;"><strong>Application:</strong> <span id="layer-app-name-display-${layer.layer_id}">${escapeHtml(layer.app_name || 'N/A')}</span> | <strong>Vendor:</strong> <span id="layer-app-vendor-display-${layer.layer_id}">${escapeHtml(layer.app_vendor || 'N/A')}</span></p>`;
                }
                html += `<p style="margin: 5px 0;"><strong>Business Justification:</strong> <span id="layer-justification-display-${layer.layer_id}">${escapeHtml(layer.business_justification)}</span></p>`;
                html += `</div>`;
                html += `<button class="btn btn-secondary" onclick="editLayerDetails('${layer.layer_id}', event)" style="padding: 8px 15px; font-size: 0.9em; margin-left: 10px; white-space: nowrap;" title="Edit layer details">‚úèÔ∏è Edit Details</button>`;
                html += `</div>`;
                
                // Unified edit form for all layer details
                html += `<div id="layer-details-edit-${layer.layer_id}" style="display: none; margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 4px; border: 1px solid #ddd;">`;
                html += `<h4 style="margin-top: 0; margin-bottom: 15px;">Edit Layer Details</h4>`;
                html += `<div style="margin-bottom: 12px;">`;
                html += `<label style="display: block; margin-bottom: 5px; font-weight: bold;">Layer Name:</label>`;
                html += `<input type="text" id="layer-name-input-${layer.layer_id}" value="${escapeHtml(layer.layer_name)}" style="width: 100%; padding: 8px; font-size: 0.9em; border: 1px solid #ddd; border-radius: 4px;">`;
                html += `</div>`;
                if (!isBaseline) {
                    html += `<div style="margin-bottom: 12px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; font-weight: bold;">Application Name:</label>`;
                    html += `<input type="text" id="layer-app-name-input-${layer.layer_id}" value="${escapeHtml(layer.app_name || '')}" style="width: 100%; padding: 8px; font-size: 0.9em; border: 1px solid #ddd; border-radius: 4px;">`;
                    html += `</div>`;
                    html += `<div style="margin-bottom: 12px;">`;
                    html += `<label style="display: block; margin-bottom: 5px; font-weight: bold;">Vendor:</label>`;
                    html += `<input type="text" id="layer-app-vendor-input-${layer.layer_id}" value="${escapeHtml(layer.app_vendor || '')}" style="width: 100%; padding: 8px; font-size: 0.9em; border: 1px solid #ddd; border-radius: 4px;">`;
                    html += `</div>`;
                }
                html += `<div style="margin-bottom: 12px;">`;
                html += `<label style="display: block; margin-bottom: 5px; font-weight: bold;">Business Justification:</label>`;
                html += `<textarea id="layer-justification-input-${layer.layer_id}" style="width: 100%; padding: 8px; font-size: 0.9em; border: 1px solid #ddd; border-radius: 4px; min-height: 80px; resize: vertical;">${escapeHtml(layer.business_justification)}</textarea>`;
                html += `</div>`;
                html += `<div style="margin-top: 10px;">`;
                html += `<button class="btn btn-primary" onclick="saveLayerDetails('${layer.layer_id}', event)" style="padding: 8px 20px; font-size: 0.9em; margin-right: 10px;">Save</button>`;
                html += `<button class="btn btn-secondary" onclick="cancelEditLayerDetails('${layer.layer_id}', event)" style="padding: 8px 20px; font-size: 0.9em;">Cancel</button>`;
                html += `</div>`;
                html += `</div>`;
                
                if (isDeviating) {
                    html += `<div class="alert alert-warning">`;
                    html += `<strong>Deviation Reason:</strong> ${escapeHtml(layer.deviation_reason || 'N/A')}<br>`;
                    html += `<strong>Risk Level:</strong> <span class="badge badge-${riskLevel?.toLowerCase() || 'warning'}">${riskLevel || 'UNKNOWN'}</span><br>`;
                    html += `<strong>Mitigation:</strong> ${escapeHtml(layer.deviation_mitigation || 'N/A')}`;
                    html += `</div>`;
                }

                const ruleCount = layer.rules ? layer.rules.length : 0;
                html += `<div class="rules-list-header" onclick="toggleRulesList(this)" data-layer-id="${layer.layer_id}">`;
                html += `<strong><span>Rules (${ruleCount})</span></strong>`;
                html += `<span style="font-size: 0.85em; color: #666;">Click to expand/collapse</span>`;
                html += `</div>`;
                html += `<div class="rules-list-container" id="rules-list-${layer.layer_id}">`;
                html += `<div class="rules-list" id="rules-list-inner-${layer.layer_id}" ondrop="handleRuleDrop(event, '${layer.layer_id}')" ondragover="handleRuleDragOver(event)" ondragleave="handleRuleDragLeave(event)">`;
                
                if (layer.rules && layer.rules.length > 0) {
                    layer.rules.forEach((rule, ruleIndex) => {
                        // Add drop zone before each rule (except first)
                        if (ruleIndex === 0) {
                            html += `<div class="rule-drop-zone" data-drop-index="0" data-layer-id="${layer.layer_id}" ondrop="handleRuleDrop(event, '${layer.layer_id}', 0)" ondragover="handleRuleDragOver(event)" ondragleave="handleRuleDragLeave(event)"></div>`;
                        }
                        // Encode JSON for data attribute (escape quotes and special chars)
                        const ruleData = JSON.stringify(rule).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                        const ruleXml = generateStandaloneRuleXML(rule);
                        const ruleXmlEscaped = escapeHtml(ruleXml);
                        const ruleId = rule.rule_id;
                        const layerId = layer.layer_id;
                        
                        // Check if this rule has validation issues
                        if (!window.ruleValidationIssues) {
                            window.ruleValidationIssues = {};
                        }
                        const ruleIssues = window.ruleValidationIssues[ruleId] || [];
                        const hasIssues = ruleIssues.length > 0;
                        const criticalIssues = ruleIssues.filter(i => i.severity === 'FAIL');
                        const hasCriticalIssues = criticalIssues.length > 0;
                        
                        // Build issue description for tooltip
                        let issueTooltip = '';
                        if (hasIssues) {
                            const issueDescriptions = ruleIssues.map(i => `${i.check}: ${i.issue}`).join('; ');
                            issueTooltip = `Validation Issues: ${issueDescriptions}`;
                        }
                        
                        // Add validation issue styling
                        const validationStyle = hasCriticalIssues 
                            ? 'background-color: #ffe6e6; border-left: 4px solid #dc3545;' 
                            : hasIssues 
                                ? 'background-color: #fff3cd; border-left: 4px solid #ffc107;'
                                : '';
                        
                        html += `<div class="rule-item" data-rule-id="${ruleId}" data-layer-id="${layerId}" data-rule-index="${ruleIndex}" data-rule-data="${ruleData}" draggable="true" ondragstart="handleRuleDragStart(event, '${ruleId}', '${layerId}')" ondragend="handleRuleDragEnd(event)" onclick="toggleRuleXML(this, event)" title="${issueTooltip || 'Click to expand/collapse XML'}" style="${validationStyle}">`;
                        
                        // Add validation issue indicator
                        if (hasIssues) {
                            html += `<div style="padding: 5px 10px; background: ${hasCriticalIssues ? '#dc3545' : '#ffc107'}; color: white; font-size: 0.85em; margin-bottom: 5px; border-radius: 3px;">`;
                            html += `<strong>‚ö† Validation Issue${ruleIssues.length > 1 ? 's' : ''}:</strong> `;
                            ruleIssues.forEach((issue, idx) => {
                                html += `${issue.check} - ${issue.issue}`;
                                if (idx < ruleIssues.length - 1) html += '; ';
                            });
                            html += `</div>`;
                        }
                        html += `<div class="rule-item-header">`;
                        html += `<div style="display: flex; align-items: center; gap: 8px;">`;
                        html += `<span class="drag-handle" title="Drag to reorder or move between layers" style="cursor: move; color: #999; font-size: 1.2em; user-select: none;" onmousedown="event.stopPropagation();">‚ò∞</span>`;
                        html += `<div>`;
                        html += `<strong>${escapeHtml(rule.rule_name)}</strong>`;
                        html += `<span class="badge badge-info">${rule.rule_type} - ${rule.file_category}</span>`;
                        html += `</div>`;
                        html += `</div>`;
                        html += `<div class="rule-actions">`;
                        html += `<button class="btn btn-secondary" onclick="toggleRuleEdit(this, event)" style="padding: 5px 12px; font-size: 0.85em;" title="Edit rule">‚úèÔ∏è Edit</button>`;
                        html += `<button class="btn btn-danger" onclick="deleteRule('${ruleId}', '${layerId}', ${isBaseline}, event)" style="padding: 5px 12px; font-size: 0.85em; margin-left: 5px;" title="Delete rule">üóëÔ∏è Delete</button>`;
                        html += `</div>`;
                        html += `</div>`;
                        html += `<div class="rule-item-details">`;
                        html += `<strong>Action:</strong> ${rule.action} | `;
                        html += `<strong>User/Group:</strong> <code>${escapeHtml(rule.user_or_group_sid || 'S-1-1-0')}</code> | `;
                        if (rule.path) html += `<strong>Path:</strong> <code>${escapeHtml(rule.path)}</code> | `;
                        if (rule.publisher_name) html += `<strong>Publisher:</strong> <code>${escapeHtml(rule.publisher_name)}</code> | `;
                        if (rule.hash_sha256) {
                            const hashType = rule.hash_type || 'SHA256';
                            html += `<strong>Hash (${hashType}):</strong> <code>${escapeHtml(rule.hash_sha256.substring(0, 16))}...</code> | `;
                        }
                        if (rule.exceptions && rule.exceptions.length > 0) {
                            html += `<strong>Exceptions:</strong> ${rule.exceptions.length} path(s) | `;
                        }
                        html += `<strong>Justification:</strong> ${escapeHtml(rule.business_justification)}`;
                        html += `</div>`;
                        html += `<div class="rule-xml-toggle">Click to view XML</div>`;
                        html += `<div class="rule-xml-expanded">`;
                        html += `<div class="rule-xml-content">${ruleXmlEscaped}</div>`;
                        html += `<div class="rule-xml-actions">`;
                        html += `<button class="btn btn-primary" onclick="copyRuleXMLInline(this, event)" style="padding: 5px 15px; font-size: 0.9em;">Copy XML</button>`;
                        html += `</div>`;
                        html += `</div>`;
                        // Edit form
                        html += generateRuleEditForm(rule, ruleId, layerId);
                        html += `</div>`;
                        // Add drop zone after each rule
                        html += `<div class="rule-drop-zone" data-drop-index="${ruleIndex + 1}" data-layer-id="${layer.layer_id}" ondrop="handleRuleDrop(event, '${layer.layer_id}', ${ruleIndex + 1})" ondragover="handleRuleDragOver(event)" ondragleave="handleRuleDragLeave(event)"></div>`;
                    });
                } else {
                    html += `<p>No rules in this layer.</p>`;
                    // Add drop zone for empty list
                    html += `<div class="rule-drop-zone" data-drop-index="0" data-layer-id="${layer.layer_id}" ondrop="handleRuleDrop(event, '${layer.layer_id}', 0)" ondragover="handleRuleDragOver(event)" ondragleave="handleRuleDragLeave(event)"></div>`;
                }
                
                html += `</div>`;
                html += `</div>`;
                
                html += `<div style="margin-top: 15px; display: flex; gap: 10px; align-items: center;">`;
                html += `<button class="btn btn-warning" onclick="exportLayer('${layer.layer_id}')" style="padding: 8px 15px;">üì• Export Layer</button>`;
                if (!isBaseline) {
                    html += `<button class="btn btn-danger" onclick="deleteLayer('${layer.layer_id}')" style="padding: 8px 15px;">Delete Layer</button>`;
                }
                html += `</div>`;
                
                html += `</div>`;
            });

            container.innerHTML = html;
        }

        // File processing state
        let currentFile = null;
        let extractedData = null;

        // Show add layer modal
        function showAddLayer() {
            if (!currentPolicyId) {
                alert('No policy selected');
                return;
            }
            document.getElementById('add-layer-modal').style.display = 'block';
            resetAddLayerForm();
            setupDragAndDrop();
            showSingleFileUpload();
        }

        // Show single file upload section
        function showSingleFileUpload() {
            document.getElementById('single-file-section').style.display = 'block';
            document.getElementById('folder-hash-section').style.display = 'none';
            document.getElementById('single-file-btn').classList.remove('btn-secondary');
            document.getElementById('single-file-btn').classList.add('btn-primary');
            document.getElementById('folder-hash-btn').classList.remove('btn-primary');
            document.getElementById('folder-hash-btn').classList.add('btn-secondary');
        }

        // Show folder hash import section
        function showFolderHashImport() {
            document.getElementById('single-file-section').style.display = 'none';
            document.getElementById('folder-hash-section').style.display = 'block';
            document.getElementById('folder-hash-btn').classList.remove('btn-secondary');
            document.getElementById('folder-hash-btn').classList.add('btn-primary');
            document.getElementById('single-file-btn').classList.remove('btn-primary');
            document.getElementById('single-file-btn').classList.add('btn-secondary');
            // Reset zip import state
            if (document.getElementById('zip-file-input')) {
                document.getElementById('zip-file-input').value = '';
            }
            if (document.getElementById('zip-file-list-section')) {
                document.getElementById('zip-file-list-section').style.display = 'none';
                document.getElementById('zip-file-list-section').innerHTML = '';
            }
            if (document.getElementById('zip-processing-status')) {
                document.getElementById('zip-processing-status').style.display = 'none';
            }
            if (document.getElementById('zip-import-error')) {
                document.getElementById('zip-import-error').style.display = 'none';
            }
            if (document.getElementById('zip-import-btn')) {
                document.getElementById('zip-import-btn').disabled = true;
            }
            if (document.getElementById('zip-layer-name')) {
                document.getElementById('zip-layer-name').value = '';
            }
            if (document.getElementById('zip-business-justification')) {
                document.getElementById('zip-business-justification').value = 'Bulk import of files from ZIP archive. Rules created to control execution of unsigned files.';
            }
            zipFileData = [];
            window.zipSkippedFiles = [];
        }

        // Reset add layer form
        function resetAddLayerForm() {
            document.getElementById('app-name').value = '';
            document.getElementById('app-vendor').value = '';
            document.getElementById('install-path').value = '';
            document.getElementById('app-version').value = '';
            document.getElementById('business-justification').value = '';
            document.getElementById('file-info-container').style.display = 'none';
            document.getElementById('process-btn').disabled = true;
            document.getElementById('step-upload').classList.add('active');
            document.getElementById('step-options').classList.remove('active');
            currentFile = null;
            extractedData = null;
        }

        // Setup drag and drop
        function setupDragAndDrop() {
            const dropZone = document.getElementById('drop-zone');
            const fileInput = document.getElementById('file-input');

            // Clear any existing listeners by removing and re-adding
            const newDropZone = dropZone.cloneNode(true);
            dropZone.parentNode.replaceChild(newDropZone, dropZone);
            
            // Re-get elements after clone
            const newDropZoneEl = document.getElementById('drop-zone');
            const newFileInput = document.getElementById('file-input');
            
            newDropZoneEl.onclick = () => newFileInput.click();

            // Prevent default drag behaviors
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            // Drag and drop handlers
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                newDropZoneEl.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                newDropZoneEl.addEventListener(eventName, () => {
                    newDropZoneEl.classList.add('dragover');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                newDropZoneEl.addEventListener(eventName, () => {
                    newDropZoneEl.classList.remove('dragover');
                }, false);
            });

            newDropZoneEl.addEventListener('drop', handleDrop, false);
            newFileInput.addEventListener('change', handleFileSelect, false);
        }

        // Handle file drop
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        // Handle file select
        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        }

        // Handle file
        function handleFile(file) {
            if (!file.name.toLowerCase().endsWith('.exe') && 
                !file.name.toLowerCase().endsWith('.dll') && 
                !file.name.toLowerCase().endsWith('.msi') && 
                !file.name.toLowerCase().endsWith('.appx')) {
                alert('Please select an executable file (.exe, .dll, .msi, or .appx)');
                return;
            }

            currentFile = file;
            
            // Show file info
            document.getElementById('file-name').textContent = file.name;
            document.getElementById('file-size').textContent = formatFileSize(file.size);
            document.getElementById('file-info-container').style.display = 'block';
            document.getElementById('process-btn').disabled = false;

            // Auto-fill app name if empty
            if (!document.getElementById('app-name').value) {
                const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '');
                document.getElementById('app-name').value = nameWithoutExt;
            }
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Clear file
        function clearFile() {
            currentFile = null;
            document.getElementById('file-input').value = '';
            document.getElementById('file-info-container').style.display = 'none';
            document.getElementById('process-btn').disabled = true;
        }

        // Process file and extract information
        async function processFile() {
            if (!currentFile) {
                alert('Please select a file first');
                return;
            }

            const appName = document.getElementById('app-name').value;
            const appVendor = document.getElementById('app-vendor').value;

            if (!appName || !appVendor) {
                alert('Please enter application name and vendor');
                return;
            }

            // Show loading
            document.getElementById('process-btn').disabled = true;
            document.getElementById('process-btn').textContent = 'Processing...';

            try {
                // Read file as ArrayBuffer
                const arrayBuffer = await readFileAsArrayBuffer(currentFile);
                
                // Calculate SHA-256 hash
                const hash = await calculateSHA256(arrayBuffer);
                
                // Extract file path (if available from file object)
                let filePath = document.getElementById('install-path').value;
                if (!filePath && currentFile.path) {
                    filePath = currentFile.path;
                } else if (!filePath) {
                    // Try to infer from file name
                    filePath = `%PROGRAMFILES%\\${appName}\\*`;
                }

                // Extract certificate information
                let publisherInfo = null;
                let isSigned = false;
                let productName = null;
                
                try {
                    const certData = extractCertificateFromPE(arrayBuffer);
                    if (certData) {
                        isSigned = true;
                        const subject = parseCertificateSubject(certData);
                        if (subject) {
                            publisherInfo = formatPublisherString(subject);
                            productName = subject.CN || appName.toUpperCase();
                        }
                    }
                } catch (certError) {
                    console.log('Certificate extraction failed (file may not be signed):', certError);
                    // Continue without certificate
                }

                // Store extracted data
                extractedData = {
                    file_name: currentFile.name,
                    file_size: currentFile.size,
                    hash_sha256: hash,
                    install_path: filePath,
                    is_signed: isSigned,
                    publisher_info: publisherInfo,
                    product_name: productName,
                    app_name: appName,
                    app_vendor: appVendor,
                    version: document.getElementById('app-version').value || null
                };

                // Show options step
                showExtractedOptions();
            } catch (error) {
                alert('Error processing file: ' + error.message);
                document.getElementById('process-btn').disabled = false;
                document.getElementById('process-btn').textContent = 'Extract Information';
            }
        }

        // Read file as ArrayBuffer
        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }

        // Calculate SHA-256 hash
        async function calculateSHA256(arrayBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Extract certificate from PE file
        function extractCertificateFromPE(arrayBuffer) {
            const view = new DataView(arrayBuffer);
            
            // Check DOS header
            if (view.getUint16(0, true) !== 0x5A4D) { // 'MZ'
                return null;
            }
            
            // Get PE header offset
            const peOffset = view.getUint32(0x3C, true);
            
            // Check PE signature
            if (view.getUint32(peOffset, true) !== 0x00004550) { // 'PE\0\0'
                return null;
            }
            
            // Get machine type (0x014C = x86, 0x8664 = x64)
            const machine = view.getUint16(peOffset + 4, true);
            const is64bit = machine === 0x8664;
            
            // Get optional header offset
            const optionalHeaderOffset = peOffset + 24;
            const magic = view.getUint16(optionalHeaderOffset, true);
            
            // Get data directories offset
            let dataDirectoriesOffset;
            if (magic === 0x10B) { // PE32
                dataDirectoriesOffset = optionalHeaderOffset + 96;
            } else if (magic === 0x20B) { // PE32+
                dataDirectoriesOffset = optionalHeaderOffset + 112;
            } else {
                return null;
            }
            
            // Certificate table is at index 4 in data directories
            const certTableRVA = view.getUint32(dataDirectoriesOffset + 32, true);
            const certTableSize = view.getUint32(dataDirectoriesOffset + 36, true);
            
            if (certTableRVA === 0 || certTableSize === 0) {
                return null; // No certificate
            }
            
            // Certificate table is at file offset (RVA for certificates is file offset)
            const certOffset = certTableRVA;
            
            // Read certificate (first 8 bytes are length, then the certificate)
            const certLength = view.getUint32(certOffset, true);
            if (certLength === 0 || certLength > certTableSize) {
                return null;
            }
            
            // Extract certificate data (skip 8 byte header)
            const certData = new Uint8Array(arrayBuffer, certOffset + 8, certLength);
            return certData;
        }

        // Parse X.509 certificate to extract subject
        function parseCertificateSubject(certData) {
            try {
                // Basic ASN.1 DER parser for certificate subject
                // Certificate structure: SEQUENCE { tbsCertificate, signatureAlgorithm, signature }
                // tbsCertificate contains: version, serialNumber, signature, issuer, validity, subject, ...
                
                const view = new DataView(certData.buffer, certData.byteOffset, certData.byteLength);
                let offset = 0;
                
                // Read SEQUENCE tag
                if (view.getUint8(offset) !== 0x30) return null;
                offset++;
                
                // Read length
                const seqLength = readASN1Length(view, offset);
                offset = seqLength.offset;
                
                // Skip to subject (we'll search for it)
                // Subject is typically around offset 200-500 in a typical cert
                // Look for subject tag (0x30) followed by SET (0x31) and then name components
                
                const subject = extractSubjectFromCert(certData);
                return subject;
            } catch (e) {
                console.error('Error parsing certificate:', e);
                return null;
            }
        }

        // Read ASN.1 length
        function readASN1Length(view, offset) {
            const firstByte = view.getUint8(offset);
            offset++;
            
            if ((firstByte & 0x80) === 0) {
                return { length: firstByte, offset };
            }
            
            const lengthBytes = firstByte & 0x7F;
            let length = 0;
            for (let i = 0; i < lengthBytes; i++) {
                length = (length << 8) | view.getUint8(offset);
                offset++;
            }
            return { length, offset };
        }

        // Extract subject from certificate (simplified parser)
        function extractSubjectFromCert(certData) {
            // Search for subject name components
            // Look for common name (CN=), organization (O=), locality (L=), state (ST=), country (C=)
            const subject = {
                CN: null,
                O: null,
                L: null,
                ST: null,
                C: null
            };
            
            // Convert to string and search for patterns (simplified approach)
            const text = new TextDecoder('latin1').decode(certData);
            
            // Try to find subject using common patterns
            // Look for UTF8String tags (0x0C) followed by readable text
            const view = new DataView(certData.buffer, certData.byteOffset, certData.byteLength);
            
            // Search for subject sequence (more reliable)
            let found = false;
            for (let i = 0; i < certData.length - 100; i++) {
                // Look for sequence that might be subject
                if (view.getUint8(i) === 0x30) {
                    const len = readASN1Length(view, i + 1);
                    if (len.length > 20 && len.length < 500) {
                        // Try to extract readable strings from this sequence
                        const subj = tryExtractSubjectString(certData, i);
                        if (subj) {
                            // Parse subject string (format: CN=...,O=...,L=...,ST=...,C=...)
                            const parts = subj.split(',');
                            parts.forEach(part => {
                                const [key, value] = part.split('=');
                                if (key && value) {
                                    const k = key.trim();
                                    const v = value.trim();
                                    if (k === 'CN') subject.CN = v;
                                    else if (k === 'O') subject.O = v;
                                    else if (k === 'L') subject.L = v;
                                    else if (k === 'ST' || k === 'S') subject.ST = v;
                                    else if (k === 'C') subject.C = v;
                                }
                            });
                            found = true;
                            break;
                        }
                    }
                }
            }
            
            // If not found, try alternative: look for readable text patterns
            if (!found) {
                // Search for common patterns in the binary
                const patterns = [
                    /O\s*=\s*([^,]+)/i,
                    /CN\s*=\s*([^,]+)/i,
                    /L\s*=\s*([^,]+)/i,
                    /ST\s*=\s*([^,]+)/i,
                    /C\s*=\s*([^,]+)/i
                ];
                
                // Try different encodings
                const encodings = ['latin1', 'utf-8'];
                for (const encoding of encodings) {
                    try {
                        const text = new TextDecoder(encoding, { fatal: false }).decode(certData);
                        const match = text.match(/O\s*=\s*([^,\x00]+)/i);
                        if (match) {
                            subject.O = match[1].trim();
                            // Try to find more fields
                            const cnMatch = text.match(/CN\s*=\s*([^,\x00]+)/i);
                            if (cnMatch) subject.CN = cnMatch[1].trim();
                            const lMatch = text.match(/L\s*=\s*([^,\x00]+)/i);
                            if (lMatch) subject.L = lMatch[1].trim();
                            const stMatch = text.match(/ST\s*=\s*([^,\x00]+)/i);
                            if (stMatch) subject.ST = stMatch[1].trim();
                            const cMatch = text.match(/C\s*=\s*([^,\x00]+)/i);
                            if (cMatch) subject.C = cMatch[1].trim();
                            found = true;
                            break;
                        }
                    } catch (e) {
                        // Continue with next encoding
                    }
                }
            }
            
            return found && (subject.O || subject.CN) ? subject : null;
        }

        // Try to extract subject string from certificate data
        function tryExtractSubjectString(certData, startOffset) {
            const view = new DataView(certData.buffer, certData.byteOffset + startOffset, certData.byteLength - startOffset);
            let offset = 0;
            
            try {
                // Read sequence
                if (view.getUint8(offset) !== 0x30) return null;
                offset++;
                const seqLen = readASN1Length(view, offset);
                offset = seqLen.offset;
                
                // Look for UTF8String or PrintableString containing subject
                const maxSearch = Math.min(seqLen.length, 1000);
                for (let i = offset; i < offset + maxSearch - 10; i++) {
                    const tag = view.getUint8(i);
                    // UTF8String = 0x0C, PrintableString = 0x13, IA5String = 0x16
                    if (tag === 0x0C || tag === 0x13 || tag === 0x16) {
                        const len = readASN1Length(view, i + 1);
                        if (len.length > 5 && len.length < 500) {
                            // Try to decode as string
                            const strStart = len.offset;
                            const strEnd = strStart + len.length;
                            if (strEnd <= view.byteLength) {
                                try {
                                    const str = new TextDecoder('utf-8', { fatal: false }).decode(
                                        new Uint8Array(view.buffer, view.byteOffset + strStart, len.length)
                                    );
                                    // Check if it looks like a subject string
                                    if (str.includes('=') && (str.includes('CN=') || str.includes('O='))) {
                                        return str;
                                    }
                                } catch (e) {
                                    // Try latin1
                                    try {
                                        const str = new TextDecoder('latin1', { fatal: false }).decode(
                                            new Uint8Array(view.buffer, view.byteOffset + strStart, len.length)
                                        );
                                        if (str.includes('=') && (str.includes('CN=') || str.includes('O='))) {
                                            return str;
                                        }
                                    } catch (e2) {
                                        // Continue
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                return null;
            }
            
            return null;
        }

        // Format subject as AppLocker publisher string
        function formatPublisherString(subject) {
            const parts = [];
            if (subject.O) parts.push(`O=${subject.O.toUpperCase()}`);
            if (subject.L) parts.push(`L=${subject.L.toUpperCase()}`);
            if (subject.ST) parts.push(`S=${subject.ST.toUpperCase()}`);
            if (subject.C) parts.push(`C=${subject.C.toUpperCase()}`);
            
            return parts.length > 0 ? parts.join(', ') : null;
        }

        // Show extracted options
        function showExtractedOptions() {
            const container = document.getElementById('extracted-info-container');
            
            let html = '<div class="extracted-info">';
            html += '<h4>Extracted Information</h4>';
            
            // Hash option
            html += '<div class="info-item">';
            html += '<label>';
            html += '<input type="checkbox" id="option-hash" name="rule-option" value="hash">';
            html += '<div>';
            html += '<strong>HASH Rule (SHA-256)</strong><br>';
            html += '<small>Pins specific file version. Requires updates when file changes.</small>';
            html += '<div class="info-item-code">' + extractedData.hash_sha256 + '</div>';
            html += '</div>';
            html += '</label>';
            html += '</div>';

            // Path option
            html += '<div class="info-item">';
            html += '<label>';
            html += '<input type="checkbox" id="option-path" name="rule-option" value="path" checked>';
            html += '<div>';
            html += '<strong>PATH Rule</strong><br>';
            html += '<small>Allows files from specific location. Works with updates if path is stable.</small>';
            html += '<div class="info-item-code">' + escapeHtml(extractedData.install_path) + '</div>';
            html += '<input type="text" id="path-input" value="' + escapeHtml(extractedData.install_path) + '" style="margin-top: 5px; width: 100%; padding: 5px;" onchange="extractedData.install_path = this.value">';
            html += '</div>';
            html += '</label>';
            html += '</div>';

            // Publisher option
            html += '<div class="info-item">';
            html += '<label>';
            if (extractedData.is_signed && extractedData.publisher_info) {
                html += '<input type="checkbox" id="option-publisher" name="rule-option" value="publisher" checked>';
                html += '<div>';
                html += '<strong>PUBLISHER Rule (Code Signature) ‚úì Extracted</strong><br>';
                html += '<small>Allows signed executables from specific publisher. Best for updates.</small>';
                html += '<div class="info-item-code" style="margin-top: 5px; background: #d4edda; padding: 8px;">';
                html += '<strong>Publisher:</strong> ' + escapeHtml(extractedData.publisher_info) + '<br>';
                html += '<strong>Product:</strong> ' + escapeHtml(extractedData.product_name || extractedData.app_name.toUpperCase());
                html += '</div>';
                html += '<div style="margin-top: 10px;">';
                html += '<input type="text" id="publisher-name-input" value="' + escapeHtml(extractedData.publisher_info) + '" style="width: 100%; padding: 5px; margin-bottom: 5px;" title="Publisher information extracted from certificate. You can edit if needed.">';
                html += '<input type="text" id="publisher-product-input" value="' + escapeHtml(extractedData.product_name || extractedData.app_name.toUpperCase()) + '" style="width: 100%; padding: 5px; margin-bottom: 5px;">';
                html += '<input type="text" id="publisher-file-input" value="*.exe" placeholder="*.exe or specific filename" style="width: 100%; padding: 5px;">';
                html += '</div>';
            } else {
                html += '<input type="checkbox" id="option-publisher" name="rule-option" value="publisher">';
                html += '<div>';
                html += '<strong>PUBLISHER Rule (Code Signature)</strong><br>';
                html += '<small>File is not signed or certificate could not be extracted. Manual entry required.</small>';
                html += '<div style="margin-top: 10px;">';
                html += '<input type="text" id="publisher-name-input" placeholder="O=COMPANY NAME, L=CITY, S=STATE, C=US" style="width: 100%; padding: 5px; margin-bottom: 5px;">';
                html += '<input type="text" id="publisher-product-input" placeholder="Product Name" value="' + escapeHtml(extractedData.app_name.toUpperCase()) + '" style="width: 100%; padding: 5px; margin-bottom: 5px;">';
                html += '<input type="text" id="publisher-file-input" placeholder="*.exe or specific filename" value="*.exe" style="width: 100%; padding: 5px;">';
                html += '</div>';
            }
            html += '</div>';
            html += '</label>';
            html += '</div>';

            html += '</div>';

            container.innerHTML = html;

            // Switch to options step
            document.getElementById('step-upload').classList.remove('active');
            document.getElementById('step-options').classList.add('active');
            document.getElementById('process-btn').disabled = false;
            document.getElementById('process-btn').textContent = 'Extract Information';
        }

        // Back to upload step
        function backToUpload() {
            document.getElementById('step-upload').classList.add('active');
            document.getElementById('step-options').classList.remove('active');
        }

        // Create layer from selected options
        function createLayerFromOptions() {
            if (!currentPolicyId) return;

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) return;

            const appName = document.getElementById('app-name').value;
            const appVendor = document.getElementById('app-vendor').value;
            const businessJustification = document.getElementById('business-justification').value;

            if (!appName || !appVendor || !businessJustification) {
                alert('Please fill in all required fields');
                return;
            }

            // Get selected rule options
            const selectedOptions = Array.from(document.querySelectorAll('input[name="rule-option"]:checked')).map(cb => cb.value);
            
            if (selectedOptions.length === 0) {
                alert('Please select at least one rule type');
                return;
            }

            const generateExe = document.getElementById('generate-exe').checked;
            const generateDll = document.getElementById('generate-dll').checked;

            if (!generateExe && !generateDll) {
                alert('Please select at least one file category (EXE or DLL)');
                return;
            }

            // Generate rules based on selected options
            const rules = [];
            const installPath = document.getElementById('path-input') ? document.getElementById('path-input').value : extractedData.install_path;

            selectedOptions.forEach(option => {
                if (option === 'hash') {
                    const hashType = 'SHA256'; // Default, can be changed in editor
                    const fileLength = extractedData.file_size || 0;
                    if (generateExe) {
                        rules.push({
                            rule_id: generateId(),
                            rule_name: `Allow ${appName} (EXE) - HASH`,
                            rule_type: 'HASH',
                            file_category: 'EXE',
                            action: 'ALLOW',
                            user_or_group_sid: 'S-1-1-0',
                            hash_sha256: extractedData.hash_sha256,
                            hash_type: hashType,
                            hash_file_length: fileLength,
                            source_file_length: fileLength,
                            hash_filename: extractedData.file_name,
                            hash_file_version: extractedData.version || null,
                            business_justification: `Allow ${appName} EXE by hash`
                        });
                    }
                    if (generateDll) {
                        rules.push({
                            rule_id: generateId(),
                            rule_name: `Allow ${appName} (DLL) - HASH`,
                            rule_type: 'HASH',
                            file_category: 'DLL',
                            action: 'ALLOW',
                            user_or_group_sid: 'S-1-1-0',
                            hash_sha256: extractedData.hash_sha256,
                            hash_type: hashType,
                            hash_file_length: fileLength,
                            source_file_length: fileLength,
                            hash_filename: extractedData.file_name,
                            hash_file_version: extractedData.version || null,
                            business_justification: `Allow ${appName} DLL by hash`
                        });
                    }
                } else if (option === 'path') {
                    // Normalize path: if it's a directory path (doesn't end with .exe/.dll), ensure it ends with \*
                    let normalizedPath = installPath.trim();
                    if (normalizedPath && !normalizedPath.match(/\.(exe|dll|msi|appx|chm|hta|ps1|bat|cmd|vbs|js)$/i) && !normalizedPath.endsWith('*')) {
                        // It's a directory path, ensure it ends with \* or /*
                        if (!normalizedPath.endsWith('\\*') && !normalizedPath.endsWith('/*')) {
                            normalizedPath = normalizedPath.replace(/[\\/]*$/, '') + '\\*';
                        }
                    }
                    
                    if (generateExe) {
                        rules.push({
                            rule_id: generateId(),
                            rule_name: `Allow ${appName} (EXE) - PATH`,
                            rule_type: 'PATH',
                            file_category: 'EXE',
                            action: 'ALLOW',
                            user_or_group_sid: 'S-1-1-0',
                            path: normalizedPath,
                            exceptions: [], // Can be added in editor
                            business_justification: `Allow ${appName} EXE from ${normalizedPath}`
                        });
                    }
                    if (generateDll) {
                        rules.push({
                            rule_id: generateId(),
                            rule_name: `Allow ${appName} (DLL) - PATH`,
                            rule_type: 'PATH',
                            file_category: 'DLL',
                            action: 'ALLOW',
                            user_or_group_sid: 'S-1-1-0',
                            path: normalizedPath,
                            exceptions: [], // Can be added in editor
                            business_justification: `Allow ${appName} DLL from ${normalizedPath}`
                        });
                    }
                } else if (option === 'publisher') {
                    const publisherName = document.getElementById('publisher-name-input').value;
                    const publisherProduct = document.getElementById('publisher-product-input').value || appName.toUpperCase();
                    const publisherFile = document.getElementById('publisher-file-input').value || '*.exe';

                    if (!publisherName) {
                        alert('Please enter publisher name for PUBLISHER rule');
                        return;
                    }

                    if (generateExe) {
                        rules.push({
                            rule_id: generateId(),
                            rule_name: `Allow ${appName} (EXE) - PUBLISHER`,
                            rule_type: 'PUBLISHER',
                            file_category: 'EXE',
                            action: 'ALLOW',
                            user_or_group_sid: 'S-1-1-0',
                            publisher_name: publisherName,
                            publisher_product: publisherProduct,
                            publisher_file: publisherFile,
                            version_low: extractedData.version || '0.0.0.0',
                            version_high: '*',
                            business_justification: `Allow ${appName} EXE signed by ${publisherName}`
                        });
                    }
                    if (generateDll) {
                        rules.push({
                            rule_id: generateId(),
                            rule_name: `Allow ${appName} (DLL) - PUBLISHER`,
                            rule_type: 'PUBLISHER',
                            file_category: 'DLL',
                            action: 'ALLOW',
                            user_or_group_sid: 'S-1-1-0',
                            publisher_name: publisherName,
                            publisher_product: publisherProduct,
                            publisher_file: '*.dll',
                            version_low: extractedData.version || '0.0.0.0',
                            version_high: '*',
                            business_justification: `Allow ${appName} DLL signed by ${publisherName}`
                        });
                    }
                }
            });

            // Analyze app for deviations
            const analysis = analyzeApp({
                app_name: appName,
                app_vendor: appVendor,
                install_path: installPath,
                version: extractedData.version,
                is_signed: selectedOptions.includes('publisher')
            });

            // Create layer
            const nextPrecedence = policy.layers.length;
            const layer = {
                layer_id: generateId(),
                policy_id: currentPolicyId,
                layer_type: 'APP',
                layer_name: `APP: ${appName}`,
                layer_precedence: nextPrecedence,
                app_name: appName,
                app_vendor: appVendor,
                deviates_from_baseline: analysis.deviates_from_baseline,
                deviation_reason: analysis.deviation_reason,
                deviation_risk_level: analysis.deviation_risk_level,
                deviation_mitigation: analysis.deviation_mitigation,
                requires_ntfs_hardening: analysis.recommendation.requires_ntfs_hardening,
                business_justification: businessJustification,
                is_locked: false,
                rules: rules
            };

            policy.layers.push(layer);
            savePolicies();
            closeModal('add-layer-modal');
            viewPolicy(currentPolicyId);
        }

        // Analyze app against baseline
        function analyzeApp(app) {
            const isUserWritable = isUserWritablePath(app.install_path);
            const isBaselineAllowed = isPathAllowedByBaseline(app.install_path);
            
            let deviates = false;
            let deviationReason = null;
            let riskLevel = null;
            let mitigation = null;
            let ruleType = 'PUBLISHER';
            let requiresNTFS = false;

            if (isUserWritable && !isBaselineAllowed) {
                deviates = true;
                if (app.is_signed) {
                    deviationReason = 'Runs from user-writable path (%LOCALAPPDATA%, %APPDATA%, etc.)';
                    riskLevel = 'LOW';
                    mitigation = 'PUBLISHER rule ensures only signed code runs here';
                    ruleType = 'PUBLISHER';
                } else {
                    deviationReason = 'Unsigned code in user-writable path';
                    riskLevel = 'HIGH';
                    mitigation = 'PATH rule with NTFS hardening verification required';
                    ruleType = 'PATH';
                    requiresNTFS = true;
                }
            } else if (!app.is_signed && !isUserWritable) {
                deviates = true;
                deviationReason = 'Unsigned executable (baseline prefers signed)';
                riskLevel = 'MEDIUM';
                mitigation = 'PATH rule with NTFS hardening verification';
                ruleType = 'PATH';
                requiresNTFS = true;
            } else if (app.is_signed && !isUserWritable) {
                // Signed app in standard location - no deviation
                ruleType = 'PUBLISHER';
            }

            return {
                is_signed: app.is_signed,
                is_baseline_compatible: !deviates,
                is_user_writable: isUserWritable,
                deviates_from_baseline: deviates,
                deviation_reason: deviationReason,
                deviation_risk_level: riskLevel,
                deviation_mitigation: mitigation,
                recommendation: {
                    rule_type: ruleType,
                    requires_ntfs_hardening: requiresNTFS,
                    requires_ciso: riskLevel === 'HIGH',
                    sustainability_hours_per_year: ruleType === 'HASH' ? 5 : 0
                },
                guidance: generateGuidance(app, deviates, riskLevel, ruleType)
            };
        }

        // Check if path is user-writable
        function isUserWritablePath(path) {
            const userPaths = ['%APPDATA%', '%LOCALAPPDATA%', '%TEMP%', '%USERPROFILE%', '%DOWNLOADS%'];
            return userPaths.some(up => path.toUpperCase().includes(up));
        }

        // Check if path is allowed by baseline
        function isPathAllowedByBaseline(path) {
            const allowedPaths = ['%WINDIR%', '%PROGRAMFILES%', '%PROGRAMFILES(X86)%'];
            return allowedPaths.some(ap => path.toUpperCase().includes(ap));
        }

        // Generate guidance
        function generateGuidance(app, deviates, riskLevel, ruleType) {
            if (!deviates) {
                return {
                    title: 'Baseline Compatible',
                    explanation: 'This application is compatible with the baseline policy. No deviations required.',
                    options: []
                };
            }

            if (riskLevel === 'HIGH') {
                return {
                    title: 'High Risk Deviation',
                    explanation: `${app.app_name} is unsigned and runs from a user-writable path. This is a HIGH risk configuration.`,
                    options: [
                        {
                            option: 'A',
                            title: 'Request vendor signature (Best)',
                            description: 'Ask the vendor to code-sign their application. Once signed, you can use a PUBLISHER rule.',
                            effort: 'Unknown (vendor negotiation)'
                        },
                        {
                            option: 'B',
                            title: 'PATH rule + NTFS hardening (Recommended)',
                            description: 'Use a PATH rule with strict NTFS permissions. Risk: MEDIUM (mitigated by hardening).',
                            effort: 'Low (verify NTFS permissions)'
                        },
                        {
                            option: 'C',
                            title: 'HASH rule (High maintenance)',
                            description: 'Create HASH rule pinning specific version. Updates require hash regeneration.',
                            effort: 'High (ongoing maintenance)'
                        }
                    ]
                };
            } else if (riskLevel === 'MEDIUM') {
                return {
                    title: 'Unsigned Executable in Standard Location',
                    explanation: `${app.app_name} is unsigned. Baseline prefers signed software because it survives updates automatically.`,
                    options: [
                        {
                            option: 'A',
                            title: 'PATH rule + NTFS hardening (Recommended)',
                            description: 'Use a PATH rule with NTFS permissions preventing modification.',
                            effort: 'Low (verify NTFS permissions)'
                        },
                        {
                            option: 'B',
                            title: 'Request vendor signature (Best)',
                            description: 'Ask the vendor to code-sign their application.',
                            effort: 'Unknown (vendor negotiation)'
                        }
                    ]
                };
            } else {
                return {
                    title: 'Signed App in User Path',
                    explanation: `${app.app_name} runs from a user-writable path but is code-signed. A PUBLISHER rule will ensure only signed code runs.`,
                    options: [
                        {
                            option: 'A',
                            title: 'PUBLISHER rule (Recommended)',
                            description: 'Use PUBLISHER rule to allow only signed versions of this app.',
                            effort: 'Low (automatic updates supported)'
                        }
                    ]
                };
            }
        }

        // Show analysis results
        function showAnalysisResults(analysis, onConfirm) {
            const modal = document.getElementById('analysis-modal');
            const container = document.getElementById('analysis-results');
            
            let html = '';
            
            if (analysis.deviates_from_baseline) {
                html += `<div class="alert alert-${analysis.deviation_risk_level === 'HIGH' ? 'danger' : 'warning'}">`;
                html += `<strong>Deviation Detected:</strong> ${escapeHtml(analysis.deviation_reason)}<br>`;
                html += `<strong>Risk Level:</strong> <span class="badge badge-${analysis.deviation_risk_level?.toLowerCase() || 'warning'}">${analysis.deviation_risk_level || 'UNKNOWN'}</span><br>`;
                html += `<strong>Mitigation:</strong> ${escapeHtml(analysis.deviation_mitigation)}`;
                html += `</div>`;
            } else {
                html += `<div class="alert alert-success">`;
                html += `<strong>Baseline Compatible:</strong> This application is compatible with the baseline policy.`;
                html += `</div>`;
            }

            if (analysis.guidance) {
                html += `<div class="guidance-box">`;
                html += `<h4>${escapeHtml(analysis.guidance.title)}</h4>`;
                html += `<p>${escapeHtml(analysis.guidance.explanation)}</p>`;
                
                if (analysis.guidance.options && analysis.guidance.options.length > 0) {
                    analysis.guidance.options.forEach(opt => {
                        html += `<div class="option-card">`;
                        html += `<div class="option-label">Option ${opt.option}: ${escapeHtml(opt.title)}</div>`;
                        html += `<p>${escapeHtml(opt.description)}</p>`;
                        html += `<small><strong>Effort:</strong> ${escapeHtml(opt.effort)}</small>`;
                        html += `</div>`;
                    });
                }
                html += `</div>`;
            }

            html += `<div style="margin-top: 20px;">`;
            html += `<p><strong>Recommended Rule Type:</strong> <span class="badge badge-info">${analysis.recommendation.rule_type}</span></p>`;
            if (analysis.recommendation.requires_ntfs_hardening) {
                html += `<p class="alert alert-warning"><strong>Note:</strong> NTFS hardening verification is required for this application.</p>`;
            }
            html += `</div>`;

            html += `<div style="margin-top: 20px; text-align: right;">`;
            html += `<button class="btn btn-secondary" onclick="closeModal('analysis-modal')">Cancel</button> `;
            html += `<button class="btn btn-primary" onclick="confirmAnalysis()">Create Layer</button>`;
            html += `</div>`;

            container.innerHTML = html;
            modal.style.display = 'block';
            
            window.confirmAnalysis = function() {
                closeModal('analysis-modal');
                if (onConfirm) onConfirm();
            };
        }

        // Generate rules for app
        function generateRulesForApp(app) {
            const rules = [];
            const fileCategories = ['EXE', 'DLL']; // Can be extended
            
            fileCategories.forEach(category => {
                if (app.rule_type === 'PUBLISHER' && app.is_signed) {
                    rules.push({
                        rule_id: generateId(),
                        rule_name: `Allow ${app.app_name} (${category})`,
                        rule_type: 'PUBLISHER',
                        file_category: category,
                        action: 'ALLOW',
                        publisher_name: `O=${app.app_vendor.toUpperCase()}, L=UNKNOWN, S=UNKNOWN, C=US`,
                        publisher_product: app.app_name.toUpperCase(),
                        publisher_file: category === 'EXE' ? '*.exe' : '*.dll',
                        version_low: app.version || '0.0.0.0',
                        version_high: '*',
                        business_justification: `Allow ${app.app_name} ${category} files`
                    });
                } else if (app.rule_type === 'PATH') {
                    rules.push({
                        rule_id: generateId(),
                        rule_name: `Allow ${app.app_name} (${category})`,
                        rule_type: 'PATH',
                        file_category: category,
                        action: 'ALLOW',
                        path: app.install_path,
                        business_justification: `Allow ${app.app_name} ${category} files from ${app.install_path}`
                    });
                }
            });

            return rules;
        }

        // Validate policy
        function validatePolicy() {
            if (!currentPolicyId) return;

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) return;

            // Clear previous validation issues
            window.ruleValidationIssues = {};
            
            const validation = performValidation(policy);
            showValidationResults(validation);
            
            // Refresh the policy view to show highlighted rules
            viewPolicy(currentPolicyId);
        }

        // Helper function for path normalization (used in validation and quick fixes)
        function normalizePathForValidation(path) {
            if (!path) return '';
            let normalized = path.replace(/\\/g, '/').toLowerCase();
            normalized = normalized.replace(/%windir%/gi, '%windir%');
            normalized = normalized.replace(/%programfiles%/gi, '%programfiles%');
            normalized = normalized.replace(/%appdata%/gi, '%appdata%');
            normalized = normalized.replace(/%localappdata%/gi, '%localappdata%');
            normalized = normalized.replace(/%temp%/gi, '%temp%');
            normalized = normalized.replace(/%userprofile%/gi, '%userprofile%');
            return normalized;
        }

        // Perform validation
        function performValidation(policy) {
            const checks = [];
            const errors = [];
            const warnings = [];
            const suggestions = [];
            
            // Store rule validation issues: rule_id -> array of {check, issue, severity}
            window.ruleValidationIssues = {};

            // Check 1: Baseline present and locked
            const baseline = policy.layers.find(l => l.layer_type === 'BASELINE');
            if (baseline && baseline.is_locked) {
                checks.push({ check: 'Baseline present and locked', status: 'PASS', details: `Baseline layer found with ${baseline.rules ? baseline.rules.length : 0} rules, locked status` });
            } else {
                checks.push({ check: 'Baseline present and locked', status: 'FAIL', details: 'Baseline layer missing or not locked', fix: 'Baseline should be auto-generated and locked' });
                errors.push({ check: 'Baseline present and locked', status: 'FAIL', details: 'Baseline layer missing or not locked', fix: 'Baseline should be auto-generated and locked' });
            }

            // Check 2: All 7 file types controlled
            const fileTypes = ['EXE', 'DLL', 'SCRIPT', 'MSI', 'APPX', 'CHM', 'HTA'];
            const foundTypes = new Set();
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        foundTypes.add(rule.file_category);
                    });
                }
            });
            
            const missingTypes = fileTypes.filter(ft => !foundTypes.has(ft));
            if (missingTypes.length === 0) {
                checks.push({ check: 'All 7 file types controlled', status: 'PASS', details: `${fileTypes.join(', ')} all present` });
            } else {
                checks.push({ check: 'All 7 file types controlled', status: 'FAIL', details: `Missing: ${missingTypes.join(', ')}. All 7 file types should be controlled.`, fix: 'Add rules for missing file types' });
                errors.push({ check: 'All 7 file types controlled', status: 'FAIL', details: `Missing: ${missingTypes.join(', ')}. All 7 file types should be controlled.`, fix: 'Add rules for missing file types' });
                // Add suggestions for missing file types
                missingTypes.forEach(type => {
                    suggestions.push({
                        check: 'All 7 file types controlled',
                        type: 'missing_file_type',
                        rule: {
                            rule_type: 'PATH',
                            action: 'DENY',
                            file_category: type,
                            path: '*',
                            rule_name: `Deny all ${type} files`,
                            business_justification: `Block all ${type} files by default. Add allow rules as needed.`
                        }
                    });
                });
            }

            // Check 3: User-writable paths blocked
            let userPathsBlocked = true;
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.action === 'ALLOW' && isUserWritablePath(rule.path || '')) {
                            if (rule.rule_type !== 'PUBLISHER') {
                                userPathsBlocked = false;
                            }
                        }
                    });
                }
            });
            
            if (userPathsBlocked) {
                checks.push({ check: 'User-writable paths blocked', status: 'PASS', details: 'User-writable paths are blocked or use PUBLISHER rules' });
            } else {
                checks.push({ check: 'User-writable paths blocked', status: 'FAIL', details: 'Some user-writable paths are allowed without PUBLISHER rules', fix: 'Use PUBLISHER rules for user-writable paths or move apps to standard locations' });
                errors.push({ check: 'User-writable paths blocked', status: 'FAIL', details: 'Some user-writable paths are allowed without PUBLISHER rules', fix: 'Use PUBLISHER rules for user-writable paths or move apps to standard locations' });
            }

            // Check 4: Deviations documented
            const deviatingLayers = policy.layers.filter(l => l.deviates_from_baseline);
            const undocumented = deviatingLayers.filter(l => !l.deviation_reason || !l.deviation_mitigation);
            if (undocumented.length === 0) {
                checks.push({ check: 'All deviations documented', status: 'PASS', details: `${deviatingLayers.length} deviations have mitigation documented` });
            } else {
                checks.push({ check: 'All deviations documented', status: 'FAIL', details: `${undocumented.length} deviations are missing documentation`, fix: 'Document deviation reason and mitigation for all deviating layers' });
                errors.push({ check: 'All deviations documented', status: 'FAIL', details: `${undocumented.length} deviations are missing documentation`, fix: 'Document deviation reason and mitigation for all deviating layers' });
            }

            // Check 5: Sustainability (hash rules < 10%)
            const totalRules = policy.layers.reduce((sum, layer) => sum + (layer.rules ? layer.rules.length : 0), 0);
            const hashRules = policy.layers.reduce((sum, layer) => {
                if (layer.rules) {
                    return sum + layer.rules.filter(r => r.rule_type === 'HASH').length;
                }
                return sum;
            }, 0);
            const hashPercentage = totalRules > 0 ? (hashRules / totalRules) * 100 : 0;
            
            if (hashPercentage < 10) {
                checks.push({ check: 'Sustainability', status: 'PASS', details: `${hashRules} HASH rules (${hashPercentage.toFixed(1)}%). Estimated maintenance: ${hashRules * 0.5} hours/year (sustainable)` });
            } else {
                checks.push({ check: 'Sustainability', status: 'WARNING', details: `${hashRules} HASH rules (${hashPercentage.toFixed(1)}%). High maintenance burden.`, fix: 'Consider requesting vendor signatures to reduce HASH rules' });
                warnings.push({ check: 'Sustainability', status: 'WARNING', details: `${hashRules} HASH rules (${hashPercentage.toFixed(1)}%). High maintenance burden.`, fix: 'Consider requesting vendor signatures to reduce HASH rules' });
            }

            // Check 6: Rule Completeness & Required Fields
            const incompleteRules = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        const issues = [];
                        if (!rule.rule_name || rule.rule_name.trim() === '') issues.push('missing name');
                        if (!rule.business_justification || rule.business_justification.trim() === '') issues.push('missing justification');
                        if (!rule.action) issues.push('missing action');
                        if (!rule.file_category) issues.push('missing file category');
                        if (!rule.rule_type) issues.push('missing rule type');
                        
                        // Type-specific required fields
                        if (rule.rule_type === 'PATH' && (!rule.path || rule.path.trim() === '')) issues.push('missing path');
                        if (rule.rule_type === 'PUBLISHER' && (!rule.publisher_name || rule.publisher_name.trim() === '')) issues.push('missing publisher name');
                        if (rule.rule_type === 'HASH' && (!rule.hash_sha256 || rule.hash_sha256.trim() === '')) issues.push('missing hash');
                        
                        if (issues.length > 0) {
                            const issueText = issues.join(', ');
                            incompleteRules.push({ rule: rule.rule_name || 'Unnamed', layer: layer.layer_name, issues: issueText });
                            if (!window.ruleValidationIssues[rule.rule_id]) {
                                window.ruleValidationIssues[rule.rule_id] = [];
                            }
                            window.ruleValidationIssues[rule.rule_id].push({
                                check: 'Rule completeness',
                                issue: issueText,
                                severity: 'FAIL',
                                rule_name: rule.rule_name || 'Unnamed'
                            });
                        }
                    });
                }
            });
            
            if (incompleteRules.length === 0) {
                checks.push({ check: 'Rule completeness', status: 'PASS', details: 'All rules have required fields' });
            } else {
                checks.push({ check: 'Rule completeness', status: 'FAIL', details: `${incompleteRules.length} rule(s) missing required fields`, fix: 'Complete all required fields for each rule' });
                errors.push({ check: 'Rule completeness', status: 'FAIL', details: `${incompleteRules.length} rule(s) missing required fields: ${incompleteRules.slice(0, 3).map(r => `${r.rule} (${r.issues})`).join('; ')}${incompleteRules.length > 3 ? '...' : ''}`, fix: 'Complete all required fields for each rule' });
            }

            // Check 7: Rule Conflicts
            const ruleConflicts = [];
            policy.layers.forEach(layer => {
                if (layer.rules && layer.rules.length > 0) {
                    // Use the conflict detection function
                    const allRules = layer.rules;
                    for (let i = 0; i < allRules.length; i++) {
                        for (let j = i + 1; j < allRules.length; j++) {
                            const rule1 = allRules[i];
                            const rule2 = allRules[j];
                            
                            // Check for conflicts (reuse the conflict detection logic)
                            if (rule1.file_category === rule2.file_category && 
                                rule1.action !== rule2.action &&
                                rule1.rule_type === 'PATH' && rule2.rule_type === 'PATH') {
                                
                                const norm1 = normalizePathForValidation(rule1.path || '');
                                const norm2 = normalizePathForValidation(rule2.path || '');
                                
                                // Check if paths conflict
                                let pathsConflict = false;
                                if (norm1 === norm2) {
                                    pathsConflict = true;
                                } else if (norm1 === '*' || norm1 === '*/*' || norm1 === '*\\*') {
                                    pathsConflict = true;
                                } else if (norm2 === '*' || norm2 === '*/*' || norm2 === '*\\*') {
                                    pathsConflict = true;
                                } else if (norm1.endsWith('/*') && norm2.endsWith('/*')) {
                                    const dir1 = norm1.substring(0, norm1.length - 2);
                                    const dir2 = norm2.substring(0, norm2.length - 2);
                                    if (dir1 === dir2) pathsConflict = true;
                                }
                                
                                // Check exceptions
                                if (pathsConflict) {
                                    const rule1Exceptions = rule1.exceptions || [];
                                    const rule2Exceptions = rule2.exceptions || [];
                                    
                                    // If DENY has exception for ALLOW path, no conflict
                                    if (rule1.action === 'DENY' && rule1Exceptions.some(exp => {
                                        const expPath = normalizePathForValidation(exp.path || exp);
                                        return expPath === norm2 || norm2.startsWith(expPath);
                                    })) {
                                        pathsConflict = false;
                                    }
                                    if (rule2.action === 'DENY' && rule2Exceptions.some(exp => {
                                        const expPath = normalizePathForValidation(exp.path || exp);
                                        return expPath === norm1 || norm1.startsWith(expPath);
                                    })) {
                                        pathsConflict = false;
                                    }
                                    
                                    if (pathsConflict) {
                                        ruleConflicts.push({
                                            layer: layer.layer_name,
                                            rule1: rule1.rule_name,
                                            rule2: rule2.rule_name,
                                            path1: rule1.path,
                                            path2: rule2.path
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            });
            
            if (ruleConflicts.length === 0) {
                checks.push({ check: 'No rule conflicts', status: 'PASS', details: 'No conflicting rules detected' });
            } else {
                checks.push({ check: 'No rule conflicts', status: 'FAIL', details: `${ruleConflicts.length} conflicting rule pair(s) found`, fix: 'Resolve conflicting rules (same path with opposite actions)' });
                errors.push({ check: 'No rule conflicts', status: 'FAIL', details: `${ruleConflicts.length} conflicting rule pair(s): ${ruleConflicts.slice(0, 3).map(c => `${c.rule1} vs ${c.rule2} in ${c.layer}`).join('; ')}${ruleConflicts.length > 3 ? '...' : ''}`, fix: 'Resolve conflicting rules' });
            }

            // Check 8: Empty Layers
            const emptyLayers = policy.layers.filter(l => !l.rules || l.rules.length === 0);
            if (emptyLayers.length === 0) {
                checks.push({ check: 'No empty layers', status: 'PASS', details: 'All layers contain rules' });
            } else {
                checks.push({ check: 'No empty layers', status: 'WARNING', details: `${emptyLayers.length} layer(s) have no rules: ${emptyLayers.map(l => l.layer_name).join(', ')}`, fix: 'Add rules to empty layers or remove them' });
                warnings.push({ check: 'No empty layers', status: 'WARNING', details: `${emptyLayers.length} layer(s) have no rules`, fix: 'Add rules to empty layers or remove them' });
            }

            // Check 8: Path Syntax Validation
            const invalidPaths = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.rule_type === 'PATH' && rule.path) {
                            const path = rule.path.trim();
                            // Check for overly permissive paths (only for ALLOW rules - DENY rules with * are restrictive, not permissive)
                            if (rule.action === 'ALLOW' && (path === '*' || path === 'C:\\*' || path === 'D:\\*')) {
                                const issue = 'overly permissive (allows everything)';
                                invalidPaths.push({ rule: rule.rule_name, path: path, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Path syntax validation',
                                    issue: issue,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                            // Check for invalid characters
                            if (/[<>"|?]/.test(path)) {
                                const issue = 'contains invalid characters';
                                invalidPaths.push({ rule: rule.rule_name, path: path, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Path syntax validation',
                                    issue: issue,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                            // Check for relative paths (warn) - exclude wildcard * which is a valid AppLocker pattern
                            if (path !== '*' && !path.startsWith('%') && !path.startsWith('C:\\') && !path.startsWith('D:\\') && !path.startsWith('\\\\')) {
                                const issue = 'may be relative path (unreliable)';
                                invalidPaths.push({ rule: rule.rule_name, path: path, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Path syntax validation',
                                    issue: issue,
                                    severity: 'WARNING',
                                    rule_name: rule.rule_name
                                });
                            }
                        }
                    });
                }
            });
            
            if (invalidPaths.length === 0) {
                checks.push({ check: 'Path syntax validation', status: 'PASS', details: 'All paths are valid and appropriately scoped' });
            } else {
                const critical = invalidPaths.filter(p => p.issue.includes('overly permissive') || p.issue.includes('invalid characters'));
                if (critical.length > 0) {
                    checks.push({ check: 'Path syntax validation', status: 'FAIL', details: `${critical.length} path(s) have critical issues`, fix: 'Fix invalid or overly permissive paths' });
                    errors.push({ check: 'Path syntax validation', status: 'FAIL', details: `${critical.length} path(s) have critical issues: ${critical.slice(0, 2).map(p => `${p.rule} - ${p.issue}`).join('; ')}`, fix: 'Fix invalid or overly permissive paths' });
                }
                const warnings_only = invalidPaths.filter(p => !p.issue.includes('overly permissive') && !p.issue.includes('invalid characters'));
                if (warnings_only.length > 0) {
                    checks.push({ check: 'Path syntax validation', status: 'WARNING', details: `${warnings_only.length} path(s) may have issues`, fix: 'Review path syntax' });
                    warnings.push({ check: 'Path syntax validation', status: 'WARNING', details: `${warnings_only.length} path(s) may have issues`, fix: 'Review path syntax' });
                }
            }

            // Check 9: Publisher Rule Format Validation
            const invalidPublishers = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.rule_type === 'PUBLISHER' && rule.publisher_name) {
                            const pub = rule.publisher_name.trim();
                            // Check for proper format (should contain O=, L=, S=, C=)
                            if (!pub.includes('O=')) {
                                const issue = 'missing Organization (O=)';
                                invalidPublishers.push({ rule: rule.rule_name, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Publisher rule format',
                                    issue: issue,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                            // Check for version range logic
                            if (rule.version_low && rule.version_high && rule.version_high !== '*') {
                                const low = parseVersion(rule.version_low);
                                const high = parseVersion(rule.version_high);
                                if (low && high && low > high) {
                                    const issue = 'version range invalid (LowSection > HighSection)';
                                    invalidPublishers.push({ rule: rule.rule_name, issue: issue });
                                    if (!window.ruleValidationIssues[rule.rule_id]) {
                                        window.ruleValidationIssues[rule.rule_id] = [];
                                    }
                                    window.ruleValidationIssues[rule.rule_id].push({
                                        check: 'Publisher rule format',
                                        issue: issue,
                                        severity: 'FAIL',
                                        rule_name: rule.rule_name
                                    });
                                }
                            }
                            // Warn if too permissive
                            if ((rule.publisher_product === '*' || !rule.publisher_product) && (rule.publisher_file === '*' || !rule.publisher_file)) {
                                const issue = 'too permissive (product and file are wildcards)';
                                invalidPublishers.push({ rule: rule.rule_name, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Publisher rule format',
                                    issue: issue,
                                    severity: 'WARNING',
                                    rule_name: rule.rule_name
                                });
                            }
                        }
                    });
                }
            });
            
            if (invalidPublishers.length === 0) {
                checks.push({ check: 'Publisher rule format', status: 'PASS', details: 'All publisher rules have valid format' });
            } else {
                const critical = invalidPublishers.filter(p => p.issue.includes('missing') || p.issue.includes('invalid'));
                if (critical.length > 0) {
                    checks.push({ check: 'Publisher rule format', status: 'FAIL', details: `${critical.length} publisher rule(s) have format issues`, fix: 'Fix publisher rule format' });
                    errors.push({ check: 'Publisher rule format', status: 'FAIL', details: `${critical.length} publisher rule(s) have format issues`, fix: 'Fix publisher rule format' });
                }
                const warnings_only = invalidPublishers.filter(p => !p.issue.includes('missing') && !p.issue.includes('invalid'));
                if (warnings_only.length > 0) {
                    checks.push({ check: 'Publisher rule format', status: 'WARNING', details: `${warnings_only.length} publisher rule(s) may be too permissive`, fix: 'Consider narrowing publisher rules' });
                    warnings.push({ check: 'Publisher rule format', status: 'WARNING', details: `${warnings_only.length} publisher rule(s) may be too permissive`, fix: 'Consider narrowing publisher rules' });
                }
            }

            // Check 10: Hash Rule Format Validation
            const invalidHashes = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.rule_type === 'HASH' && rule.hash_sha256) {
                            const hash = rule.hash_sha256.trim();
                            // Validate SHA-256 format (64 hex characters)
                            if (!/^[0-9a-fA-F]{64}$/.test(hash)) {
                                const issue = 'invalid SHA-256 format (must be 64 hex characters)';
                                invalidHashes.push({ rule: rule.rule_name, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Hash rule format',
                                    issue: issue,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                            // Check hash type consistency
                            if (rule.hash_type && !['SHA256', 'SHA256Flat', 'SHA256Authenticode'].includes(rule.hash_type)) {
                                const issue = `invalid hash type: ${rule.hash_type}`;
                                invalidHashes.push({ rule: rule.rule_name, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Hash rule format',
                                    issue: issue,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                            // Check file length
                            if (rule.hash_file_length !== undefined && rule.hash_file_length < 0) {
                                const issue = 'invalid file length (must be >= 0)';
                                invalidHashes.push({ rule: rule.rule_name, issue: issue });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Hash rule format',
                                    issue: issue,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                        }
                    });
                }
            });
            
            if (invalidHashes.length === 0) {
                checks.push({ check: 'Hash rule format', status: 'PASS', details: 'All hash rules have valid format' });
            } else {
                checks.push({ check: 'Hash rule format', status: 'FAIL', details: `${invalidHashes.length} hash rule(s) have format issues`, fix: 'Fix hash rule format' });
                errors.push({ check: 'Hash rule format', status: 'FAIL', details: `${invalidHashes.length} hash rule(s) have format issues: ${invalidHashes.slice(0, 2).map(h => h.issue).join('; ')}`, fix: 'Fix hash rule format' });
            }

            // Check 11: SID Format Validation
            const invalidSIDs = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.user_or_group_sid) {
                            if (!validateSID(rule.user_or_group_sid)) {
                                invalidSIDs.push({ rule: rule.rule_name, rule_id: rule.rule_id, sid: rule.user_or_group_sid });
                                // Store in ruleValidationIssues for navigation
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'SID format validation',
                                    issue: 'Invalid SID format',
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name || 'Unnamed'
                                });
                            }
                            // Warn if using Everyone for sensitive rules
                            if (rule.user_or_group_sid === 'S-1-1-0' && rule.action === 'ALLOW' && rule.rule_type === 'PATH' && rule.path && !rule.path.includes('%WINDIR%') && !rule.path.includes('%PROGRAMFILES%')) {
                                invalidSIDs.push({ rule: rule.rule_name, rule_id: rule.rule_id, sid: rule.user_or_group_sid, issue: 'using Everyone (S-1-1-0) for non-system path' });
                                // Store in ruleValidationIssues for navigation
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'SID format validation',
                                    issue: 'Using Everyone (S-1-1-0) for non-system path',
                                    severity: 'WARNING',
                                    rule_name: rule.rule_name || 'Unnamed'
                                });
                            }
                        }
                    });
                }
            });
            
            if (invalidSIDs.length === 0) {
                checks.push({ check: 'SID format validation', status: 'PASS', details: 'All SIDs are valid' });
            } else {
                const critical = invalidSIDs.filter(s => !s.issue);
                if (critical.length > 0) {
                    checks.push({ check: 'SID format validation', status: 'FAIL', details: `${critical.length} rule(s) have invalid SID format`, fix: 'Fix SID format' });
                    errors.push({ check: 'SID format validation', status: 'FAIL', details: `${critical.length} rule(s) have invalid SID format`, fix: 'Fix SID format' });
                }
                const warnings_only = invalidSIDs.filter(s => s.issue);
                if (warnings_only.length > 0) {
                    checks.push({ check: 'SID format validation', status: 'WARNING', details: `${warnings_only.length} rule(s) may have SID usage issues`, fix: 'Review SID usage for security' });
                    warnings.push({ check: 'SID format validation', status: 'WARNING', details: `${warnings_only.length} rule(s) may have SID usage issues`, fix: 'Review SID usage for security' });
                }
            }

            // Check 12: Exception Validation
            const invalidExceptions = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.exceptions && rule.exceptions.length > 0) {
                            rule.exceptions.forEach((exception, idx) => {
                                const excPath = typeof exception === 'string' ? exception : exception.path;
                                if (!excPath || excPath.trim() === '') {
                                    invalidExceptions.push({ rule: rule.rule_name, issue: 'empty exception path' });
                                } else if (excPath === '*') {
                                    invalidExceptions.push({ rule: rule.rule_name, issue: 'exception is too broad (*) and negates the rule' });
                                }
                                // Check if exception conflicts with main rule
                                if (rule.rule_type === 'PATH' && rule.path && excPath.includes(rule.path.replace('*', ''))) {
                                    invalidExceptions.push({ rule: rule.rule_name, issue: 'exception may conflict with main rule path' });
                                }
                            });
                            // Warn if too many exceptions
                            if (rule.exceptions.length > 10) {
                                invalidExceptions.push({ rule: rule.rule_name, issue: `too many exceptions (${rule.exceptions.length}), may impact performance` });
                            }
                        }
                    });
                }
            });
            
            if (invalidExceptions.length === 0) {
                checks.push({ check: 'Exception validation', status: 'PASS', details: 'All exceptions are valid' });
            } else {
                const critical = invalidExceptions.filter(e => e.issue.includes('empty') || e.issue.includes('too broad'));
                if (critical.length > 0) {
                    checks.push({ check: 'Exception validation', status: 'FAIL', details: `${critical.length} exception(s) have critical issues`, fix: 'Fix invalid exceptions' });
                    errors.push({ check: 'Exception validation', status: 'FAIL', details: `${critical.length} exception(s) have critical issues`, fix: 'Fix invalid exceptions' });
                }
                const warnings_only = invalidExceptions.filter(e => !e.issue.includes('empty') && !e.issue.includes('too broad'));
                if (warnings_only.length > 0) {
                    checks.push({ check: 'Exception validation', status: 'WARNING', details: `${warnings_only.length} exception(s) may have issues`, fix: 'Review exceptions' });
                    warnings.push({ check: 'Exception validation', status: 'WARNING', details: `${warnings_only.length} exception(s) may have issues`, fix: 'Review exceptions' });
                }
            }

            // Check 13: Business Justification Quality
            const poorJustifications = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.business_justification) {
                            const just = rule.business_justification.trim();
                            if (just.length < 10) {
                                poorJustifications.push({ rule: rule.rule_name, issue: 'justification too short (< 10 characters)' });
                            } else if (just.toLowerCase() === 'test' || just.toLowerCase() === 'testing' || just.toLowerCase() === 'temp') {
                                poorJustifications.push({ rule: rule.rule_name, issue: 'justification appears to be placeholder text' });
                            }
                        }
                    });
                }
            });
            
            if (poorJustifications.length === 0) {
                checks.push({ check: 'Business justification quality', status: 'PASS', details: 'All justifications are meaningful' });
            } else {
                checks.push({ check: 'Business justification quality', status: 'WARNING', details: `${poorJustifications.length} rule(s) have poor justifications`, fix: 'Improve business justifications' });
                warnings.push({ check: 'Business justification quality', status: 'WARNING', details: `${poorJustifications.length} rule(s) have poor justifications`, fix: 'Improve business justifications' });
            }

            // Check 14: Rule Count & Performance
            if (totalRules > 1000) {
                checks.push({ check: 'Rule count performance', status: 'WARNING', details: `Total rules: ${totalRules}. High rule count may impact performance.`, fix: 'Consider consolidating rules or using more specific paths' });
                warnings.push({ check: 'Rule count performance', status: 'WARNING', details: `Total rules: ${totalRules}. High rule count may impact performance.`, fix: 'Consider consolidating rules or using more specific paths' });
            } else if (totalRules > 500) {
                checks.push({ check: 'Rule count performance', status: 'WARNING', details: `Total rules: ${totalRules}. Moderate rule count.`, fix: 'Monitor performance' });
                warnings.push({ check: 'Rule count performance', status: 'WARNING', details: `Total rules: ${totalRules}. Moderate rule count.`, fix: 'Monitor performance' });
            } else {
                checks.push({ check: 'Rule count performance', status: 'PASS', details: `Total rules: ${totalRules} (within recommended limits)` });
            }

            // Check 15: Duplicate Rules Detection
            const ruleSignatures = new Map();
            const duplicates = [];
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        let signature = '';
                        if (rule.rule_type === 'PATH') {
                            signature = `PATH:${rule.path}:${rule.file_category}:${rule.action}`;
                        } else if (rule.rule_type === 'PUBLISHER') {
                            signature = `PUBLISHER:${rule.publisher_name}:${rule.publisher_product}:${rule.publisher_file}:${rule.file_category}:${rule.action}`;
                        } else if (rule.rule_type === 'HASH') {
                            signature = `HASH:${rule.hash_sha256}:${rule.file_category}:${rule.action}`;
                        }
                        
                        if (signature && ruleSignatures.has(signature)) {
                            duplicates.push({ rule: rule.rule_name, duplicateOf: ruleSignatures.get(signature) });
                        } else if (signature) {
                            ruleSignatures.set(signature, rule.rule_name);
                        }
                    });
                }
            });
            
            if (duplicates.length === 0) {
                checks.push({ check: 'Duplicate rules', status: 'PASS', details: 'No duplicate rules detected' });
            } else {
                checks.push({ check: 'Duplicate rules', status: 'WARNING', details: `${duplicates.length} duplicate rule(s) detected`, fix: 'Remove duplicate rules to reduce policy size' });
                warnings.push({ check: 'Duplicate rules', status: 'WARNING', details: `${duplicates.length} duplicate rule(s) detected: ${duplicates.slice(0, 3).map(d => d.rule).join(', ')}${duplicates.length > 3 ? '...' : ''}`, fix: 'Remove duplicate rules' });
            }

            // Check 16: Best Practice - Publisher Preference
            const pathRules = policy.layers.reduce((sum, layer) => {
                if (layer.rules) {
                    return sum + layer.rules.filter(r => r.rule_type === 'PATH' && r.action === 'ALLOW').length;
                }
                return sum;
            }, 0);
            const publisherRules = policy.layers.reduce((sum, layer) => {
                if (layer.rules) {
                    return sum + layer.rules.filter(r => r.rule_type === 'PUBLISHER' && r.action === 'ALLOW').length;
                }
                return sum;
            }, 0);
            
            if (pathRules > publisherRules * 2 && pathRules > 10) {
                checks.push({ check: 'Best practice: Publisher preference', status: 'WARNING', details: `PATH rules (${pathRules}) significantly outnumber PUBLISHER rules (${publisherRules}). PUBLISHER rules are more secure.`, fix: 'Consider using PUBLISHER rules when executables are signed' });
                warnings.push({ check: 'Best practice: Publisher preference', status: 'WARNING', details: `PATH rules (${pathRules}) significantly outnumber PUBLISHER rules (${publisherRules})`, fix: 'Consider using PUBLISHER rules when executables are signed' });
            } else {
                checks.push({ check: 'Best practice: Publisher preference', status: 'PASS', details: `Good balance: ${publisherRules} PUBLISHER vs ${pathRules} PATH rules` });
            }

            // Check 17: Layer Precedence Validation
            const precedenceIssues = [];
            const precedences = policy.layers.map(l => ({ name: l.layer_name, prec: l.layer_precedence, type: l.layer_type }));
            const baselinePrec = precedences.find(p => p.type === 'BASELINE');
            if (baselinePrec && baselinePrec.prec !== 0) {
                precedenceIssues.push({ issue: 'Baseline layer precedence is not 0', layer: baselinePrec.name });
            }
            const nonBaseline = precedences.filter(p => p.type !== 'BASELINE');
            const precedenceDuplicates = nonBaseline.filter((p, i) => nonBaseline.findIndex(pp => pp.prec === p.prec) !== i);
            if (precedenceDuplicates.length > 0) {
                precedenceIssues.push({ issue: 'Duplicate precedence values found', layers: precedenceDuplicates.map(d => d.name).join(', ') });
            }
            
            if (precedenceIssues.length === 0) {
                checks.push({ check: 'Layer precedence', status: 'PASS', details: 'All layer precedences are valid' });
            } else {
                checks.push({ check: 'Layer precedence', status: 'WARNING', details: `${precedenceIssues.length} precedence issue(s) found`, fix: 'Fix layer precedence values' });
                warnings.push({ check: 'Layer precedence', status: 'WARNING', details: `${precedenceIssues.length} precedence issue(s) found`, fix: 'Fix layer precedence values' });
            }

            // Check 18: LOLBin Blocking Verification
            const lolBinsBlocked = {
                'powershell.exe': false,
                'cmd.exe': false,
                'wscript.exe': false,
                'cscript.exe': false
            };
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.action === 'DENY' && rule.rule_type === 'PATH' && rule.path) {
                            if (rule.path.includes('powershell.exe')) lolBinsBlocked['powershell.exe'] = true;
                            if (rule.path.includes('cmd.exe')) lolBinsBlocked['cmd.exe'] = true;
                            if (rule.path.includes('wscript.exe')) lolBinsBlocked['wscript.exe'] = true;
                            if (rule.path.includes('cscript.exe')) lolBinsBlocked['cscript.exe'] = true;
                        }
                    });
                }
            });
            
            const unblockedLolBins = Object.keys(lolBinsBlocked).filter(bin => !lolBinsBlocked[bin]);
            if (unblockedLolBins.length === 0) {
                checks.push({ check: 'LOLBin blocking', status: 'PASS', details: 'Common LOLBins are blocked in user paths' });
            } else {
                checks.push({ check: 'LOLBin blocking', status: 'WARNING', details: `Consider blocking these LOLBins in user paths: ${unblockedLolBins.join(', ')}`, fix: 'Add DENY rules for LOLBins in user-writable paths' });
                warnings.push({ check: 'LOLBin blocking', status: 'WARNING', details: `Consider blocking these LOLBins in user paths: ${unblockedLolBins.join(', ')}`, fix: 'Add DENY rules for LOLBins in user-writable paths' });
                // Add suggestions for LOLBin blocking
                unblockedLolBins.forEach(bin => {
                    suggestions.push({
                        check: 'LOLBin blocking',
                        type: 'lolbin_block',
                        rule: {
                            rule_type: 'PATH',
                            action: 'DENY',
                            file_category: 'EXE',
                            path: `%USERPROFILE%\\*\\${bin}`,
                            rule_name: `Deny ${bin} in user paths`,
                            business_justification: `Security hardening: Block ${bin} execution from user-writable paths to prevent LOLBin attacks.`
                        }
                    });
                });
            }

            // Check 19: HTA Blocking Verification
            const htaBlocked = policy.layers.some(layer => 
                layer.rules && layer.rules.some(r => 
                    r.file_category === 'HTA' && r.action === 'DENY' && (r.path === '*' || r.path === '*\\*')
                )
            );
            
            if (htaBlocked) {
                checks.push({ check: 'HTA blocking', status: 'PASS', details: 'HTA files are blocked' });
            } else {
                checks.push({ check: 'HTA blocking', status: 'WARNING', details: 'HTA files should be blocked', fix: 'Add DENY rule for HTA file category' });
                warnings.push({ check: 'HTA blocking', status: 'WARNING', details: 'HTA files should be blocked', fix: 'Add DENY rule for HTA file category' });
                // Add suggestion for HTA blocking
                suggestions.push({
                    check: 'HTA blocking',
                    type: 'hta_block',
                    rule: {
                        rule_type: 'PATH',
                        action: 'DENY',
                        file_category: 'HTA',
                        path: '*',
                        rule_name: 'Deny all HTA files',
                        business_justification: 'Block all HTML Application (HTA) files to prevent malicious script execution.'
                    }
                });
            }

            // Check 20: Temp/Downloads Blocking
            const tempBlocked = policy.layers.some(layer => 
                layer.rules && layer.rules.some(r => 
                    r.action === 'DENY' && r.path && (r.path.includes('%TEMP%') || r.path.includes('%TMP%'))
                )
            );
            const downloadsBlocked = policy.layers.some(layer => 
                layer.rules && layer.rules.some(r => 
                    r.action === 'DENY' && r.path && r.path.includes('Downloads')
                )
            );
            
            if (tempBlocked && downloadsBlocked) {
                checks.push({ check: 'Temp/Downloads blocking', status: 'PASS', details: 'Temporary and download paths are blocked' });
            } else {
                const missing = [];
                if (!tempBlocked) missing.push('TEMP');
                if (!downloadsBlocked) missing.push('Downloads');
                checks.push({ check: 'Temp/Downloads blocking', status: 'WARNING', details: `Consider blocking: ${missing.join(', ')}`, fix: 'Add DENY rules for temporary and download paths' });
                warnings.push({ check: 'Temp/Downloads blocking', status: 'WARNING', details: `Consider blocking: ${missing.join(', ')}`, fix: 'Add DENY rules for temporary and download paths' });
                // Add suggestions for Temp/Downloads blocking
                if (!tempBlocked) {
                    suggestions.push({
                        check: 'Temp/Downloads blocking',
                        type: 'temp_block',
                        rule: {
                            rule_type: 'PATH',
                            action: 'DENY',
                            file_category: 'EXE',
                            path: '%TEMP%\\*',
                            rule_name: 'Deny executables from TEMP',
                            business_justification: 'Security hardening: Block executable files from temporary directories to prevent malware execution.'
                        }
                    });
                }
                if (!downloadsBlocked) {
                    suggestions.push({
                        check: 'Temp/Downloads blocking',
                        type: 'downloads_block',
                        rule: {
                            rule_type: 'PATH',
                            action: 'DENY',
                            file_category: 'EXE',
                            path: '%USERPROFILE%\\Downloads\\*',
                            rule_name: 'Deny executables from Downloads',
                            business_justification: 'Security hardening: Block executable files from Downloads folder to prevent execution of downloaded malware.'
                        }
                    });
                }
            }

            // Check 20: Enhanced LOLBin Detection
            const highRiskLolBins = ['mshta.exe', 'wscript.exe', 'cscript.exe'];
            const mediumRiskLolBins = ['powershell.exe', 'cmd.exe', 'rundll32.exe', 'regsvr32.exe', 'forfiles.exe', 'certutil.exe', 'bitsadmin.exe', 'msiexec.exe'];
            const lolBinIssues = [];
            
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.rule_type === 'PATH' && rule.path) {
                            const path = rule.path.toLowerCase();
                            
                            // Check high-risk LOLBins
                            highRiskLolBins.forEach(bin => {
                                if (path.includes(bin)) {
                                    const hasExceptions = rule.exceptions && rule.exceptions.length > 0;
                                    if (rule.action === 'DENY' && hasExceptions) {
                                        lolBinIssues.push({
                                            rule_id: rule.rule_id,
                                            rule_name: rule.rule_name,
                                            bin: bin,
                                            issue: `High-risk LOLBin ${bin} is blocked but has exceptions (should be blocked entirely)`,
                                            severity: 'FAIL',
                                            fix_type: 'remove_exceptions'
                                        });
                                        if (!window.ruleValidationIssues[rule.rule_id]) {
                                            window.ruleValidationIssues[rule.rule_id] = [];
                                        }
                                        window.ruleValidationIssues[rule.rule_id].push({
                                            check: 'LOLBin detection',
                                            issue: `High-risk LOLBin ${bin} has exceptions (should be blocked entirely)`,
                                            severity: 'FAIL',
                                            rule_name: rule.rule_name
                                        });
                                    } else if (rule.action === 'ALLOW' && path.includes('system32') && !path.includes('user')) {
                                        lolBinIssues.push({
                                            rule_id: rule.rule_id,
                                            rule_name: rule.rule_name,
                                            bin: bin,
                                            issue: `High-risk LOLBin ${bin} is allowed from System32 (should be blocked entirely)`,
                                            severity: 'WARNING',
                                            fix_type: 'block_entirely'
                                        });
                                        if (!window.ruleValidationIssues[rule.rule_id]) {
                                            window.ruleValidationIssues[rule.rule_id] = [];
                                        }
                                        window.ruleValidationIssues[rule.rule_id].push({
                                            check: 'LOLBin detection',
                                            issue: `High-risk LOLBin ${bin} allowed from System32 (should be blocked entirely)`,
                                            severity: 'WARNING',
                                            rule_name: rule.rule_name
                                        });
                                    }
                                }
                            });
                            
                            // Check medium-risk LOLBins
                            mediumRiskLolBins.forEach(bin => {
                                if (path.includes(bin)) {
                                    if (rule.action === 'DENY' && path.includes('*\\') && !path.includes('system32') && !path.includes('syswow64')) {
                                        // Blocked from user paths - check if System32 exception exists
                                        const hasSystemException = rule.exceptions && rule.exceptions.some(ex => {
                                            const exPath = (typeof ex === 'string' ? ex : ex.path || '').toLowerCase();
                                            return exPath.includes('system32') || exPath.includes('syswow64');
                                        });
                                        if (!hasSystemException) {
                                            lolBinIssues.push({
                                                rule_id: rule.rule_id,
                                                rule_name: rule.rule_name,
                                                bin: bin,
                                                issue: `LOLBin ${bin} blocked from user paths but missing System32 exception (may break system functionality)`,
                                                severity: 'WARNING',
                                                fix_type: 'add_system_exception'
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            });
            
            if (lolBinIssues.length === 0) {
                checks.push({ check: 'LOLBin detection', status: 'PASS', details: 'LOLBin blocking configuration is appropriate' });
            } else {
                const critical = lolBinIssues.filter(i => i.severity === 'FAIL');
                const warnings_only = lolBinIssues.filter(i => i.severity === 'WARNING');
                if (critical.length > 0) {
                    checks.push({ check: 'LOLBin detection', status: 'FAIL', details: `${critical.length} high-risk LOLBin issue(s) found`, fix: 'Remove exceptions from high-risk LOLBin blocks or block them entirely' });
                    errors.push({ check: 'LOLBin detection', status: 'FAIL', details: `${critical.length} high-risk LOLBin issue(s): ${critical.slice(0, 2).map(i => `${i.bin} - ${i.issue}`).join('; ')}`, fix: 'Fix LOLBin blocking configuration' });
                }
                if (warnings_only.length > 0) {
                    checks.push({ check: 'LOLBin detection', status: 'WARNING', details: `${warnings_only.length} LOLBin configuration issue(s) found`, fix: 'Review LOLBin blocking configuration' });
                    warnings.push({ check: 'LOLBin detection', status: 'WARNING', details: `${warnings_only.length} LOLBin configuration issue(s) found`, fix: 'Review LOLBin blocking configuration' });
                }
            }

            // Check 21: Default Deny Coverage
            const fileTypesForDeny = ['EXE', 'DLL', 'SCRIPT', 'MSI', 'APPX', 'CHM', 'HTA'];
            const defaultDenyIssues = [];
            
            fileTypesForDeny.forEach(category => {
                const hasDefaultDeny = policy.layers.some(layer => 
                    layer.rules && layer.rules.some(r => 
                        r.file_category === category && 
                        r.action === 'DENY' && 
                        (r.path === '*' || r.path === '*\\*' || r.path === '*\\*.exe' || r.path === '*\\*.dll' || r.path === '*\\*.js' || r.path === '*\\*.vbs' || r.path === '*\\*.ps1')
                    )
                );
                
                if (!hasDefaultDeny) {
                    defaultDenyIssues.push({
                        category: category,
                        issue: `No default deny rule for ${category} category`
                    });
                }
                
                // Check for overly permissive ALLOW rules
                policy.layers.forEach(layer => {
                    if (layer.rules) {
                        layer.rules.forEach(rule => {
                            if (rule.file_category === category && 
                                rule.action === 'ALLOW' && 
                                rule.rule_type === 'PATH' &&
                                (rule.path === '*' || rule.path === 'C:\\*' || rule.path === 'D:\\*')) {
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Default deny coverage',
                                    issue: `Overly permissive ALLOW rule (${rule.path}) - should be more specific`,
                                    severity: 'FAIL',
                                    rule_name: rule.rule_name
                                });
                            }
                        });
                    }
                });
            });
            
            if (defaultDenyIssues.length === 0) {
                checks.push({ check: 'Default deny coverage', status: 'PASS', details: 'All file categories have default deny rules or specific allow rules' });
            } else {
                checks.push({ check: 'Default deny coverage', status: 'WARNING', details: `${defaultDenyIssues.length} file category/categories missing default deny: ${defaultDenyIssues.map(d => d.category).join(', ')}`, fix: 'Add default deny rules for missing categories' });
                warnings.push({ check: 'Default deny coverage', status: 'WARNING', details: `${defaultDenyIssues.length} file category/categories missing default deny`, fix: 'Add default deny rules' });
                defaultDenyIssues.forEach(issue => {
                    suggestions.push({
                        check: 'Default deny coverage',
                        type: 'default_deny',
                        rule: {
                            rule_type: 'PATH',
                            action: 'DENY',
                            file_category: issue.category,
                            path: '*',
                            rule_name: `Deny all ${issue.category} files`,
                            business_justification: `Default deny rule for ${issue.category} category - add specific allow rules as needed`
                        }
                    });
                });
            }

            // Check 22: Path Hardening Validation
            const pathHardeningIssues = [];
            const requiredWritableExceptions = [
                '%System32%\\Microsoft\\Crypto\\RSA\\MachineKeys\\*',
                '%System32%\\spool\\drivers\\color\\*',
                '%System32%\\Tasks\\*',
                '%WinDir%\\Tasks\\*',
                '%WinDir%\\Temp\\*',
                '%System32%\\Com\\dmp\\*',
                '%System32%\\FxsTmp\\*',
                '%System32%\\spool\\*',
                '%WinDir%\\tracing\\*',
                '%WINDIR%\\Microsoft.NET\\*'
            ];
            
            policy.layers.forEach(layer => {
                if (layer.rules) {
                    layer.rules.forEach(rule => {
                        if (rule.rule_type === 'PATH' && 
                            rule.action === 'ALLOW' && 
                            rule.path && 
                            (rule.path.includes('%WINDIR%') || rule.path.includes('%WinDir%'))) {
                            
                            const exceptions = rule.exceptions || [];
                            const exceptionPaths = exceptions.map(ex => {
                                const path = typeof ex === 'string' ? ex : (ex.path || '');
                                return path.toLowerCase().replace(/\\/g, '/');
                            });
                            
                            const missingExceptions = [];
                            requiredWritableExceptions.forEach(reqEx => {
                                const normalizedReq = reqEx.toLowerCase().replace(/\\/g, '/');
                                const hasException = exceptionPaths.some(exPath => 
                                    exPath === normalizedReq || 
                                    exPath.includes(normalizedReq.replace('*', '')) ||
                                    normalizedReq.includes(exPath.replace('*', ''))
                                );
                                if (!hasException) {
                                    missingExceptions.push(reqEx);
                                }
                            });
                            
                            if (missingExceptions.length > 0) {
                                pathHardeningIssues.push({
                                    rule_id: rule.rule_id,
                                    rule_name: rule.rule_name,
                                    missing: missingExceptions,
                                    issue: `Missing exceptions for writable subdirectories: ${missingExceptions.slice(0, 3).join(', ')}${missingExceptions.length > 3 ? '...' : ''}`
                                });
                                if (!window.ruleValidationIssues[rule.rule_id]) {
                                    window.ruleValidationIssues[rule.rule_id] = [];
                                }
                                window.ruleValidationIssues[rule.rule_id].push({
                                    check: 'Path hardening validation',
                                    issue: `Missing exceptions for writable subdirectories: ${missingExceptions.slice(0, 2).join(', ')}${missingExceptions.length > 2 ? '...' : ''}`,
                                    severity: 'WARNING',
                                    rule_name: rule.rule_name,
                                    fix_data: { missing_exceptions: missingExceptions }
                                });
                            }
                        }
                    });
                }
            });
            
            if (pathHardeningIssues.length === 0) {
                checks.push({ check: 'Path hardening validation', status: 'PASS', details: 'All %WINDIR% rules have proper exceptions for writable subdirectories' });
            } else {
                checks.push({ check: 'Path hardening validation', status: 'WARNING', details: `${pathHardeningIssues.length} %WINDIR% rule(s) missing exceptions for writable subdirectories`, fix: 'Add exceptions for writable subdirectories to %WINDIR% rules' });
                warnings.push({ check: 'Path hardening validation', status: 'WARNING', details: `${pathHardeningIssues.length} %WINDIR% rule(s) missing exceptions`, fix: 'Add exceptions for writable subdirectories' });
            }

            // Check 23: Rule Ordering Optimization
            const orderingIssues = [];
            policy.layers.forEach(layer => {
                if (layer.rules && layer.rules.length > 1) {
                    const rules = layer.rules;
                    
                    // Check deny-before-allow ordering
                    for (let i = 0; i < rules.length - 1; i++) {
                        const rule1 = rules[i];
                        const rule2 = rules[i + 1];
                        
                        // If both are PATH rules with same category, check ordering
                        if (rule1.rule_type === 'PATH' && rule2.rule_type === 'PATH' && 
                            rule1.file_category === rule2.file_category) {
                            
                            // DENY should come before ALLOW for same path
                            if (rule1.action === 'ALLOW' && rule2.action === 'DENY') {
                                const path1 = normalizePathForValidation(rule1.path || '');
                                const path2 = normalizePathForValidation(rule2.path || '');
                                
                                // Check if paths overlap
                                if (path1 === path2 || path1.includes(path2.replace('*', '')) || path2.includes(path1.replace('*', ''))) {
                                    orderingIssues.push({
                                        rule1_id: rule1.rule_id,
                                        rule2_id: rule2.rule_id,
                                        rule1_name: rule1.rule_name,
                                        rule2_name: rule2.rule_name,
                                        layer_id: layer.layer_id,
                                        issue: 'ALLOW rule comes before DENY rule for overlapping paths (should be DENY first)',
                                        fix_type: 'reorder_rules'
                                    });
                                }
                            }
                            
                            // More specific rules should come before less specific
                            const path1 = normalizePathForValidation(rule1.path || '');
                            const path2 = normalizePathForValidation(rule2.path || '');
                            const specificity1 = path1.split('\\').length + (path1.includes('*') ? 0 : 10);
                            const specificity2 = path2.split('\\').length + (path2.includes('*') ? 0 : 10);
                            
                            if (specificity2 > specificity1 && rule1.action === rule2.action) {
                                orderingIssues.push({
                                    rule1_id: rule1.rule_id,
                                    rule2_id: rule2.rule_id,
                                    rule1_name: rule1.rule_name,
                                    rule2_name: rule2.rule_name,
                                    layer_id: layer.layer_id,
                                    issue: 'Less specific rule comes before more specific rule (may impact performance)',
                                    fix_type: 'reorder_rules'
                                });
                            }
                        }
                    }
                }
            });
            
            if (orderingIssues.length === 0) {
                checks.push({ check: 'Rule ordering optimization', status: 'PASS', details: 'Rules are optimally ordered (DENY before ALLOW, specific before general)' });
            } else {
                checks.push({ check: 'Rule ordering optimization', status: 'WARNING', details: `${orderingIssues.length} rule ordering issue(s) found`, fix: 'Reorder rules: DENY before ALLOW, specific before general' });
                warnings.push({ check: 'Rule ordering optimization', status: 'WARNING', details: `${orderingIssues.length} rule ordering issue(s) found`, fix: 'Optimize rule ordering for better performance' });
            }

            return {
                is_valid: errors.length === 0,
                is_compliant: errors.length === 0,
                checks: checks,
                errors: errors,
                warnings: warnings,
                suggestions: suggestions,
                quickFixes: { lolBinIssues, pathHardeningIssues, orderingIssues }
            };
        }

        // Helper function to parse version strings
        function parseVersion(versionStr) {
            if (!versionStr || versionStr === '*') return null;
            const parts = versionStr.split('.').map(p => parseInt(p));
            if (parts.length === 4 && parts.every(p => !isNaN(p))) {
                return parts[0] * 1000000 + parts[1] * 10000 + parts[2] * 100 + parts[3];
            }
            return null;
        }

        // Show validation results
        function showValidationResults(validation) {
            const modal = document.getElementById('validation-modal');
            const container = document.getElementById('validation-results');
            
            let html = '';
            
            if (!validation.is_compliant) {
                html += `<div class="alert alert-danger">`;
                html += `<strong>‚úó Policy has validation errors</strong>`;
                html += `</div>`;
            }

            html += `<h3>Validation Checks</h3>`;
            validation.checks.forEach((check, index) => {
                const badgeClass = check.status === 'PASS' ? 'badge-success' : check.status === 'FAIL' ? 'badge-danger' : 'badge-warning';
                // Check if this validation check references specific rules with issues
                const hasRuleIssues = check.status !== 'PASS' && window.ruleValidationIssues && Object.keys(window.ruleValidationIssues).length > 0;
                html += `<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px;">`;
                html += `<strong>${escapeHtml(check.check)}</strong> <span class="badge ${badgeClass}">${check.status}</span><br>`;
                html += `<small>${escapeHtml(check.details)}</small>`;
                if (check.fix) {
                    html += `<br><small style="color: #667eea;"><strong>Fix:</strong> ${escapeHtml(check.fix)}</small>`;
                }
                // Add link to view affected rules if this check has rule-level issues
                if (hasRuleIssues && check.status !== 'PASS') {
                    const affectedRules = Object.keys(window.ruleValidationIssues).filter(ruleId => {
                        const issues = window.ruleValidationIssues[ruleId];
                        if (!issues) return false;
                        // Match check name and severity (for warnings, match WARNING; for errors, match FAIL)
                        const expectedSeverity = check.status === 'WARNING' ? 'WARNING' : (check.status === 'FAIL' ? 'FAIL' : null);
                        if (expectedSeverity) {
                            return issues.some(i => i.check === check.check && i.severity === expectedSeverity);
                        } else {
                            return issues.some(i => i.check === check.check);
                        }
                    });
                    if (affectedRules.length > 0) {
                        html += `<br><small style="color: #667eea; cursor: pointer; text-decoration: underline;" onclick="navigateToRule('${affectedRules[0]}')" title="Click to navigate to affected rule">View affected rule${affectedRules.length > 1 ? 's' : ''} (${affectedRules.length})</small>`;
                    }
                }
                html += `</div>`;
            });

            if (validation.errors.length > 0) {
                html += `<h3 style="color: #dc3545; margin-top: 20px;">Errors</h3>`;
                validation.errors.forEach((error, index) => {
                    // Find rules affected by this error
                    const affectedRules = window.ruleValidationIssues ? Object.keys(window.ruleValidationIssues).filter(ruleId => {
                        const issues = window.ruleValidationIssues[ruleId];
                        return issues && issues.some(i => i.check === error.check && i.severity === 'FAIL');
                    }) : [];
                    html += `<div class="alert alert-danger" style="${affectedRules.length > 0 ? 'cursor: pointer;' : ''}" ${affectedRules.length > 0 ? `onclick="navigateToRule('${affectedRules[0]}')" title="Click to navigate to affected rule"` : ''}>`;
                    html += `<strong>${escapeHtml(error.check)}</strong><br>`;
                    html += `${escapeHtml(error.details)}<br>`;
                    if (error.fix) {
                        html += `<strong>Fix:</strong> ${escapeHtml(error.fix)}`;
                    }
                    if (affectedRules.length > 0) {
                        html += `<br><small style="color: #fff; text-decoration: underline; cursor: pointer;">Click to view affected rule${affectedRules.length > 1 ? 's' : ''} (${affectedRules.length})</small>`;
                    }
                    html += `</div>`;
                });
            }

            if (validation.warnings.length > 0) {
                html += `<h3 style="color: #ffc107; margin-top: 20px;">Warnings</h3>`;
                validation.warnings.forEach((warning, index) => {
                    // Find rules affected by this warning
                    const affectedRules = window.ruleValidationIssues ? Object.keys(window.ruleValidationIssues).filter(ruleId => {
                        const issues = window.ruleValidationIssues[ruleId];
                        return issues && issues.some(i => i.check === warning.check && i.severity === 'WARNING');
                    }) : [];
                    html += `<div class="alert alert-warning" style="${affectedRules.length > 0 ? 'cursor: pointer;' : ''}" ${affectedRules.length > 0 ? `onclick="navigateToRule('${affectedRules[0]}')" title="Click to navigate to affected rule"` : ''}>`;
                    html += `<strong>${escapeHtml(warning.check)}</strong><br>`;
                    html += `${escapeHtml(warning.details)}<br>`;
                    if (warning.fix) {
                        html += `<strong>Fix:</strong> ${escapeHtml(warning.fix)}`;
                    }
                    if (affectedRules.length > 0) {
                        html += `<br><small style="color: #856404; text-decoration: underline; cursor: pointer;">Click to view affected rule${affectedRules.length > 1 ? 's' : ''} (${affectedRules.length})</small>`;
                    }
                    html += `</div>`;
                });
            }

            // Add suggestions section with create buttons
            if (validation.suggestions && validation.suggestions.length > 0) {
                html += `<h3 style="color: #667eea; margin-top: 20px;">Suggested Rules</h3>`;
                html += `<div style="margin-bottom: 15px;">`;
                html += `<p style="color: #666; font-size: 0.9em; margin-bottom: 10px; display: inline-block;">Click "Create Rule" to automatically add these rules to your baseline layer:</p>`;
                html += `<button class="btn btn-primary" style="margin-left: 10px; padding: 6px 16px;" onclick="createAllSuggestedRules()">Create All Rules (${validation.suggestions.length})</button>`;
                html += `</div>`;
                
                // Group suggestions by check type
                const suggestionsByCheck = {};
                validation.suggestions.forEach((suggestion, index) => {
                    if (!suggestionsByCheck[suggestion.check]) {
                        suggestionsByCheck[suggestion.check] = [];
                    }
                    suggestionsByCheck[suggestion.check].push({...suggestion, index: index});
                });
                
                Object.keys(suggestionsByCheck).forEach(checkName => {
                    const checkSuggestions = suggestionsByCheck[checkName];
                    html += `<div style="margin: 10px 0; padding: 10px; background: #f0f4ff; border-left: 3px solid #667eea; border-radius: 4px;">`;
                    html += `<strong>${escapeHtml(checkName)}</strong><br>`;
                    checkSuggestions.forEach(suggestion => {
                        html += `<div style="margin: 8px 0; padding: 8px; background: white; border-radius: 3px;">`;
                        html += `<strong>${escapeHtml(suggestion.rule.rule_name)}</strong><br>`;
                        html += `<small style="color: #666;">${escapeHtml(suggestion.rule.business_justification)}</small><br>`;
                        html += `<small style="color: #666;">Type: ${escapeHtml(suggestion.rule.rule_type)} | Action: ${escapeHtml(suggestion.rule.action)} | Category: ${escapeHtml(suggestion.rule.file_category)}`;
                        if (suggestion.rule.path) {
                            html += ` | Path: ${escapeHtml(suggestion.rule.path)}`;
                        }
                        html += `</small><br>`;
                        html += `<button class="btn btn-primary" style="margin-top: 5px; padding: 4px 12px; font-size: 0.85em;" onclick="createRuleFromSuggestion(${suggestion.index})">Create Rule</button>`;
                        html += `</div>`;
                    });
                    html += `</div>`;
                });
                
                // Store suggestions for button handlers
                window.validationSuggestions = validation.suggestions;
            }

            // Add Quick Fixes section
            if (validation.quickFixes) {
                const { lolBinIssues, pathHardeningIssues, orderingIssues } = validation.quickFixes;
                const totalQuickFixes = (lolBinIssues?.length || 0) + (pathHardeningIssues?.length || 0) + (orderingIssues?.length || 0);
                
                if (totalQuickFixes > 0) {
                    html += `<h3 style="color: #28a745; margin-top: 20px;">Quick Fixes Available</h3>`;
                    html += `<p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Automatically fix common issues with one click:</p>`;
                    
                    // LOLBin Quick Fixes
                    if (lolBinIssues && lolBinIssues.length > 0) {
                        const removeExceptions = lolBinIssues.filter(i => i.fix_type === 'remove_exceptions');
                        const addSystemExceptions = lolBinIssues.filter(i => i.fix_type === 'add_system_exception');
                        
                        if (removeExceptions.length > 0) {
                            html += `<div style="margin: 10px 0; padding: 10px; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 4px;">`;
                            html += `<strong>LOLBin Exceptions (${removeExceptions.length})</strong><br>`;
                            html += `<small>Remove exceptions from high-risk LOLBin blocks</small><br>`;
                            html += `<button class="btn btn-warning" style="margin-top: 8px; padding: 6px 16px;" onclick="applyQuickFix('remove_lolbin_exceptions', ${JSON.stringify(removeExceptions).replace(/"/g, '&quot;')})">Fix ${removeExceptions.length} Issue${removeExceptions.length > 1 ? 's' : ''}</button>`;
                            html += ` <button class="btn btn-secondary" style="margin-top: 8px; padding: 6px 16px;" onclick="previewQuickFix('remove_lolbin_exceptions', ${JSON.stringify(removeExceptions).replace(/"/g, '&quot;')})">Preview</button>`;
                            html += `</div>`;
                        }
                        
                        if (addSystemExceptions.length > 0) {
                            html += `<div style="margin: 10px 0; padding: 10px; background: #d1ecf1; border-left: 3px solid #17a2b8; border-radius: 4px;">`;
                            html += `<strong>Missing System Exceptions (${addSystemExceptions.length})</strong><br>`;
                            html += `<small>Add System32 exceptions to LOLBin blocks</small><br>`;
                            html += `<button class="btn btn-info" style="margin-top: 8px; padding: 6px 16px;" onclick="applyQuickFix('add_system_exceptions', ${JSON.stringify(addSystemExceptions).replace(/"/g, '&quot;')})">Fix ${addSystemExceptions.length} Issue${addSystemExceptions.length > 1 ? 's' : ''}</button>`;
                            html += ` <button class="btn btn-secondary" style="margin-top: 8px; padding: 6px 16px;" onclick="previewQuickFix('add_system_exceptions', ${JSON.stringify(addSystemExceptions).replace(/"/g, '&quot;')})">Preview</button>`;
                            html += `</div>`;
                        }
                    }
                    
                    // Path Hardening Quick Fixes
                    if (pathHardeningIssues && pathHardeningIssues.length > 0) {
                        html += `<div style="margin: 10px 0; padding: 10px; background: #d1ecf1; border-left: 3px solid #17a2b8; border-radius: 4px;">`;
                        html += `<strong>Path Hardening (${pathHardeningIssues.length})</strong><br>`;
                        html += `<small>Add missing exceptions to %WINDIR% rules</small><br>`;
                        html += `<button class="btn btn-info" style="margin-top: 8px; padding: 6px 16px;" onclick="applyQuickFix('add_path_exceptions', ${JSON.stringify(pathHardeningIssues).replace(/"/g, '&quot;')})">Fix ${pathHardeningIssues.length} Issue${pathHardeningIssues.length > 1 ? 's' : ''}</button>`;
                        html += ` <button class="btn btn-secondary" style="margin-top: 8px; padding: 6px 16px;" onclick="previewQuickFix('add_path_exceptions', ${JSON.stringify(pathHardeningIssues).replace(/"/g, '&quot;')})">Preview</button>`;
                        html += `</div>`;
                    }
                    
                    // Rule Ordering Quick Fixes
                    if (orderingIssues && orderingIssues.length > 0) {
                        html += `<div style="margin: 10px 0; padding: 10px; background: #d4edda; border-left: 3px solid #28a745; border-radius: 4px;">`;
                        html += `<strong>Rule Ordering (${orderingIssues.length})</strong><br>`;
                        html += `<small>Reorder rules for optimal performance</small><br>`;
                        html += `<button class="btn btn-success" style="margin-top: 8px; padding: 6px 16px;" onclick="applyQuickFix('reorder_rules', ${JSON.stringify(orderingIssues).replace(/"/g, '&quot;')})">Fix ${orderingIssues.length} Issue${orderingIssues.length > 1 ? 's' : ''}</button>`;
                        html += ` <button class="btn btn-secondary" style="margin-top: 8px; padding: 6px 16px;" onclick="previewQuickFix('reorder_rules', ${JSON.stringify(orderingIssues).replace(/"/g, '&quot;')})">Preview</button>`;
                        html += `</div>`;
                    }
                }
            }

            // Add section for rules with validation issues (clickable to navigate to rule)
            if (window.ruleValidationIssues && Object.keys(window.ruleValidationIssues).length > 0) {
                html += `<h3 style="color: #dc3545; margin-top: 20px;">Rules with Issues (Click to Navigate)</h3>`;
                Object.keys(window.ruleValidationIssues).forEach(ruleId => {
                    const issues = window.ruleValidationIssues[ruleId];
                    if (issues && issues.length > 0) {
                        const criticalIssues = issues.filter(i => i.severity === 'FAIL');
                        const hasCritical = criticalIssues.length > 0;
                        const ruleName = issues[0].rule_name || 'Unnamed Rule';
                        html += `<div class="alert ${hasCritical ? 'alert-danger' : 'alert-warning'}" style="cursor: pointer; margin: 8px 0;" onclick="navigateToRule('${ruleId}')" title="Click to navigate to this rule">`;
                        html += `<strong>${escapeHtml(ruleName)}</strong> <span style="color: #666; font-size: 0.9em;">(ID: ${ruleId.substring(0, 8)}...)</span><br>`;
                        issues.forEach((issue, idx) => {
                            html += `<small style="display: block; margin-top: 4px;">`;
                            html += `<span class="badge ${issue.severity === 'FAIL' ? 'badge-danger' : 'badge-warning'}" style="margin-right: 5px;">${issue.severity}</span>`;
                            html += `<strong>${escapeHtml(issue.check)}:</strong> ${escapeHtml(issue.issue)}`;
                            html += `</small>`;
                        });
                        html += `</div>`;
                    }
                });
            }

            container.innerHTML = html;
            modal.style.display = 'block';
        }

        // Navigate to a specific rule by rule_id
        function navigateToRule(ruleId) {
            // Close the validation modal
            closeModal('validation-modal');
            
            // Find the rule element
            const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
            if (!ruleElement) {
                alert('Rule not found. The policy view may need to be refreshed.');
                return;
            }
            
            // Get the layer ID to expand the rules list
            const layerId = ruleElement.getAttribute('data-layer-id');
            const rulesListContainer = document.getElementById(`rules-list-${layerId}`);
            const rulesListHeader = document.querySelector(`.rules-list-header[data-layer-id="${layerId}"]`);
            
            // Expand the rules list if it's collapsed (use CSS classes, not inline styles)
            if (rulesListContainer && !rulesListContainer.classList.contains('expanded')) {
                // Manually add the expanded class to both container and header
                // This ensures the toggle function will work correctly when clicked
                rulesListContainer.classList.add('expanded');
                if (rulesListHeader) {
                    rulesListHeader.classList.add('expanded');
                }
            }
            
            // Scroll to the rule with smooth behavior
            setTimeout(() => {
                ruleElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Highlight the rule temporarily
                const originalBg = ruleElement.style.backgroundColor;
                const originalBorder = ruleElement.style.borderLeft;
                ruleElement.style.backgroundColor = '#fff3cd';
                ruleElement.style.borderLeft = '4px solid #ffc107';
                ruleElement.style.transition = 'all 0.3s ease';
                
                // Expand the rule XML view
                if (!ruleElement.classList.contains('expanded')) {
                    toggleRuleXML(ruleElement, new Event('click'));
                }
                
                // Remove highlight after 3 seconds
                setTimeout(() => {
                    ruleElement.style.backgroundColor = originalBg;
                    ruleElement.style.borderLeft = originalBorder;
                }, 3000);
            }, 100);
        }

        // Apply quick fix
        function applyQuickFix(fixType, issues) {
            if (!currentPolicyId) return;
            
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) return;
            
            let changesMade = 0;
            
            if (fixType === 'remove_lolbin_exceptions') {
                issues.forEach(issue => {
                    policy.layers.forEach(layer => {
                        if (layer.rules) {
                            const rule = layer.rules.find(r => r.rule_id === issue.rule_id);
                            if (rule && rule.exceptions) {
                                rule.exceptions = [];
                                changesMade++;
                            }
                        }
                    });
                });
            } else if (fixType === 'add_system_exceptions') {
                issues.forEach(issue => {
                    policy.layers.forEach(layer => {
                        if (layer.rules) {
                            const rule = layer.rules.find(r => r.rule_id === issue.rule_id);
                            if (rule) {
                                if (!rule.exceptions) rule.exceptions = [];
                                const binName = issue.bin.toLowerCase();
                                const systemPaths = [
                                    { path: `%WINDIR%\\System32\\${binName}` },
                                    { path: `%WINDIR%\\SysWOW64\\${binName}` }
                                ];
                                systemPaths.forEach(sysPath => {
                                    if (!rule.exceptions.some(ex => {
                                        const exPath = typeof ex === 'string' ? ex : (ex.path || '');
                                        return exPath.toLowerCase().includes(binName) && (exPath.includes('System32') || exPath.includes('SysWOW64'));
                                    })) {
                                        rule.exceptions.push(sysPath);
                                        changesMade++;
                                    }
                                });
                            }
                        }
                    });
                });
            } else if (fixType === 'add_path_exceptions') {
                issues.forEach(issue => {
                    policy.layers.forEach(layer => {
                        if (layer.rules) {
                            const rule = layer.rules.find(r => r.rule_id === issue.rule_id);
                            if (rule) {
                                if (!rule.exceptions) rule.exceptions = [];
                                issue.missing.forEach(missingEx => {
                                    if (!rule.exceptions.some(ex => {
                                        const exPath = typeof ex === 'string' ? ex : (ex.path || '');
                                        return exPath.toLowerCase() === missingEx.toLowerCase();
                                    })) {
                                        rule.exceptions.push({ path: missingEx });
                                        changesMade++;
                                    }
                                });
                            }
                        }
                    });
                });
            } else if (fixType === 'reorder_rules') {
                // Group issues by layer
                const issuesByLayer = {};
                issues.forEach(issue => {
                    if (!issuesByLayer[issue.layer_id]) {
                        issuesByLayer[issue.layer_id] = [];
                    }
                    issuesByLayer[issue.layer_id].push(issue);
                });
                
                Object.keys(issuesByLayer).forEach(layerId => {
                    const layer = policy.layers.find(l => l.layer_id === layerId);
                    if (layer && layer.rules) {
                        // Sort rules: DENY before ALLOW, specific before general
                        layer.rules.sort((a, b) => {
                            // First, DENY before ALLOW
                            if (a.action !== b.action) {
                                return a.action === 'DENY' ? -1 : 1;
                            }
                            // Then, more specific before less specific
                            const path1 = normalizePathForValidation(a.path || '');
                            const path2 = normalizePathForValidation(b.path || '');
                            const specificity1 = path1.split('\\').length + (path1.includes('*') ? 0 : 10);
                            const specificity2 = path2.split('\\').length + (path2.includes('*') ? 0 : 10);
                            return specificity2 - specificity1;
                        });
                        changesMade += issuesByLayer[layerId].length;
                    }
                });
            }
            
            if (changesMade > 0) {
                savePolicies();
                alert(`Quick fix applied: ${changesMade} change(s) made. Re-running validation...`);
                validatePolicy();
            } else {
                alert('No changes were made. The issues may have already been fixed.');
            }
        }

        // Preview quick fix
        function previewQuickFix(fixType, issues) {
            let previewHtml = '<h3>Quick Fix Preview</h3><ul style="text-align: left; max-height: 400px; overflow-y: auto;">';
            
            if (fixType === 'remove_lolbin_exceptions') {
                issues.forEach(issue => {
                    previewHtml += `<li><strong>${escapeHtml(issue.rule_name)}</strong>: Remove all exceptions (${issue.bin} should be blocked entirely)</li>`;
                });
            } else if (fixType === 'add_system_exceptions') {
                issues.forEach(issue => {
                    previewHtml += `<li><strong>${escapeHtml(issue.rule_name)}</strong>: Add System32/SysWOW64 exceptions for ${issue.bin}</li>`;
                });
            } else if (fixType === 'add_path_exceptions') {
                issues.forEach(issue => {
                    previewHtml += `<li><strong>${escapeHtml(issue.rule_name)}</strong>: Add ${issue.missing.length} missing exception(s): ${issue.missing.slice(0, 2).join(', ')}${issue.missing.length > 2 ? '...' : ''}</li>`;
                });
            } else if (fixType === 'reorder_rules') {
                const issuesByLayer = {};
                issues.forEach(issue => {
                    if (!issuesByLayer[issue.layer_id]) {
                        issuesByLayer[issue.layer_id] = [];
                    }
                    issuesByLayer[issue.layer_id].push(issue);
                });
                Object.keys(issuesByLayer).forEach(layerId => {
                    const layer = policies.find(p => p.policy_id === currentPolicyId)?.layers.find(l => l.layer_id === layerId);
                    if (layer) {
                        previewHtml += `<li><strong>${escapeHtml(layer.layer_name)}</strong>: Reorder ${issuesByLayer[layerId].length} rule(s) (DENY before ALLOW, specific before general)</li>`;
                    }
                });
            }
            
            previewHtml += '</ul>';
            previewHtml += '<p style="margin-top: 15px;"><button class="btn btn-primary" onclick="closeModal(\'preview-modal\'); applyQuickFix(\'' + fixType + '\', ' + JSON.stringify(issues).replace(/"/g, '&quot;') + ')">Apply Fix</button> ';
            previewHtml += '<button class="btn btn-secondary" onclick="closeModal(\'preview-modal\')">Cancel</button></p>';
            
            // Create or update preview modal
            let previewModal = document.getElementById('preview-modal');
            if (!previewModal) {
                previewModal = document.createElement('div');
                previewModal.id = 'preview-modal';
                previewModal.className = 'modal';
                previewModal.innerHTML = '<div class="modal-content"><span class="close" onclick="closeModal(\'preview-modal\')">&times;</span><div id="preview-content"></div></div>';
                document.body.appendChild(previewModal);
            }
            
            document.getElementById('preview-content').innerHTML = previewHtml;
            previewModal.style.display = 'block';
        }

        // Create rule from validation suggestion
        function createRuleFromSuggestion(suggestionIndex) {
            if (!currentPolicyId) {
                alert('No policy selected');
                return;
            }

            if (!window.validationSuggestions || !window.validationSuggestions[suggestionIndex]) {
                alert('Suggestion not found');
                return;
            }

            const suggestion = window.validationSuggestions[suggestionIndex];
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }

            // Find baseline layer or create one if it doesn't exist
            let baselineLayer = policy.layers.find(l => l.layer_type === 'BASELINE');
            if (!baselineLayer) {
                // Create baseline layer
                baselineLayer = {
                    layer_id: generateId(),
                    policy_id: currentPolicyId,
                    layer_type: 'BASELINE',
                    layer_name: 'Baseline',
                    layer_precedence: 0,
                    business_justification: 'Baseline security rules',
                    is_locked: true,
                    deviates_from_baseline: false,
                    rules: []
                };
                policy.layers.push(baselineLayer);
            }

            // Check if rule already exists (prevent duplicates)
            const ruleExists = baselineLayer.rules.some(r => 
                r.rule_type === suggestion.rule.rule_type &&
                r.action === suggestion.rule.action &&
                r.file_category === suggestion.rule.file_category &&
                (r.path === suggestion.rule.path || r.publisher_name === suggestion.rule.publisher_name)
            );

            if (ruleExists) {
                alert('This rule already exists in the baseline layer');
                return;
            }

            // Create the rule
            const newRule = {
                rule_id: generateId(),
                rule_name: suggestion.rule.rule_name,
                rule_type: suggestion.rule.rule_type,
                file_category: suggestion.rule.file_category,
                action: suggestion.rule.action,
                business_justification: suggestion.rule.business_justification,
                user_or_group_sid: suggestion.rule.user_or_group_sid || 'S-1-1-0',
                created_at: new Date().toISOString(),
                exceptions: []
            };

            // Add type-specific fields
            if (suggestion.rule.rule_type === 'PATH') {
                newRule.path = suggestion.rule.path;
            } else if (suggestion.rule.rule_type === 'PUBLISHER') {
                newRule.publisher_name = suggestion.rule.publisher_name || '';
                newRule.publisher_product = suggestion.rule.publisher_product || null;
                newRule.publisher_file = suggestion.rule.publisher_file || '*';
                newRule.version_low = suggestion.rule.version_low || null;
                newRule.version_high = suggestion.rule.version_high || '*';
            } else if (suggestion.rule.rule_type === 'HASH') {
                newRule.hash_sha256 = suggestion.rule.hash_sha256 || '';
                newRule.hash_type = suggestion.rule.hash_type || 'SHA256';
                newRule.hash_filename = suggestion.rule.hash_filename || null;
                newRule.source_file_length = suggestion.rule.source_file_length || 0;
            }

            // Add rule to baseline layer
            baselineLayer.rules.push(newRule);

            // Save policies
            savePolicies();

            // Refresh view
            viewPolicy(currentPolicyId);

            // Show success message
            alert(`Rule "${suggestion.rule.rule_name}" has been added to the baseline layer.`);

            // Re-run validation to update suggestions
            validatePolicy();
        }

        // Create all suggested rules at once
        function createAllSuggestedRules() {
            if (!currentPolicyId) {
                alert('No policy selected');
                return;
            }

            if (!window.validationSuggestions || window.validationSuggestions.length === 0) {
                alert('No suggestions available');
                return;
            }

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }

            // Find baseline layer or create one if it doesn't exist
            let baselineLayer = policy.layers.find(l => l.layer_type === 'BASELINE');
            if (!baselineLayer) {
                // Create baseline layer
                baselineLayer = {
                    layer_id: generateId(),
                    policy_id: currentPolicyId,
                    layer_type: 'BASELINE',
                    layer_name: 'Baseline',
                    layer_precedence: 0,
                    business_justification: 'Baseline security rules',
                    is_locked: true,
                    deviates_from_baseline: false,
                    rules: []
                };
                policy.layers.push(baselineLayer);
            }

            let createdCount = 0;
            let skippedCount = 0;

            // Process each suggestion
            window.validationSuggestions.forEach(suggestion => {
                // Check if rule already exists (prevent duplicates)
                const ruleExists = baselineLayer.rules.some(r => 
                    r.rule_type === suggestion.rule.rule_type &&
                    r.action === suggestion.rule.action &&
                    r.file_category === suggestion.rule.file_category &&
                    (r.path === suggestion.rule.path || r.publisher_name === suggestion.rule.publisher_name)
                );

                if (ruleExists) {
                    skippedCount++;
                    return;
                }

                // Create the rule
                const newRule = {
                    rule_id: generateId(),
                    rule_name: suggestion.rule.rule_name,
                    rule_type: suggestion.rule.rule_type,
                    file_category: suggestion.rule.file_category,
                    action: suggestion.rule.action,
                    business_justification: suggestion.rule.business_justification,
                    user_or_group_sid: suggestion.rule.user_or_group_sid || 'S-1-1-0',
                    created_at: new Date().toISOString(),
                    exceptions: []
                };

                // Add type-specific fields
                if (suggestion.rule.rule_type === 'PATH') {
                    newRule.path = suggestion.rule.path;
                } else if (suggestion.rule.rule_type === 'PUBLISHER') {
                    newRule.publisher_name = suggestion.rule.publisher_name || '';
                    newRule.publisher_product = suggestion.rule.publisher_product || null;
                    newRule.publisher_file = suggestion.rule.publisher_file || '*';
                    newRule.version_low = suggestion.rule.version_low || null;
                    newRule.version_high = suggestion.rule.version_high || '*';
                } else if (suggestion.rule.rule_type === 'HASH') {
                    newRule.hash_sha256 = suggestion.rule.hash_sha256 || '';
                    newRule.hash_type = suggestion.rule.hash_type || 'SHA256';
                    newRule.hash_filename = suggestion.rule.hash_filename || null;
                    newRule.source_file_length = suggestion.rule.source_file_length || 0;
                }

                // Add rule to baseline layer
                baselineLayer.rules.push(newRule);
                createdCount++;
            });

            // Save policies
            savePolicies();

            // Refresh view
            viewPolicy(currentPolicyId);

            // Show success message
            let message = `Created ${createdCount} rule(s) in the baseline layer.`;
            if (skippedCount > 0) {
                message += ` ${skippedCount} rule(s) were skipped (already exist).`;
            }
            alert(message);

            // Re-run validation to update suggestions
            validatePolicy();
        }

        // Show import modal (from policy view - requires existing policy)
        function showImportPolicy() {
            if (!currentPolicyId) {
                alert('Please select a policy first');
                return;
            }
            document.getElementById('import-modal').style.display = 'block';
            document.getElementById('import-file-input').value = '';
            document.getElementById('import-xml-text').value = '';
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('import-preview-content').innerHTML = '';
            document.getElementById('import-error').style.display = 'none';
            document.getElementById('import-btn').disabled = true;
            document.getElementById('import-layer-name').value = '';
            document.getElementById('import-business-justification').value = '';
            // Reset layer name field visibility
            const layerNameGroup = document.getElementById('import-layer-name').closest('.form-group');
            if (layerNameGroup) {
                layerNameGroup.style.display = 'block';
            }
            // Clear stored parse result
            window.lastImportParseResult = null;
            // Reset to file method
            switchImportMethod('file');
        }

        // Show import modal from dashboard (creates new policy if needed)
        function showImportPolicyFromDashboard() {
            document.getElementById('import-modal').style.display = 'block';
            document.getElementById('import-file-input').value = '';
            document.getElementById('import-xml-text').value = '';
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('import-preview-content').innerHTML = '';
            document.getElementById('import-error').style.display = 'none';
            document.getElementById('import-btn').disabled = true;
            document.getElementById('import-layer-name').value = '';
            document.getElementById('import-business-justification').value = '';
            // Reset layer name field visibility
            const layerNameGroup = document.getElementById('import-layer-name').closest('.form-group');
            if (layerNameGroup) {
                layerNameGroup.style.display = 'block';
            }
            // Clear stored parse result
            window.lastImportParseResult = null;
            // Reset to file method
            switchImportMethod('file');
            // Set flag to indicate this is from dashboard
            window.importFromDashboard = true;
        }

        // Show ZIP import from dashboard

        // Switch between file upload and paste methods
        function switchImportMethod(method) {
            const fileSection = document.getElementById('import-file-section');
            const pasteSection = document.getElementById('import-paste-section');
            const fileBtn = document.getElementById('import-method-file');
            const pasteBtn = document.getElementById('import-method-paste');
            
            if (method === 'file') {
                fileSection.style.display = 'block';
                pasteSection.style.display = 'none';
                fileBtn.classList.add('active');
                pasteBtn.classList.remove('active');
                // Clear paste input
                document.getElementById('import-xml-text').value = '';
            } else {
                fileSection.style.display = 'none';
                pasteSection.style.display = 'block';
                fileBtn.classList.remove('active');
                pasteBtn.classList.add('active');
                // Clear file input
                document.getElementById('import-file-input').value = '';
            }
            
            // Reset preview and error
            document.getElementById('import-preview').style.display = 'none';
            document.getElementById('import-preview-content').innerHTML = '';
            document.getElementById('import-error').style.display = 'none';
            document.getElementById('import-btn').disabled = true;
        }

        // Handle text paste input
        function handleImportTextPaste(textarea) {
            const xmlText = textarea.value.trim();
            
            if (!xmlText) {
                document.getElementById('import-preview').style.display = 'none';
                document.getElementById('import-preview-content').innerHTML = '';
                document.getElementById('import-error').style.display = 'none';
                document.getElementById('import-btn').disabled = true;
                return;
            }

            try {
                const preview = parseAppLockerXML(xmlText);
                
                if (preview.error) {
                    document.getElementById('import-error').style.display = 'block';
                    document.getElementById('import-error').textContent = preview.error;
                    document.getElementById('import-preview').style.display = 'none';
                    document.getElementById('import-btn').disabled = true;
                } else {
                    document.getElementById('import-error').style.display = 'none';
                    document.getElementById('import-preview').style.display = 'block';
                    document.getElementById('import-preview-content').innerHTML = preview.html;
                    document.getElementById('import-btn').disabled = false;
                    
                    // Store parse result for use during import
                    window.lastImportParseResult = preview;
                    
                    // Handle layer name field based on whether layers are preserved
                    const layerNameGroup = document.getElementById('import-layer-name').closest('.form-group');
                    if (preview.hasLayerStructure && preview.layers) {
                        // Hide layer name field - layers will use their preserved names
                        layerNameGroup.style.display = 'none';
                    } else {
                        // Show layer name field for single layer import
                        layerNameGroup.style.display = 'block';
                        // Auto-generate layer name if empty
                        if (!document.getElementById('import-layer-name').value) {
                            const date = new Date().toISOString().split('T')[0];
                            document.getElementById('import-layer-name').value = `Imported Policy - ${date}`;
                        }
                    }
                }
            } catch (error) {
                document.getElementById('import-error').style.display = 'block';
                document.getElementById('import-error').textContent = 'Error parsing XML: ' + error.message;
                document.getElementById('import-preview').style.display = 'none';
                document.getElementById('import-btn').disabled = true;
            }
        }

        // Handle file selection for import
        function handleImportFileSelect(input) {
            const file = input.files[0];
            if (!file) {
                document.getElementById('import-btn').disabled = true;
                document.getElementById('import-preview').style.display = 'none';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const xmlText = e.target.result;
                    const preview = parseAppLockerXML(xmlText);
                    
                    if (preview.error) {
                        document.getElementById('import-error').style.display = 'block';
                        document.getElementById('import-error').textContent = preview.error;
                        document.getElementById('import-preview').style.display = 'none';
                        document.getElementById('import-btn').disabled = true;
                    } else {
                        document.getElementById('import-error').style.display = 'none';
                        document.getElementById('import-preview').style.display = 'block';
                        document.getElementById('import-preview-content').innerHTML = preview.html;
                        document.getElementById('import-btn').disabled = false;
                        
                        // Store parse result for use during import
                        window.lastImportParseResult = preview;
                        
                        // Handle layer name field based on whether layers are preserved
                        const layerNameGroup = document.getElementById('import-layer-name').closest('.form-group');
                        if (preview.hasLayerStructure && preview.layers) {
                            // Hide layer name field - layers will use their preserved names
                            layerNameGroup.style.display = 'none';
                        } else {
                            // Show layer name field for single layer import
                            layerNameGroup.style.display = 'block';
                            // Auto-generate layer name if empty
                            if (!document.getElementById('import-layer-name').value) {
                                const date = new Date().toISOString().split('T')[0];
                                document.getElementById('import-layer-name').value = `Imported Policy - ${date}`;
                            }
                        }
                    }
                } catch (error) {
                    document.getElementById('import-error').style.display = 'block';
                    document.getElementById('import-error').textContent = 'Error reading file: ' + error.message;
                    document.getElementById('import-preview').style.display = 'none';
                    document.getElementById('import-btn').disabled = true;
                }
            };
            reader.readAsText(file);
        }

        // Parse AppLocker XML and extract rules with layer preservation
        function parseAppLockerXML(xmlText) {
            try {
                // Normalize the XML text - remove BOM and ensure it starts properly
                let normalizedXml = xmlText.trim();
                
                // Remove BOM if present
                if (normalizedXml.charCodeAt(0) === 0xFEFF) {
                    normalizedXml = normalizedXml.slice(1);
                }
                
                // If XML doesn't start with <?xml, prepend the declaration
                if (!normalizedXml.startsWith('<?xml')) {
                    // Check if it starts with <AppLockerPolicy or whitespace before it
                    const firstTagIndex = normalizedXml.indexOf('<');
                    if (firstTagIndex >= 0) {
                        // Remove any leading whitespace and prepend XML declaration
                        normalizedXml = '<?xml version="1.0" encoding="utf-8"?>\n' + normalizedXml.substring(firstTagIndex);
                    }
                }
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(normalizedXml, 'text/xml');
                
                // Check for parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    return { error: 'Invalid XML format: ' + parseError.textContent };
                }

                const policy = xmlDoc.querySelector('AppLockerPolicy');
                if (!policy) {
                    return { error: 'Not a valid AppLocker policy XML. Missing AppLockerPolicy element.' };
                }

                // Extract policy metadata from comments
                let policyMetadata = null;
                const walker = xmlDoc.createTreeWalker(policy, NodeFilter.SHOW_COMMENT);
                let node;
                while (node = walker.nextNode()) {
                    if (node.textContent.includes('PolicyMetadata:')) {
                        try {
                            let jsonStr = node.textContent.replace('PolicyMetadata:', '').trim();
                            // Decode HTML entities (e.g., &quot; -> ")
                            // Use direct replacement - most reliable for XML comments
                            jsonStr = jsonStr
                                .replace(/&quot;/g, '"')
                                .replace(/&amp;/g, '&')
                                .replace(/&lt;/g, '<')
                                .replace(/&gt;/g, '>')
                                .replace(/&apos;/g, "'");
                            
                            policyMetadata = JSON.parse(jsonStr);
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }
                }

                const ruleCollections = policy.querySelectorAll('RuleCollection');
                if (ruleCollections.length === 0) {
                    return { error: 'No RuleCollections found in the policy.' };
                }

                // Map to store layers and their rules
                const layersMap = new Map();
                const allRules = [];
                const stats = {
                    Exe: 0,
                    Dll: 0,
                    Script: 0,
                    Msi: 0,
                    Appx: 0
                };

                // Process each RuleCollection
                ruleCollections.forEach(collection => {
                    const type = collection.getAttribute('Type');
                    if (type) {
                        stats[type] = 0;
                    }

                    // Walk through all child nodes (comments and elements) in order
                    let currentLayerId = null;
                    let currentLayerData = null;
                    
                    // Get all child nodes including comments
                    const childNodes = Array.from(collection.childNodes);
                    
                    childNodes.forEach(childNode => {
                        // Node.COMMENT_NODE = 8, Node.ELEMENT_NODE = 1
                        if (childNode.nodeType === 8) { // COMMENT_NODE
                            // Check if this is a layer comment
                            if (childNode.textContent.includes('Layer:')) {
                                try {
                                    let jsonStr = childNode.textContent.replace('Layer:', '').trim();
                                    // Decode HTML entities (e.g., &quot; -> ")
                                    // Use direct replacement - most reliable for XML comments
                                    jsonStr = jsonStr
                                        .replace(/&quot;/g, '"')
                                        .replace(/&amp;/g, '&')
                                        .replace(/&lt;/g, '<')
                                        .replace(/&gt;/g, '>')
                                        .replace(/&apos;/g, "'");
                                    
                                    currentLayerData = JSON.parse(jsonStr);
                                    currentLayerId = currentLayerData.layer_id;
                                    
                                    // Initialize layer if not exists, or update metadata if it does
                                    if (!layersMap.has(currentLayerId)) {
                                        layersMap.set(currentLayerId, {
                                            layer_id: currentLayerData.layer_id,
                                            layer_name: currentLayerData.layer_name,
                                            layer_type: currentLayerData.layer_type || 'IMPORTED',
                                            layer_precedence: currentLayerData.layer_precedence || 0,
                                            business_justification: currentLayerData.business_justification || '',
                                            deviates_from_baseline: currentLayerData.deviates_from_baseline || false,
                                            deviation_reason: currentLayerData.deviation_reason || null,
                                            deviation_risk_level: currentLayerData.deviation_risk_level || null,
                                            deviation_mitigation: currentLayerData.deviation_mitigation || null,
                                            app_name: currentLayerData.app_name || null,
                                            app_vendor: currentLayerData.app_vendor || null,
                                            is_locked: currentLayerData.layer_type === 'BASELINE',
                                            rules: []
                                        });
                                    } else {
                                        // Layer already exists (from previous RuleCollection) - update metadata to ensure consistency
                                        const existingLayer = layersMap.get(currentLayerId);
                                        // Update metadata fields that might have been missing
                                        if (currentLayerData.app_name && !existingLayer.app_name) {
                                            existingLayer.app_name = currentLayerData.app_name;
                                        }
                                        if (currentLayerData.app_vendor && !existingLayer.app_vendor) {
                                            existingLayer.app_vendor = currentLayerData.app_vendor;
                                        }
                                    }
                                } catch (e) {
                                    // Log parse errors for debugging
                                    console.warn('Failed to parse layer comment:', childNode.textContent, e);
                                    // Continue without layer tracking for this comment
                                    // Don't reset currentLayerId - keep the previous layer active
                                }
                            }
                        } else if (childNode.nodeType === 1) { // ELEMENT_NODE
                            // Check if it's a rule element
                            if (childNode.tagName === 'FilePublisherRule' || 
                                childNode.tagName === 'FilePathRule' || 
                                childNode.tagName === 'FileHashRule') {
                                
                                const rule = parseRuleElement(childNode, type);
                                if (rule) {
                                    allRules.push(rule);
                                    if (type && stats[type] !== undefined) {
                                        stats[type]++;
                                    }
                                    
                                    // Add rule to current layer if layer tracking is active
                                    if (currentLayerId && layersMap.has(currentLayerId)) {
                                        layersMap.get(currentLayerId).rules.push(rule);
                                    } else if (currentLayerId && currentLayerData) {
                                        // Layer ID exists but layer not in map - create it with current layer data
                                        console.warn('Rule found for layer that was not initialized:', currentLayerId);
                                        layersMap.set(currentLayerId, {
                                            layer_id: currentLayerData.layer_id,
                                            layer_name: currentLayerData.layer_name,
                                            layer_type: currentLayerData.layer_type || 'IMPORTED',
                                            layer_precedence: currentLayerData.layer_precedence || 0,
                                            business_justification: currentLayerData.business_justification || '',
                                            deviates_from_baseline: currentLayerData.deviates_from_baseline || false,
                                            deviation_reason: currentLayerData.deviation_reason || null,
                                            deviation_risk_level: currentLayerData.deviation_risk_level || null,
                                            deviation_mitigation: currentLayerData.deviation_mitigation || null,
                                            app_name: currentLayerData.app_name || null,
                                            app_vendor: currentLayerData.app_vendor || null,
                                            is_locked: currentLayerData.layer_type === 'BASELINE',
                                            rules: [rule]
                                        });
                                    }
                                    // Note: Rules without layer comments (currentLayerId is null) will not be assigned to any layer
                                    // This is intentional - they will be handled in the "no layer structure" path
                                }
                            }
                        }
                    });
                });

                if (allRules.length === 0) {
                    return { error: 'No rules found in the policy.' };
                }

                // Convert layers map to array and sort by precedence
                const layers = Array.from(layersMap.values()).sort((a, b) => a.layer_precedence - b.layer_precedence);
                
                // Calculate total rules assigned to layers
                const rulesInLayers = layers.reduce((sum, layer) => sum + (layer.rules ? layer.rules.length : 0), 0);
                
                // Determine if layer structure should be preserved
                // We have layer structure if we found layers AND rules were assigned to them
                const hasLayerStructure = layers.length > 0 && rulesInLayers > 0;
                
                // Debug logging
                console.log('Import parsing results:', {
                    totalRules: allRules.length,
                    layersFound: layers.length,
                    rulesInLayers: rulesInLayers,
                    hasLayerStructure: hasLayerStructure,
                    layers: layers.map(l => ({ name: l.layer_name, ruleCount: l.rules ? l.rules.length : 0 }))
                });
                
                // Generate preview HTML
                let html = '';
                if (hasLayerStructure) {
                    html += `<p><strong>Found ${layers.length} layer(s) with ${allRules.length} rule(s) across ${ruleCollections.length} RuleCollection(s):</strong></p>`;
                    html += `<ul style="margin: 10px 0; padding-left: 20px;">`;
                    layers.forEach(layer => {
                        const ruleCount = layer.rules ? layer.rules.length : 0;
                        html += `<li><strong>${escapeHtml(layer.layer_name)}</strong> (${layer.layer_type}): ${ruleCount} rule(s)</li>`;
                    });
                    html += `</ul>`;
                    html += `<p style="color: #28a745; font-size: 0.9em;"><strong>‚úì Layer structure will be preserved</strong></p>`;
                } else {
                    html += `<p><strong>Found ${allRules.length} rule(s) across ${ruleCollections.length} RuleCollection(s):</strong></p>`;
                    html += `<ul style="margin: 10px 0; padding-left: 20px;">`;
                    Object.keys(stats).forEach(type => {
                        if (stats[type] > 0) {
                            html += `<li>${type}: ${stats[type]} rule(s)</li>`;
                        }
                    });
                    html += `</ul>`;
                    html += `<p style="color: #666; font-size: 0.9em;">Rules will be imported into a new layer.</p>`;
                }

                return { 
                    layers: hasLayerStructure ? layers : null,
                    rules: allRules,
                    stats: stats,
                    policyMetadata: policyMetadata,
                    hasLayerStructure: hasLayerStructure,
                    html: html
                };
            } catch (error) {
                return { error: 'Error parsing XML: ' + error.message };
            }
        }

        // Parse individual rule element
        function parseRuleElement(ruleElement, collectionType) {
            try {
                const ruleId = ruleElement.getAttribute('Id') || generateId();
                const ruleName = ruleElement.getAttribute('Name') || 'Imported Rule';
                const description = ruleElement.getAttribute('Description') || '';
                const userOrGroupSid = ruleElement.getAttribute('UserOrGroupSid') || 'S-1-1-0';
                const action = ruleElement.getAttribute('Action') || 'ALLOW';

                // Determine rule type and file category
                let ruleType = 'PATH';
                let fileCategory = 'EXE';

                if (ruleElement.tagName === 'FilePublisherRule') {
                    ruleType = 'PUBLISHER';
                } else if (ruleElement.tagName === 'FileHashRule') {
                    ruleType = 'HASH';
                }

                // Map collection type to file category
                // Note: Chm and Hta RuleCollections are non-standard but may exist in some exports
                // They map to CHM/HTA categories but will be exported to Exe RuleCollection
                const categoryMap = {
                    'Exe': 'EXE',
                    'Dll': 'DLL',
                    'Script': 'SCRIPT',
                    'Msi': 'MSI',
                    'Appx': 'APPX',
                    'Chm': 'CHM',
                    'Hta': 'HTA'
                };
                fileCategory = categoryMap[collectionType] || 'EXE';

                const rule = {
                    rule_id: ruleId,
                    rule_name: ruleName,
                    rule_type: ruleType,
                    file_category: fileCategory,
                    action: action,
                    user_or_group_sid: userOrGroupSid,
                    business_justification: description,
                    exceptions: []
                };

                // Parse conditions
                const conditions = ruleElement.querySelector('Conditions');
                if (conditions) {
                    if (ruleType === 'PUBLISHER') {
                        const publisherCondition = conditions.querySelector('FilePublisherCondition');
                        if (publisherCondition) {
                            rule.publisher_name = publisherCondition.getAttribute('PublisherName') || '';
                            rule.publisher_product = publisherCondition.getAttribute('ProductName') || null;
                            rule.publisher_file = publisherCondition.getAttribute('BinaryName') || '*.exe';
                            
                            const versionRange = publisherCondition.querySelector('BinaryVersionRange');
                            if (versionRange) {
                                rule.version_low = versionRange.getAttribute('LowSection') || null;
                                rule.version_high = versionRange.getAttribute('HighSection') || '*';
                            }
                        }
                    } else if (ruleType === 'PATH') {
                        const pathCondition = conditions.querySelector('FilePathCondition');
                        if (pathCondition) {
                            rule.path = pathCondition.getAttribute('Path') || '';
                        }
                    } else if (ruleType === 'HASH') {
                        const hashCondition = conditions.querySelector('FileHashCondition');
                        if (hashCondition) {
                            const fileHash = hashCondition.querySelector('FileHash');
                            if (fileHash) {
                                rule.hash_sha256 = fileHash.getAttribute('Data') || '';
                                rule.hash_type = fileHash.getAttribute('Type') || 'SHA256';
                                rule.hash_filename = fileHash.getAttribute('SourceFileName') || null;
                                rule.hash_file_length = parseInt(fileHash.getAttribute('SourceFileLength')) || 0;
                                rule.source_file_length = rule.hash_file_length;
                            }
                        }
                    }
                }

                // Parse exceptions
                const exceptions = ruleElement.querySelector('Exceptions');
                if (exceptions) {
                    const exceptionElements = exceptions.querySelectorAll('Exception');
                    rule.exceptions = Array.from(exceptionElements).map(exp => {
                        return { path: exp.getAttribute('Path') || exp.textContent };
                    });
                }

                return rule;
            } catch (error) {
                console.error('Error parsing rule:', error);
                return null;
            }
        }

        // Import policy as new layer
        function importPolicy() {
            // Check if importing from dashboard
            const importFromDashboard = window.importFromDashboard || false;
            
            if (!importFromDashboard && !currentPolicyId) {
                alert('No policy selected');
                return;
            }

            // Get XML from either file or text input
            const fileInput = document.getElementById('import-file-input');
            const textInput = document.getElementById('import-xml-text');
            let xmlText = null;

            if (fileInput.files[0]) {
                // Use file input
                const reader = new FileReader();
                reader.onload = function(e) {
                    processImportXML(e.target.result);
                };
                reader.readAsText(fileInput.files[0]);
                return;
            } else if (textInput.value.trim()) {
                // Use text input
                xmlText = textInput.value.trim();
                processImportXML(xmlText);
                return;
            } else {
                alert('Please either upload a file or paste XML content');
                return;
            }
        }

        // Process imported XML
        function processImportXML(xmlText) {
            try {
                // Check if importing from dashboard
                const importFromDashboard = window.importFromDashboard || false;
                
                // Use stored parse result if available, otherwise parse now
                let parseResult = window.lastImportParseResult;
                if (!parseResult) {
                    parseResult = parseAppLockerXML(xmlText);
                }
                
                const layerName = document.getElementById('import-layer-name').value.trim();
                const businessJustification = document.getElementById('import-business-justification').value.trim() || 'Imported from existing AppLocker policy';
                
                if (parseResult.error) {
                    alert('Error parsing policy: ' + parseResult.error);
                    return;
                }

                if (!parseResult.rules || parseResult.rules.length === 0) {
                    alert('No rules found in the policy');
                    return;
                }

                // Handle dashboard import - create new policy
                let policy;
                if (importFromDashboard || !currentPolicyId) {
                    // Create new policy from imported XML
                    let policyName = 'Imported Policy';
                    let policyDescription = 'Policy imported from AppLocker XML';
                    let systemClasses = [];
                    
                    // Use metadata from imported XML if available
                    if (parseResult.policyMetadata) {
                        policyName = parseResult.policyMetadata.policy_name || policyName;
                        policyDescription = parseResult.policyMetadata.description || policyDescription;
                        systemClasses = parseResult.policyMetadata.system_classes || [];
                    } else {
                        // Prompt for policy name if no metadata
                        const userPolicyName = prompt('Enter a name for the new policy:', policyName);
                        if (!userPolicyName) {
                            return; // User cancelled
                        }
                        policyName = userPolicyName;
                    }
                    
                    policy = {
                        policy_id: generateId(),
                        policy_name: policyName,
                        description: policyDescription,
                        system_classes: systemClasses,
                        status: 'DRAFT',
                        created_at: new Date().toISOString(),
                        layers: []
                    };
                    
                    policies.push(policy);
                    currentPolicyId = policy.policy_id;
                    savePolicies();
                    
                    // Clear the dashboard flag
                    window.importFromDashboard = false;
                } else {
                    // Import into existing policy
                    policy = policies.find(p => p.policy_id === currentPolicyId);
                    if (!policy) {
                        alert('Policy not found');
                        return;
                    }
                }

                // Check if layer structure was preserved
                if (parseResult.hasLayerStructure && parseResult.layers && parseResult.layers.length > 0) {
                    // Layers preserved - no need for layer name
                    // Import all layers with preserved structure
                    const nextPrecedence = policy.layers.length;
                    let importedCount = 0;
                    
                    // Sort layers by precedence to maintain order
                    const sortedLayers = [...parseResult.layers].sort((a, b) => 
                        (a.layer_precedence || 0) - (b.layer_precedence || 0)
                    );
                    
                    sortedLayers.forEach((importedLayer, index) => {
                        // Skip baseline layers if they already exist
                        if (importedLayer.layer_type === 'BASELINE') {
                            const existingBaseline = policy.layers.find(l => l.layer_type === 'BASELINE');
                            if (existingBaseline) {
                                // Merge rules into existing baseline (or skip)
                                return;
                            }
                        }
                        
                        // Use the original precedence from the imported layer, adjusted for existing layers
                        const originalPrecedence = importedLayer.layer_precedence || 0;
                        const adjustedPrecedence = nextPrecedence + originalPrecedence;
                        
                        const layer = {
                            layer_id: importedLayer.layer_id || generateId(),
                            policy_id: currentPolicyId,
                            layer_type: importedLayer.layer_type || 'IMPORTED',
                            layer_name: importedLayer.layer_name || `${layerName} - Layer ${index + 1}`,
                            layer_precedence: adjustedPrecedence,
                            business_justification: importedLayer.business_justification || businessJustification,
                            is_locked: importedLayer.is_locked || (importedLayer.layer_type === 'BASELINE'),
                            deviates_from_baseline: importedLayer.deviates_from_baseline || false,
                            deviation_reason: importedLayer.deviation_reason || null,
                            deviation_risk_level: importedLayer.deviation_risk_level || null,
                            deviation_mitigation: importedLayer.deviation_mitigation || null,
                            app_name: importedLayer.app_name || null,
                            app_vendor: importedLayer.app_vendor || null,
                            rules: (importedLayer.rules || []).map(rule => ({
                                ...rule,
                                rule_id: rule.rule_id || generateId(),
                                created_at: new Date().toISOString()
                            }))
                        };
                        
                        // Only add layer if it has rules
                        if (layer.rules.length > 0) {
                            policy.layers.push(layer);
                            importedCount++;
                        }
                    });
                    
                    savePolicies();
                    closeModal('import-modal');
                    
                    // Switch to policy view (always, since we either created a new policy or imported into existing)
                    renderPoliciesList();
                    viewPolicy(currentPolicyId);
                    
                    alert(`Successfully imported ${importedCount} layer(s) with ${parseResult.rules.length} rule(s). Layer structure preserved.`);
                } else {
                    // No layer structure - create single layer (backward compatibility)
                    // Validate layer name is provided
                    if (!layerName) {
                        alert('Please enter a layer name');
                        return;
                    }
                    
                    const nextPrecedence = policy.layers.length;
                    const layer = {
                        layer_id: generateId(),
                        policy_id: currentPolicyId,
                        layer_type: 'IMPORTED',
                        layer_name: layerName,
                        layer_precedence: nextPrecedence,
                        business_justification: businessJustification,
                        is_locked: false,
                        deviates_from_baseline: false,
                        rules: parseResult.rules.map(rule => ({
                            ...rule,
                            rule_id: rule.rule_id || generateId(),
                            created_at: new Date().toISOString()
                        }))
                    };

                    policy.layers.push(layer);
                    savePolicies();
                    closeModal('import-modal');
                    
                    // Switch to policy view (always, since we either created a new policy or imported into existing)
                    renderPoliciesList();
                    viewPolicy(currentPolicyId);
                    
                    alert(`Successfully imported ${parseResult.rules.length} rule(s) as new layer "${layerName}"`);
                }
            } catch (error) {
                alert('Error importing policy: ' + error.message);
            }
        }

        // ZIP Import Functions
        let zipFileData = []; // Store processed file data

        // Detect file category based on file extension
        // Returns null if file type is not supported by AppLocker
        function detectFileCategory(fileName) {
            const ext = fileName.split('.').pop()?.toLowerCase() || '';
            
            // If no extension, not supported
            if (!ext || ext === fileName.toLowerCase()) {
                return null;
            }
            
            // EXE files
            if (ext === 'exe' || ext === 'com' || ext === 'scr') {
                return 'EXE';
            }
            
            // DLL files
            if (ext === 'dll' || ext === 'ocx' || ext === 'cpl') {
                return 'DLL';
            }
            
            // Script files
            if (ext === 'ps1' || ext === 'vbs' || ext === 'js' || ext === 'bat' || 
                ext === 'cmd' || ext === 'wsf' || ext === 'wsh' || ext === 'jse' || 
                ext === 'vbe' || ext === 'msh' || ext === 'msh1' || ext === 'msh2' || 
                ext === 'mshxml' || ext === 'msh1xml' || ext === 'msh2xml') {
                return 'SCRIPT';
            }
            
            // MSI files
            if (ext === 'msi' || ext === 'msp' || ext === 'mst') {
                return 'MSI';
            }
            
            // APPX files
            if (ext === 'appx' || ext === 'appxbundle' || ext === 'msix' || ext === 'msixbundle') {
                return 'APPX';
            }
            
            // CHM files
            if (ext === 'chm') {
                return 'CHM';
            }
            
            // HTA files
            if (ext === 'hta') {
                return 'HTA';
            }
            
            // Not a supported AppLocker file type
            return null;
        }

        function showZipImport() {
            // This function is kept for backward compatibility but now opens the add-layer-modal
            if (!currentPolicyId) {
                alert('Please select a policy first');
                return;
            }
            showAddLayer();
            showFolderHashImport();
        }

        async function handleZipFileSelect(input) {
            const file = input.files[0];
            if (!file) {
                document.getElementById('zip-file-list-section').style.display = 'none';
                document.getElementById('zip-import-btn').disabled = true;
                return;
            }

            if (!file.name.endsWith('.zip')) {
                alert('Please select a ZIP file');
                input.value = '';
                return;
            }

            // Show processing status
            document.getElementById('zip-processing-status').style.display = 'block';
            document.getElementById('zip-file-list-section').style.display = 'none';
            document.getElementById('zip-import-btn').disabled = true;
            document.getElementById('zip-import-error').style.display = 'none';

            try {
                // Read ZIP file
                const arrayBuffer = await file.arrayBuffer();
                const zip = await JSZip.loadAsync(arrayBuffer);
                
                // Get all files from ZIP (recursively processes all files including those in subfolders)
                const fileEntries = [];
                zip.forEach((relativePath, file) => {
                    // Skip directory entries, but process all files including those in nested subfolders
                    // relativePath includes the full path with subfolder structure (e.g., "folder/subfolder/file.dll")
                    if (!file.dir) {
                        fileEntries.push({ path: relativePath, file: file });
                    }
                });

                if (fileEntries.length === 0) {
                    throw new Error('ZIP file is empty or contains only directories');
                }

                // Process files
                zipFileData = [];
                const skippedFiles = [];
                let processedCount = 0;
                const totalFiles = fileEntries.length;

                document.getElementById('zip-processing-text').textContent = `Processing ${totalFiles} files...`;

                for (const entry of fileEntries) {
                    try {
                        // Get file name from path
                        const fileName = entry.path.split('/').pop() || entry.path.split('\\').pop() || entry.path;
                        
                        // Detect file category based on extension - skip if not supported
                        const detectedCategory = detectFileCategory(fileName);
                        
                        if (!detectedCategory) {
                            // File type not supported by AppLocker - skip it
                            skippedFiles.push({
                                path: entry.path,
                                fileName: fileName
                            });
                            processedCount++;
                            const progress = Math.round((processedCount / totalFiles) * 100);
                            document.getElementById('zip-progress-bar').style.width = progress + '%';
                            document.getElementById('zip-progress-text').textContent = `${progress}% (${processedCount}/${totalFiles})`;
                            continue;
                        }
                        
                        // Read file as ArrayBuffer
                        const fileData = await entry.file.async('arraybuffer');
                        
                        // Calculate SHA-256 hash
                        const hashBuffer = await crypto.subtle.digest('SHA-256', fileData);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

                        // Only add files with supported AppLocker categories
                        zipFileData.push({
                            path: entry.path,
                            fileName: fileName,
                            hash: hashHex,
                            size: fileData.byteLength,
                            selected: true,
                            detectedCategory: detectedCategory
                        });

                        processedCount++;
                        const progress = Math.round((processedCount / totalFiles) * 100);
                        document.getElementById('zip-progress-bar').style.width = progress + '%';
                        document.getElementById('zip-progress-text').textContent = `${progress}% (${processedCount}/${totalFiles})`;
                    } catch (error) {
                        console.error(`Error processing file ${entry.path}:`, error);
                        processedCount++;
                    }
                }
                
                // Store skipped files for display
                window.zipSkippedFiles = skippedFiles;

                // Check if we have any valid files
                if (zipFileData.length === 0) {
                    document.getElementById('zip-processing-status').style.display = 'none';
                    document.getElementById('zip-import-error').style.display = 'block';
                    let errorMsg = 'No AppLocker-supported files found in ZIP. ';
                    if (skippedFiles.length > 0) {
                        errorMsg += `Found ${skippedFiles.length} file(s) but none have supported extensions (EXE, DLL, SCRIPT, MSI, APPX, CHM, HTA).`;
                    } else {
                        errorMsg += 'ZIP file appears to be empty or contains only directories.';
                    }
                    document.getElementById('zip-import-error').textContent = errorMsg;
                    return;
                }

                // Hide processing status
                document.getElementById('zip-processing-status').style.display = 'none';
                
                // Auto-generate layer name if empty
                if (!document.getElementById('zip-layer-name').value.trim()) {
                    const date = new Date().toISOString().split('T')[0];
                    // Count unique categories
                    const uniqueCategories = [...new Set(zipFileData.map(f => f.detectedCategory).filter(c => c))];
                    const categoryLabel = uniqueCategories.length === 1 
                        ? uniqueCategories[0] 
                        : `${uniqueCategories.length} Categories`;
                    document.getElementById('zip-layer-name').value = `Bulk Import - ${categoryLabel} - ${date}`;
                }
                
                // Show file list
                displayZipFileList();
                document.getElementById('zip-file-list-section').style.display = 'block';
                document.getElementById('zip-import-btn').disabled = false;

            } catch (error) {
                document.getElementById('zip-processing-status').style.display = 'none';
                document.getElementById('zip-import-error').style.display = 'block';
                document.getElementById('zip-import-error').textContent = 'Error processing ZIP file: ' + error.message;
                console.error('Error processing ZIP:', error);
            }
        }

        function displayZipFileList() {
            const container = document.getElementById('zip-file-list');
            const ruleAction = document.getElementById('zip-rule-action').value;
            
            // Count files by category
            const categoryCounts = {};
            zipFileData.forEach(file => {
                const cat = file.detectedCategory || 'EXE';
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });
            
            let html = '';
            
            // Show summary with skipped files info
            const skippedFiles = window.zipSkippedFiles || [];
            html += `<div style="margin-bottom: 10px; padding: 8px; background: #e7f3ff; border-radius: 4px; font-size: 0.9em;">`;
            html += `<strong>Settings:</strong> Action: ${ruleAction} | Rule Type: HASH<br>`;
            html += `<strong>AppLocker-Supported Files:</strong> ${zipFileData.length} file(s)`;
            if (Object.keys(categoryCounts).length > 0) {
                html += ` | Categories: ${Object.keys(categoryCounts).map(cat => `${cat}: ${categoryCounts[cat]}`).join(', ')}`;
            }
            if (skippedFiles.length > 0) {
                html += `<br><span style="color: #856404; font-weight: bold;">‚ö† Skipped:</span> ${skippedFiles.length} file(s) not supported by AppLocker (will not be imported)`;
            }
            html += `</div>`;
            
            // Show skipped files section if any
            if (skippedFiles.length > 0) {
                html += `<div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">`;
                html += `<h4 style="margin-bottom: 8px; color: #856404; font-size: 0.95em;">Skipped Files (${skippedFiles.length}) - Not Supported by AppLocker</h4>`;
                html += `<div style="max-height: 150px; overflow-y: auto; font-size: 0.85em;">`;
                skippedFiles.forEach(skipped => {
                    html += `<div style="padding: 4px 0; color: #856404;">`;
                    html += `<span style="font-family: monospace;">${escapeHtml(skipped.fileName)}</span>`;
                    if (skipped.path !== skipped.fileName) {
                        html += ` <span style="color: #999;">(${escapeHtml(skipped.path)})</span>`;
                    }
                    html += `</div>`;
                });
                html += `</div>`;
                html += `<small style="color: #856404;">These files do not have extensions supported by AppLocker and will not be imported.</small>`;
                html += `</div>`;
            }
            
            // Group files by category for better organization
            // Only include files with valid categories (should all be valid at this point, but double-check)
            const filesByCategory = {};
            zipFileData.forEach((file, index) => {
                const cat = file.detectedCategory;
                if (cat) { // Only process files with valid categories
                    if (!filesByCategory[cat]) {
                        filesByCategory[cat] = [];
                    }
                    filesByCategory[cat].push({ file, index });
                }
            });
            
            // Display files grouped by category
            Object.keys(filesByCategory).sort().forEach(category => {
                html += `<div style="margin: 15px 0;">`;
                html += `<h4 style="margin-bottom: 8px; color: #667eea; font-size: 1em;">${category} Files (${filesByCategory[category].length})</h4>`;
                
                filesByCategory[category].forEach(({ file, index }) => {
                    const fileSizeKB = (file.size / 1024).toFixed(2);
                    const actionColor = ruleAction === 'ALLOW' ? '#28a745' : '#dc3545';
                    const categoryColors = {
                        'EXE': '#667eea',
                        'DLL': '#17a2b8',
                        'SCRIPT': '#ffc107',
                        'MSI': '#28a745',
                        'APPX': '#6f42c1',
                        'CHM': '#fd7e14',
                        'HTA': '#dc3545'
                    };
                    const catColor = categoryColors[category] || '#667eea';
                    
                    html += `<div style="padding: 10px; margin: 5px 0; background: white; border: 1px solid #ddd; border-radius: 4px; display: flex; align-items: center;">`;
                    html += `<input type="checkbox" id="zip-file-${index}" ${file.selected ? 'checked' : ''} onchange="updateZipFileSelection(${index})" style="margin-right: 10px; width: 18px; height: 18px;">`;
                    html += `<div style="flex: 1;">`;
                    html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">`;
                    html += `<strong>${escapeHtml(file.fileName)}</strong>`;
                    html += `<span style="padding: 2px 8px; background: ${actionColor}; color: white; border-radius: 3px; font-size: 0.75em; font-weight: bold;">${ruleAction}</span>`;
                    html += `<span style="padding: 2px 8px; background: ${catColor}; color: white; border-radius: 3px; font-size: 0.75em;">${category}</span>`;
                    html += `</div>`;
                    html += `<small style="color: #666; display: block;">Path: ${escapeHtml(file.path)}</small>`;
                    html += `<small style="color: #666; display: block;">Size: ${fileSizeKB} KB | Hash: ${file.hash.substring(0, 32)}...</small>`;
                    html += `</div>`;
                    html += `</div>`;
                });
                
                html += `</div>`;
            });

            container.innerHTML = html;
            updateZipFileCounts();
        }

        function updateZipFileSelection(index) {
            const checkbox = document.getElementById(`zip-file-${index}`);
            zipFileData[index].selected = checkbox.checked;
            updateZipFileCounts();
        }

        function selectAllZipFiles() {
            zipFileData.forEach((file, index) => {
                file.selected = true;
                const checkbox = document.getElementById(`zip-file-${index}`);
                if (checkbox) checkbox.checked = true;
            });
            updateZipFileCounts();
        }

        function deselectAllZipFiles() {
            zipFileData.forEach((file, index) => {
                file.selected = false;
                const checkbox = document.getElementById(`zip-file-${index}`);
                if (checkbox) checkbox.checked = false;
            });
            updateZipFileCounts();
        }

        function updateZipFileCounts() {
            const total = zipFileData.length;
            const selected = zipFileData.filter(f => f.selected).length;
            document.getElementById('zip-file-count').textContent = total;
            document.getElementById('zip-selected-count').textContent = selected;
            document.getElementById('zip-import-btn').disabled = selected === 0;
        }

        function importZipFiles() {
            if (!currentPolicyId) {
                alert('No policy selected');
                return;
            }

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }

            const selectedFiles = zipFileData.filter(f => f.selected);
            if (selectedFiles.length === 0) {
                alert('Please select at least one file to import');
                return;
            }

            const layerName = document.getElementById('zip-layer-name').value.trim();
            if (!layerName) {
                alert('Please enter a layer name');
                return;
            }

            const businessJustification = document.getElementById('zip-business-justification').value.trim() || 'Bulk import of files from ZIP archive';
            const ruleAction = document.getElementById('zip-rule-action').value;

            // Filter to only include files with valid AppLocker categories
            const validFiles = selectedFiles.filter(file => file.detectedCategory);
            
            if (validFiles.length === 0) {
                alert('No valid AppLocker-supported files selected. All selected files must have supported extensions.');
                return;
            }
            
            if (validFiles.length < selectedFiles.length) {
                const skipped = selectedFiles.length - validFiles.length;
                if (!confirm(`${skipped} selected file(s) do not have valid AppLocker categories and will be skipped. Continue with ${validFiles.length} file(s)?`)) {
                    return;
                }
            }

            // Create rules from valid files, using detected category for each file
            const rules = validFiles.map(file => {
                return {
                    rule_id: generateId(),
                    rule_name: `Hash Rule: ${file.fileName}`,
                    rule_type: 'HASH',
                    file_category: file.detectedCategory,
                    action: ruleAction,
                    hash_sha256: file.hash,
                    hash_type: 'SHA256',
                    hash_filename: file.fileName,
                    source_file_length: file.size,
                    business_justification: `${businessJustification} - File: ${file.fileName} (${file.detectedCategory})`,
                    user_or_group_sid: 'S-1-1-0',
                    created_at: new Date().toISOString()
                };
            });

            // Create new layer
            const nextPrecedence = policy.layers.length;
            const layer = {
                layer_id: generateId(),
                policy_id: currentPolicyId,
                layer_type: 'IMPORTED',
                layer_name: layerName,
                layer_precedence: nextPrecedence,
                business_justification: businessJustification,
                is_locked: false,
                deviates_from_baseline: false,
                rules: rules
            };

            policy.layers.push(layer);
            savePolicies();
            closeModal('add-layer-modal');
            viewPolicy(currentPolicyId);

            alert(`Successfully imported ${validFiles.length} file(s) as ${rules.length} rule(s) in layer "${layerName}"`);
        }

        // Show export modal
        function showExport() {
            if (!currentPolicyId) return;
            document.getElementById('export-modal').style.display = 'block';
            
            // Show/hide layer preservation option based on format
            const formatSelect = document.getElementById('export-format');
            const layerPreservationGroup = document.getElementById('export-layer-preservation-group');
            
            function updateLayerPreservationVisibility() {
                if (formatSelect.value === 'group_policy') {
                    layerPreservationGroup.style.display = 'block';
                } else {
                    layerPreservationGroup.style.display = 'none';
                }
            }
            
            // Set initial visibility
            updateLayerPreservationVisibility();
            
            // Update on format change
            formatSelect.onchange = updateLayerPreservationVisibility;
        }

        // Export policy
        function exportPolicy() {
            if (!currentPolicyId) return;

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) return;

            const format = document.getElementById('export-format').value;
            const enforcementMode = document.getElementById('export-enforcement-mode').value || 'Enabled';
            const preserveLayers = document.getElementById('export-preserve-layers') ? document.getElementById('export-preserve-layers').checked : true;
            let content = '';
            let filename = '';
            let mimeType = '';

            if (format === 'group_policy') {
                content = exportToGroupPolicyXML(policy, enforcementMode, preserveLayers);
                filename = `AppLockerPolicy-${policy.policy_name.replace(/[^a-z0-9]/gi, '_')}.xml`;
                mimeType = 'application/xml';
            } else if (format === 'intune') {
                content = exportToIntuneJSON(policy, enforcementMode, preserveLayers);
                filename = `AppLockerPolicy-${policy.policy_name.replace(/[^a-z0-9]/gi, '_')}.json`;
                mimeType = 'application/json';
            } else {
                content = exportToText(policy);
                filename = `AppLockerPolicy-${policy.policy_name.replace(/[^a-z0-9]/gi, '_')}.txt`;
                mimeType = 'text/plain';
            }

            downloadFile(filename, content, mimeType);
            closeModal('export-modal');
        }

        // Export to Group Policy XML
        function exportToGroupPolicyXML(policy, enforcementMode = 'Enabled', preserveLayers = true) {
            // Validate EnforcementMode - AppLocker accepts "Enabled", "AuditOnly", or "NotConfigured"
            const validEnforcementMode = (enforcementMode === 'Enabled' || enforcementMode === 'AuditOnly' || enforcementMode === 'NotConfigured') 
                ? enforcementMode 
                : 'Enabled';
            
            let xml = '<?xml version="1.0" encoding="utf-8"?>\n';
            xml += '<AppLockerPolicy Version="1">\n';
            xml += '  <!-- KNOWN LIMITATIONS:\n';
            xml += '       1. .NET 4.0+ DLL Rules: AppLocker DLL rules do NOT fire for .NET 4.0+ assemblies.\n';
            xml += '          AppLocker cannot control .NET DLLs loaded by .NET 4.0+ executables.\n';
            xml += '          Mitigation: Use WDAC for .NET 4.0+ environments, or enforce strong-name verification.\n';
            xml += '          Risk accepted: [Document who approved this risk]\n';
            xml += '       2. Windows 11 24H2 Script Bug: Windows 11 24H2 has a bug where Script rules fail to enforce\n';
            xml += '          PowerShell Constrained Language Mode. Patched in May 2025 updates.\n';
            xml += '          Mitigation: Ensure May 2025 patches applied before deployment.\n';
            xml += '          Test: $ExecutionContext.SessionState.LanguageMode should = "ConstrainedLanguage"\n';
            xml += '       3. LOLBin Blocking Philosophy: mshta.exe, wscript.exe, cscript.exe are blocked entirely\n';
            xml += '          (NO EXCEPTIONS) per Microsoft/NSA recommendation. This may break VBScript/JScript-dependent apps.\n';
            xml += '          Alternative: Allow from System32 and rely on Script rules to block user-writable script files.\n';
            xml += '  -->\n';
            
            // Add policy metadata as comment if preserving layers
            if (preserveLayers) {
                const policyMetadata = {
                    policy_name: policy.policy_name,
                    description: policy.description,
                    system_classes: policy.system_classes,
                    exported_at: new Date().toISOString(),
                    format: 'applocker-with-layers'
                };
                xml += `  <!-- PolicyMetadata:${escapeXml(JSON.stringify(policyMetadata))} -->\n`;
            }
            
            // Sort layers by precedence
            const sortedLayers = [...policy.layers].sort((a, b) => a.layer_precedence - b.layer_precedence);
            
            // Helper function to check if there are rules for a category
            function hasRulesForCategory(layers, fileCategory, categoryName) {
                for (const layer of layers) {
                    if (layer.rules) {
                        const hasRules = layer.rules.some(rule => {
                            if (categoryName === 'Exe') {
                                return rule.file_category === 'EXE' || rule.file_category === 'CHM' || rule.file_category === 'HTA';
                            }
                            return rule.file_category === fileCategory;
                        });
                        if (hasRules) return true;
                    }
                }
                return false;
            }
            
            // Helper function to add layer comment and rules for a specific file category
            function addLayerRulesForCategory(layers, fileCategory, categoryName) {
                let hasRules = false;
                let lastLayerId = null;
                
                layers.forEach(layer => {
                    if (layer.rules) {
                        const categoryRules = layer.rules.filter(rule => {
                            if (categoryName === 'Exe') {
                                return rule.file_category === 'EXE' || rule.file_category === 'CHM' || rule.file_category === 'HTA';
                            }
                            return rule.file_category === fileCategory;
                        });
                        
                        if (categoryRules.length > 0) {
                            // Add layer comment if layer changed or first rule
                            if (preserveLayers && layer.layer_id !== lastLayerId) {
                                const layerMetadata = {
                                    layer_id: layer.layer_id,
                                    layer_name: layer.layer_name,
                                    layer_type: layer.layer_type,
                                    layer_precedence: layer.layer_precedence,
                                    business_justification: layer.business_justification,
                                    deviates_from_baseline: layer.deviates_from_baseline,
                                    deviation_reason: layer.deviation_reason || null,
                                    deviation_risk_level: layer.deviation_risk_level || null,
                                    deviation_mitigation: layer.deviation_mitigation || null,
                                    app_name: layer.app_name || null,
                                    app_vendor: layer.app_vendor || null
                                };
                                xml += `    <!-- Layer:${escapeXml(JSON.stringify(layerMetadata))} -->\n`;
                                lastLayerId = layer.layer_id;
                            }
                            
                            categoryRules.forEach(rule => {
                                xml += generateRuleXML(rule, layer);
                                hasRules = true;
                            });
                        }
                    }
                });
                
                return hasRules;
            }
            
            // Exe RuleCollection (includes EXE, CHM, HTA)
            if (hasRulesForCategory(sortedLayers, 'EXE', 'Exe')) {
                xml += `  <RuleCollection Type="Exe" EnforcementMode="${validEnforcementMode}">\n`;
                addLayerRulesForCategory(sortedLayers, 'EXE', 'Exe');
                xml += '  </RuleCollection>\n';
            }
            
            // Dll RuleCollection
            if (hasRulesForCategory(sortedLayers, 'DLL', 'Dll')) {
                xml += `  <RuleCollection Type="Dll" EnforcementMode="${validEnforcementMode}">\n`;
                addLayerRulesForCategory(sortedLayers, 'DLL', 'Dll');
                xml += '  </RuleCollection>\n';
            }
            
            // Script RuleCollection
            if (hasRulesForCategory(sortedLayers, 'SCRIPT', 'Script')) {
                xml += `  <RuleCollection Type="Script" EnforcementMode="${validEnforcementMode}">\n`;
                addLayerRulesForCategory(sortedLayers, 'SCRIPT', 'Script');
                xml += '  </RuleCollection>\n';
            }
            
            // Msi RuleCollection
            if (hasRulesForCategory(sortedLayers, 'MSI', 'Msi')) {
                xml += `  <RuleCollection Type="Msi" EnforcementMode="${validEnforcementMode}">\n`;
                addLayerRulesForCategory(sortedLayers, 'MSI', 'Msi');
                xml += '  </RuleCollection>\n';
            }
            
            // Appx RuleCollection
            if (hasRulesForCategory(sortedLayers, 'APPX', 'Appx')) {
                xml += `  <RuleCollection Type="Appx" EnforcementMode="${validEnforcementMode}">\n`;
                addLayerRulesForCategory(sortedLayers, 'APPX', 'Appx');
                xml += '  </RuleCollection>\n';
            }
            
            xml += '</AppLockerPolicy>\n';
            
            return xml;
        }

        // Generate rule XML
        function generateRuleXML(rule, layer) {
            const userOrGroupSid = rule.user_or_group_sid || 'S-1-1-0';
            
            // Ensure Action is properly capitalized (AppLocker requires "Allow" or "Deny")
            const action = rule.action === 'ALLOW' ? 'Allow' : 
                           rule.action === 'DENY' ? 'Deny' : 
                           rule.action || 'Allow';
            
            // Ensure rule_id is a valid GUID format
            let ruleId = rule.rule_id;
            if (!ruleId || !/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(ruleId)) {
                ruleId = generateId();
            }
            
            let xml = '    <FilePublisherRule Id="' + escapeXml(ruleId) + '" Name="' + escapeXml(rule.rule_name || 'Unnamed Rule') + '" Description="' + escapeXml(rule.business_justification || '') + '" UserOrGroupSid="' + escapeXml(userOrGroupSid) + '" Action="' + action + '">\n';
            
            if (rule.rule_type === 'PUBLISHER' && rule.publisher_name) {
                xml += '      <Conditions>\n';
                xml += '        <FilePublisherCondition PublisherName="' + escapeXml(rule.publisher_name) + '" ProductName="' + escapeXml(rule.publisher_product || '*') + '" BinaryName="' + escapeXml(rule.publisher_file || '*') + '">\n';
                if (rule.version_low || rule.version_high) {
                    xml += '          <BinaryVersionRange LowSection="' + escapeXml(rule.version_low || '*') + '" HighSection="' + escapeXml(rule.version_high || '*') + '" />\n';
                }
                xml += '        </FilePublisherCondition>\n';
                xml += '      </Conditions>\n';
            } else if (rule.rule_type === 'PATH' && rule.path) {
                xml = xml.replace('FilePublisherRule', 'FilePathRule');
                xml = xml.replace('FilePublisherCondition', 'FilePathCondition');
                xml += '      <Conditions>\n';
                xml += '        <FilePathCondition Path="' + escapeXml(rule.path) + '" />\n';
                xml += '      </Conditions>\n';
                
                // Add exceptions if they exist
                // CRITICAL: AppLocker XML schema requires <FilePathCondition> inside <Exceptions>, NOT <Exception>
                if (rule.exceptions && rule.exceptions.length > 0) {
                    xml += '      <Exceptions>\n';
                    rule.exceptions.forEach(exception => {
                        const exceptionPath = typeof exception === 'string' ? exception : exception.path;
                        if (exceptionPath) {
                            xml += '        <FilePathCondition Path="' + escapeXml(exceptionPath) + '" />\n';
                        }
                    });
                    xml += '      </Exceptions>\n';
                }
            } else if (rule.rule_type === 'HASH' && rule.hash_sha256) {
                xml = xml.replace('FilePublisherRule', 'FileHashRule');
                xml = xml.replace('FilePublisherCondition', 'FileHashCondition');
                const hashType = rule.hash_type || 'SHA256';
                // Ensure hash type is valid for AppLocker
                const validHashType = ['SHA256', 'SHA256FLAT', 'SHA2', 'SHA2FLAT'].includes(hashType) ? hashType : 'SHA256';
                const fileLength = rule.hash_file_length || rule.source_file_length || 0;
                xml += '      <Conditions>\n';
                xml += '        <FileHashCondition>\n';
                let fileHashAttrs = 'Type="' + escapeXml(validHashType) + '" Data="' + escapeXml(rule.hash_sha256) + '"';
                if (rule.hash_filename) {
                    fileHashAttrs += ' SourceFileName="' + escapeXml(rule.hash_filename) + '"';
                }
                if (fileLength > 0) {
                    fileHashAttrs += ' SourceFileLength="' + fileLength + '"';
                }
                xml += '          <FileHash ' + fileHashAttrs + ' />\n';
                xml += '        </FileHashCondition>\n';
                xml += '      </Conditions>\n';
            } else {
                // Fallback: if rule type is not recognized, try to export as PATH if path exists
                if (rule.path) {
                    xml = xml.replace('FilePublisherRule', 'FilePathRule');
                    xml += '      <Conditions>\n';
                    xml += '        <FilePathCondition Path="' + escapeXml(rule.path) + '" />\n';
                    xml += '      </Conditions>\n';
                } else {
                    // Invalid rule - return empty or minimal rule
                    console.warn('Rule has invalid type or missing required fields:', rule);
                    return '';
                }
            }
            
            // Determine closing tag based on rule type
            let closingTag = 'FilePublisherRule';
            if (rule.rule_type === 'PATH') {
                closingTag = 'FilePathRule';
            } else if (rule.rule_type === 'HASH') {
                closingTag = 'FileHashRule';
            }
            xml += '    </' + closingTag + '>\n';
            return xml;
        }

        // Generate standalone XML for a single rule (for display)
        function generateStandaloneRuleXML(rule) {
            // Determine the rule collection type based on file category
            // Note: CHM and HTA are controlled via Exe RuleCollection in AppLocker
            const collectionType = rule.file_category === 'EXE' ? 'Exe' :
                                  rule.file_category === 'DLL' ? 'Dll' :
                                  rule.file_category === 'SCRIPT' ? 'Script' :
                                  rule.file_category === 'MSI' ? 'Msi' :
                                  rule.file_category === 'APPX' ? 'Appx' :
                                  rule.file_category === 'CHM' ? 'Exe' :
                                  rule.file_category === 'HTA' ? 'Exe' : 'Exe';
            
            let xml = '<?xml version="1.0" encoding="utf-8"?>\n';
            xml += '<AppLockerPolicy Version="1">\n';
            xml += `  <RuleCollection Type="${collectionType}" EnforcementMode="Enabled">\n`;
            xml += generateRuleXML(rule, null);
            xml += '  </RuleCollection>\n';
            xml += '</AppLockerPolicy>\n';
            
            return xml;
        }

        // Toggle rule XML expansion
        function toggleRuleXML(element, event) {
            // Don't toggle if clicking on action buttons, edit form, or drag handle
            if (event) {
                const target = event.target;
                if (target.closest('.rule-actions') || 
                    target.closest('.rule-edit-form') || 
                    target.closest('.rule-xml-actions') ||
                    target.closest('.drag-handle') ||
                    target.tagName === 'BUTTON' ||
                    target.tagName === 'INPUT' ||
                    target.tagName === 'SELECT' ||
                    target.tagName === 'TEXTAREA') {
                    return;
                }
                event.stopPropagation();
            }
            
            // Check if this rule is already expanded
            const isExpanded = element.classList.contains('expanded');
            
            // Collapse all other rules first
            document.querySelectorAll('.rule-item.expanded').forEach(item => {
                if (item !== element) {
                    item.classList.remove('expanded');
                }
            });
            
            // Toggle this rule
            if (isExpanded) {
                element.classList.remove('expanded');
            } else {
                element.classList.add('expanded');
                // Scroll into view if needed
                element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Toggle rules list for a layer
        function toggleRulesList(header) {
            const layerId = header.getAttribute('data-layer-id');
            const container = document.getElementById(`rules-list-${layerId}`);
            
            if (!container) {
                return;
            }
            
            const isExpanded = container.classList.contains('expanded');
            
            if (isExpanded) {
                container.classList.remove('expanded');
                header.classList.remove('expanded');
            } else {
                container.classList.add('expanded');
                header.classList.add('expanded');
            }
        }

        // Copy rule XML inline
        function copyRuleXMLInline(button, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // Find the XML content in the same rule item
            const ruleItem = button.closest('.rule-item');
            const xmlContent = ruleItem.querySelector('.rule-xml-content');
            
            if (!xmlContent) {
                alert('XML content not found');
                return;
            }
            
            const xml = xmlContent.textContent;
            
            navigator.clipboard.writeText(xml).then(() => {
                const originalText = button.textContent;
                button.textContent = '‚úì Copied!';
                button.classList.add('btn-success');
                button.classList.remove('btn-primary');
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.classList.remove('btn-success');
                    button.classList.add('btn-primary');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err.message);
            });
        }

        // Generate rule edit form HTML
        function generateRuleEditForm(rule, ruleId, layerId) {
            let html = `<div class="rule-edit-form" data-rule-id="${ruleId}" data-layer-id="${layerId}">`;
            html += `<div class="form-group">`;
            html += `<label>Rule Name *</label>`;
            html += `<input type="text" class="edit-rule-name" value="${escapeHtml(rule.rule_name)}" required>`;
            html += `</div>`;
            
            html += `<div class="form-row">`;
            html += `<div class="form-group">`;
            html += `<label>Rule Type *</label>`;
            html += `<select class="edit-rule-type">`;
            html += `<option value="PATH" ${rule.rule_type === 'PATH' ? 'selected' : ''}>PATH</option>`;
            html += `<option value="PUBLISHER" ${rule.rule_type === 'PUBLISHER' ? 'selected' : ''}>PUBLISHER</option>`;
            html += `<option value="HASH" ${rule.rule_type === 'HASH' ? 'selected' : ''}>HASH</option>`;
            html += `</select>`;
            html += `</div>`;
            
            html += `<div class="form-group">`;
            html += `<label>File Category *</label>`;
            html += `<select class="edit-file-category" id="file-category-select-${ruleId}" onchange="updateFileCategoryInfo(this, '${ruleId}')">`;
            html += `<optgroup label="Executables (Exe RuleCollection)">`;
            html += `<option value="EXE" ${rule.file_category === 'EXE' ? 'selected' : ''}>EXE - Executable Files (.exe)</option>`;
            html += `<option value="CHM" ${rule.file_category === 'CHM' ? 'selected' : ''}>CHM - Compiled HTML Help (.chm)</option>`;
            html += `<option value="HTA" ${rule.file_category === 'HTA' ? 'selected' : ''}>HTA - HTML Applications (.hta)</option>`;
            html += `</optgroup>`;
            html += `<optgroup label="Libraries (Dll RuleCollection)">`;
            html += `<option value="DLL" ${rule.file_category === 'DLL' ? 'selected' : ''}>DLL - Dynamic Link Libraries (.dll)</option>`;
            html += `</optgroup>`;
            html += `<optgroup label="Scripts (Script RuleCollection)">`;
            html += `<option value="SCRIPT" ${rule.file_category === 'SCRIPT' ? 'selected' : ''}>SCRIPT - Scripts (.ps1, .vbs, .js, .bat, .cmd)</option>`;
            html += `</optgroup>`;
            html += `<optgroup label="Installers (Msi RuleCollection)">`;
            html += `<option value="MSI" ${rule.file_category === 'MSI' ? 'selected' : ''}>MSI - Windows Installer (.msi, .msp)</option>`;
            html += `</optgroup>`;
            html += `<optgroup label="Store Apps (Appx RuleCollection)">`;
            html += `<option value="APPX" ${rule.file_category === 'APPX' ? 'selected' : ''}>APPX - Windows Store Apps (.appx, .appxbundle)</option>`;
            html += `</optgroup>`;
            html += `</select>`;
            html += `<small style="display: block; margin-top: 5px; color: #666;" id="file-category-info-${ruleId}">`;
            html += `<span id="file-category-description-${ruleId}"></span>`;
            html += `</small>`;
            html += `</div>`;
            
            html += `<div class="form-group">`;
            html += `<label>Action *</label>`;
            html += `<select class="edit-action">`;
            html += `<option value="ALLOW" ${rule.action === 'ALLOW' ? 'selected' : ''}>ALLOW</option>`;
            html += `<option value="DENY" ${rule.action === 'DENY' ? 'selected' : ''}>DENY</option>`;
            html += `</select>`;
            html += `</div>`;
            html += `</div>`;
            
            // User/Group SID field
            html += `<div class="form-group">`;
            html += `<label>User or Group SID</label>`;
            html += `<select class="edit-user-group-sid-select" id="sid-select-${ruleId}" style="margin-bottom: 8px;" onchange="handleSidSelect(this, '${ruleId}')">`;
            html += `<option value="S-1-1-0" ${(rule.user_or_group_sid || 'S-1-1-0') === 'S-1-1-0' ? 'selected' : ''}>Everyone (S-1-1-0)</option>`;
            html += `<option value="S-1-5-11" ${rule.user_or_group_sid === 'S-1-5-11' ? 'selected' : ''}>Authenticated Users (S-1-5-11)</option>`;
            html += `<option value="S-1-5-18" ${rule.user_or_group_sid === 'S-1-5-18' ? 'selected' : ''}>Local System (S-1-5-18)</option>`;
            html += `<option value="S-1-5-19" ${rule.user_or_group_sid === 'S-1-5-19' ? 'selected' : ''}>NT Authority\\Local Service (S-1-5-19)</option>`;
            html += `<option value="S-1-5-20" ${rule.user_or_group_sid === 'S-1-5-20' ? 'selected' : ''}>NT Authority\\Network Service (S-1-5-20)</option>`;
            html += `<option value="S-1-5-32-544" ${rule.user_or_group_sid === 'S-1-5-32-544' ? 'selected' : ''}>Administrators (S-1-5-32-544)</option>`;
            html += `<option value="S-1-5-32-545" ${rule.user_or_group_sid === 'S-1-5-32-545' ? 'selected' : ''}>Users (S-1-5-32-545)</option>`;
            html += `<option value="S-1-5-32-546" ${rule.user_or_group_sid === 'S-1-5-32-546' ? 'selected' : ''}>Guests (S-1-5-32-546)</option>`;
            html += `<option value="S-1-5-32-547" ${rule.user_or_group_sid === 'S-1-5-32-547' ? 'selected' : ''}>Power Users (S-1-5-32-547)</option>`;
            html += `<option value="S-1-5-32-551" ${rule.user_or_group_sid === 'S-1-5-32-551' ? 'selected' : ''}>Backup Operators (S-1-5-32-551)</option>`;
            html += `<option value="S-1-5-32-552" ${rule.user_or_group_sid === 'S-1-5-32-552' ? 'selected' : ''}>Replicator (S-1-5-32-552)</option>`;
            html += `<option value="CUSTOM" ${!isCommonSid(rule.user_or_group_sid || 'S-1-1-0') ? 'selected' : ''}>Custom SID...</option>`;
            html += `</select>`;
            html += `<input type="text" class="edit-user-group-sid" id="sid-input-${ruleId}" value="${escapeHtml(rule.user_or_group_sid || 'S-1-1-0')}" placeholder="S-1-1-0" pattern="^S-1-[0-9-]+$" title="Security Identifier format: S-1-..." oninput="validateSidInput(this, '${ruleId}')">`;
            html += `<small style="display: block; margin-top: 5px; color: #666;">`;
            html += `<span id="sid-validation-${ruleId}" style="display: none; margin-right: 8px;"></span>`;
            html += `<span id="sid-helper-${ruleId}">Select a common SID from dropdown or type a custom SID</span>`;
            html += `</small>`;
            html += `</div>`;
            
            // PATH rule section
            html += `<div class="rule-type-section" id="path-section-${ruleId}" style="${rule.rule_type === 'PATH' ? '' : 'display: none;'}">`;
            html += `<h4>PATH Rule Settings</h4>`;
            html += `<div class="form-group">`;
            html += `<label>Path *</label>`;
            html += `<div style="display: flex; gap: 5px; margin-bottom: 5px; flex-wrap: wrap;">`;
            html += `<button type="button" class="btn btn-secondary" onclick="insertWildcard('${ruleId}', '*')" style="padding: 4px 8px; font-size: 0.8em;" title="All files">All Files (*)</button>`;
            html += `<button type="button" class="btn btn-secondary" onclick="insertWildcard('${ruleId}', '*.exe')" style="padding: 4px 8px; font-size: 0.8em;" title="All .exe files">*.exe</button>`;
            html += `<button type="button" class="btn btn-secondary" onclick="insertWildcard('${ruleId}', '*.dll')" style="padding: 4px 8px; font-size: 0.8em;" title="All .dll files">*.dll</button>`;
            html += `<button type="button" class="btn btn-secondary" onclick="insertWildcard('${ruleId}', '*.ps1')" style="padding: 4px 8px; font-size: 0.8em;" title="All .ps1 files">*.ps1</button>`;
            html += `<button type="button" class="btn btn-secondary" onclick="insertWildcard('${ruleId}', '*.chm')" style="padding: 4px 8px; font-size: 0.8em;" title="All .chm files">*.chm</button>`;
            html += `</div>`;
            html += `<input type="text" class="edit-path" id="path-input-${ruleId}" value="${escapeHtml(rule.path || '')}" placeholder="e.g., %PROGRAMFILES%\\*">`;
            html += `<small style="display: block; margin-top: 5px; color: #666;">`;
            html += `<strong>Wildcard Examples:</strong> <code>*</code> (all files), <code>*.exe</code> (all executables), <code>%PROGRAMFILES%\\*</code> (all files in Program Files), <code>%WINDIR%\\System32\\*.dll</code> (all DLLs in System32)`;
            html += `</small>`;
            html += `</div>`;
            html += `<div class="form-group">`;
            html += `<label>Exceptions (Excluded Paths)</label>`;
            html += `<div id="path-exceptions-${ruleId}" class="exceptions-list">`;
            const exceptions = rule.exceptions || [];
            exceptions.forEach((exception, idx) => {
                html += `<div class="exception-item" style="display: flex; gap: 5px; margin-bottom: 5px;">`;
                html += `<input type="text" class="exception-path" value="${escapeHtml(exception.path || exception)}" placeholder="e.g., %System32%\\excluded\\*" style="flex: 1;">`;
                html += `<button type="button" class="btn btn-danger" onclick="removeException(this, '${ruleId}')" style="padding: 5px 10px;">Remove</button>`;
                html += `</div>`;
            });
            html += `</div>`;
            html += `<button type="button" class="btn btn-secondary" onclick="addException('${ruleId}')" style="margin-top: 5px; padding: 5px 15px; font-size: 0.9em;">+ Add Exception</button>`;
            html += `</div>`;
            html += `</div>`;
            
            // PUBLISHER rule section
            html += `<div class="rule-type-section" id="publisher-section-${ruleId}" style="${rule.rule_type === 'PUBLISHER' ? '' : 'display: none;'}">`;
            html += `<h4>PUBLISHER Rule Settings</h4>`;
            html += `<div class="form-group">`;
            html += `<label>Publisher Name *</label>`;
            html += `<input type="text" class="edit-publisher-name" value="${escapeHtml(rule.publisher_name || '')}" placeholder="O=COMPANY, L=CITY, S=STATE, C=US">`;
            html += `</div>`;
            html += `<div class="form-row">`;
            html += `<div class="form-group">`;
            html += `<label>Product Name</label>`;
            html += `<input type="text" class="edit-publisher-product" value="${escapeHtml(rule.publisher_product || '')}" placeholder="Product Name">`;
            html += `</div>`;
            html += `<div class="form-group">`;
            html += `<label>File Pattern</label>`;
            html += `<input type="text" class="edit-publisher-file" value="${escapeHtml(rule.publisher_file || '*.exe')}" placeholder="*.exe">`;
            html += `</div>`;
            html += `</div>`;
            html += `<div class="form-row">`;
            html += `<div class="form-group">`;
            html += `<label>Version Low</label>`;
            html += `<input type="text" class="edit-version-low" value="${escapeHtml(rule.version_low || '')}" placeholder="0.0.0.0">`;
            html += `</div>`;
            html += `<div class="form-group">`;
            html += `<label>Version High</label>`;
            html += `<input type="text" class="edit-version-high" value="${escapeHtml(rule.version_high || '*')}" placeholder="*">`;
            html += `</div>`;
            html += `</div>`;
            html += `</div>`;
            
            // HASH rule section
            html += `<div class="rule-type-section" id="hash-section-${ruleId}" style="${rule.rule_type === 'HASH' ? '' : 'display: none;'}">`;
            html += `<h4>HASH Rule Settings</h4>`;
            html += `<div class="form-row">`;
            html += `<div class="form-group">`;
            html += `<label>Hash Type *</label>`;
            html += `<select class="edit-hash-type">`;
            html += `<option value="SHA256" ${(rule.hash_type || 'SHA256') === 'SHA256' ? 'selected' : ''}>SHA256</option>`;
            html += `<option value="SHA256Flat" ${rule.hash_type === 'SHA256Flat' ? 'selected' : ''}>SHA256Flat</option>`;
            html += `<option value="SHA256Authenticode" ${rule.hash_type === 'SHA256Authenticode' ? 'selected' : ''}>SHA256Authenticode</option>`;
            html += `</select>`;
            html += `</div>`;
            html += `<div class="form-group">`;
            html += `<label>Source File Length (bytes)</label>`;
            html += `<input type="number" class="edit-hash-filelength" value="${rule.hash_file_length || rule.source_file_length || '0'}" placeholder="0" min="0">`;
            html += `</div>`;
            html += `</div>`;
            html += `<div class="form-group">`;
            html += `<label>SHA-256 Hash *</label>`;
            html += `<input type="text" class="edit-hash-sha256" value="${escapeHtml(rule.hash_sha256 || '')}" placeholder="64 character hex hash">`;
            html += `</div>`;
            html += `<div class="form-row">`;
            html += `<div class="form-group">`;
            html += `<label>File Name</label>`;
            html += `<input type="text" class="edit-hash-filename" value="${escapeHtml(rule.hash_filename || '')}" placeholder="filename.exe">`;
            html += `</div>`;
            html += `<div class="form-group">`;
            html += `<label>File Version</label>`;
            html += `<input type="text" class="edit-hash-version" value="${escapeHtml(rule.hash_file_version || '')}" placeholder="1.0.0.0">`;
            html += `</div>`;
            html += `</div>`;
            html += `</div>`;
            
            html += `<div class="form-group">`;
            html += `<label>Business Justification *</label>`;
            html += `<textarea class="edit-business-justification" required>${escapeHtml(rule.business_justification || '')}</textarea>`;
            html += `</div>`;
            
            html += `<div class="form-actions">`;
            html += `<button class="btn btn-success" onclick="saveRuleEdit(this, event)">üíæ Save</button>`;
            html += `<button class="btn btn-secondary" onclick="cancelRuleEdit(this, event)">Cancel</button>`;
            html += `</div>`;
            html += `</div>`;
            
            return html;
        }

        // Toggle rule edit mode
        function toggleRuleEdit(button, event) {
            if (event) {
                event.stopPropagation();
            }
            
            const ruleItem = button.closest('.rule-item');
            const isEditing = ruleItem.classList.contains('editing');
            
            // Close all other editing rules
            document.querySelectorAll('.rule-item.editing').forEach(item => {
                if (item !== ruleItem) {
                    item.classList.remove('editing');
                }
            });
            
            // Toggle this rule
            if (isEditing) {
                ruleItem.classList.remove('editing');
                button.textContent = '‚úèÔ∏è Edit';
            } else {
                ruleItem.classList.add('editing');
                button.textContent = '‚úñÔ∏è Cancel';
                // Show/hide rule type sections based on selected type
                updateRuleTypeSections(ruleItem);
                // Initialize file category info
                setTimeout(() => initializeFileCategoryInfo(ruleItem), 10);
                // Scroll into view
                ruleItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // Update rule type sections visibility
        function updateRuleTypeSections(ruleItem) {
            const ruleType = ruleItem.querySelector('.edit-rule-type').value;
            const ruleId = ruleItem.getAttribute('data-rule-id');
            
            // Hide all sections
            ruleItem.querySelectorAll('.rule-type-section').forEach(section => {
                section.style.display = 'none';
            });
            
            // Show relevant section
            if (ruleType === 'PATH') {
                const section = document.getElementById(`path-section-${ruleId}`);
                if (section) section.style.display = 'block';
            } else if (ruleType === 'PUBLISHER') {
                const section = document.getElementById(`publisher-section-${ruleId}`);
                if (section) section.style.display = 'block';
            } else if (ruleType === 'HASH') {
                const section = document.getElementById(`hash-section-${ruleId}`);
                if (section) section.style.display = 'block';
            }
        }

        // Add exception to PATH rule
        function addException(ruleId) {
            const exceptionsList = document.getElementById(`path-exceptions-${ruleId}`);
            if (!exceptionsList) return;
            
            const exceptionItem = document.createElement('div');
            exceptionItem.className = 'exception-item';
            exceptionItem.style.cssText = 'display: flex; gap: 5px; margin-bottom: 5px;';
            exceptionItem.innerHTML = `
                <input type="text" class="exception-path" placeholder="e.g., %System32%\\excluded\\*" style="flex: 1;">
                <button type="button" class="btn btn-danger" onclick="removeException(this, '${ruleId}')" style="padding: 5px 10px;">Remove</button>
            `;
            exceptionsList.appendChild(exceptionItem);
        }

        // Remove exception from PATH rule
        function removeException(button, ruleId) {
            const exceptionItem = button.closest('.exception-item');
            if (exceptionItem) {
                exceptionItem.remove();
            }
        }

        // Validate SID format
        function validateSID(sid) {
            if (!sid) return false;
            // SID format: S-1-[identifier authority]-[subauthority1]-[subauthority2]-...
            const sidPattern = /^S-1-[0-9-]+$/;
            return sidPattern.test(sid);
        }

        // Common SIDs lookup
        const COMMON_SIDS = {
            'S-1-1-0': 'Everyone',
            'S-1-5-11': 'Authenticated Users',
            'S-1-5-18': 'Local System',
            'S-1-5-19': 'NT Authority\\Local Service',
            'S-1-5-20': 'NT Authority\\Network Service',
            'S-1-5-32-544': 'Administrators',
            'S-1-5-32-545': 'Users',
            'S-1-5-32-546': 'Guests',
            'S-1-5-32-547': 'Power Users',
            'S-1-5-32-551': 'Backup Operators',
            'S-1-5-32-552': 'Replicator'
        };

        function isCommonSid(sid) {
            if (!sid) return false;
            return COMMON_SIDS.hasOwnProperty(sid);
        }

        // Handle SID dropdown selection
        function handleSidSelect(selectElement, ruleId) {
            const sidInput = document.getElementById(`sid-input-${ruleId}`);
            const validationSpan = document.getElementById(`sid-validation-${ruleId}`);
            const helperSpan = document.getElementById(`sid-helper-${ruleId}`);
            
            if (selectElement.value === 'CUSTOM') {
                sidInput.value = '';
                sidInput.focus();
                validationSpan.style.display = 'none';
                helperSpan.textContent = 'Type a custom SID in the format: S-1-[identifier authority]-[subauthority1]-...';
            } else {
                sidInput.value = selectElement.value;
                validationSpan.style.display = 'none';
                const friendlyName = COMMON_SIDS[selectElement.value] || selectElement.value;
                helperSpan.textContent = `Selected: ${friendlyName}`;
                // Validate the selected SID
                validateSidInput(sidInput, ruleId);
            }
        }

        // Validate SID input in real-time
        function validateSidInput(inputElement, ruleId) {
            const selectElement = document.getElementById(`sid-select-${ruleId}`);
            const validationSpan = document.getElementById(`sid-validation-${ruleId}`);
            const helperSpan = document.getElementById(`sid-helper-${ruleId}`);
            const sid = inputElement.value.trim();
            
            // Update dropdown if user typed a common SID
            if (isCommonSid(sid)) {
                selectElement.value = sid;
                const friendlyName = COMMON_SIDS[sid] || sid;
                helperSpan.textContent = `Selected: ${friendlyName}`;
            } else if (sid && sid !== 'CUSTOM') {
                selectElement.value = 'CUSTOM';
                helperSpan.textContent = 'Custom SID entered';
            }
            
            if (!sid) {
                validationSpan.style.display = 'none';
                return;
            }
            
            if (validateSID(sid)) {
                validationSpan.style.display = 'inline';
                validationSpan.style.color = '#28a745';
                validationSpan.textContent = '‚úì Valid';
            } else {
                validationSpan.style.display = 'inline';
                validationSpan.style.color = '#dc3545';
                validationSpan.textContent = '‚úó Invalid format';
            }
        }

        // File category information
        const FILE_CATEGORY_INFO = {
            'EXE': {
                name: 'Executable Files',
                extensions: '.exe',
                ruleCollection: 'Exe',
                description: 'Standard Windows executables and applications. Controls execution of .exe files.',
                examples: 'Notepad.exe, Chrome.exe, Office applications'
            },
            'DLL': {
                name: 'Dynamic Link Libraries',
                extensions: '.dll',
                ruleCollection: 'Dll',
                description: 'Shared libraries loaded by executables. Controls loading of .dll files.',
                examples: 'System DLLs, application libraries, COM components'
            },
            'SCRIPT': {
                name: 'Scripts',
                extensions: '.ps1, .vbs, .js, .bat, .cmd',
                ruleCollection: 'Script',
                description: 'PowerShell, VBScript, JavaScript, and batch files. Controls script execution.',
                examples: 'PowerShell scripts, automation scripts, batch files'
            },
            'MSI': {
                name: 'Windows Installer Packages',
                extensions: '.msi, .msp',
                ruleCollection: 'Msi',
                description: 'Windows Installer packages and patches. Controls software installation.',
                examples: 'Software installers, application updates, patches'
            },
            'APPX': {
                name: 'Windows Store Apps',
                extensions: '.appx, .appxbundle',
                ruleCollection: 'Appx',
                description: 'Universal Windows Platform (UWP) applications. Controls Store app execution.',
                examples: 'Microsoft Store apps, UWP applications'
            },
            'CHM': {
                name: 'Compiled HTML Help',
                extensions: '.chm',
                ruleCollection: 'Exe',
                description: 'Compiled help files that can execute code. Controlled via Exe RuleCollection.',
                examples: 'Help documentation files, help systems',
                note: 'Note: CHM files are controlled through the Exe RuleCollection in AppLocker.'
            },
            'HTA': {
                name: 'HTML Applications',
                extensions: '.hta',
                ruleCollection: 'Exe',
                description: 'HTML-based applications with full system access (high risk). Controlled via Exe RuleCollection.',
                examples: 'HTML applications, local web apps',
                note: 'Note: HTA files are controlled through the Exe RuleCollection in AppLocker.'
            }
        };

        // Update file category description on change
        function updateFileCategoryInfo(selectElement, ruleId) {
            const category = selectElement.value;
            const info = FILE_CATEGORY_INFO[category];
            const descriptionSpan = document.getElementById(`file-category-description-${ruleId}`);
            
            if (info && descriptionSpan) {
                let html = `<strong>${info.name}</strong> - ${info.description}<br>`;
                html += `<small style="color: #888;">Extensions: ${info.extensions} | RuleCollection: ${info.ruleCollection}`;
                if (info.note) {
                    html += `<br><span style="color: #ff9800;">${info.note}</span>`;
                }
                html += `</small>`;
                descriptionSpan.innerHTML = html;
            }
        }

        // Initialize file category info when form is opened
        function initializeFileCategoryInfo(ruleItem) {
            const ruleId = ruleItem.getAttribute('data-rule-id');
            const selectElement = document.getElementById(`file-category-select-${ruleId}`);
            if (selectElement) {
                updateFileCategoryInfo(selectElement, ruleId);
            }
        }

        // Insert wildcard pattern into path input
        function insertWildcard(ruleId, pattern) {
            const pathInput = document.getElementById(`path-input-${ruleId}`);
            if (!pathInput) return;
            
            const currentValue = pathInput.value;
            const cursorPos = pathInput.selectionStart || currentValue.length;
            
            // If input is empty or just has a path prefix, append the pattern
            if (!currentValue || currentValue.endsWith('\\') || currentValue.endsWith('/')) {
                pathInput.value = currentValue + pattern;
            } else if (currentValue.trim() === '') {
                // If empty, just set the pattern
                pathInput.value = pattern;
            } else {
                // Insert at cursor position
                const before = currentValue.substring(0, cursorPos);
                const after = currentValue.substring(cursorPos);
                pathInput.value = before + pattern + after;
                // Set cursor position after inserted text
                setTimeout(() => {
                    pathInput.setSelectionRange(cursorPos + pattern.length, cursorPos + pattern.length);
                    pathInput.focus();
                }, 10);
            }
            pathInput.focus();
        }

        // Save rule edit
        function saveRuleEdit(button, event) {
            if (event) {
                event.stopPropagation();
            }
            
            const ruleItem = button.closest('.rule-item');
            const ruleId = ruleItem.getAttribute('data-rule-id');
            const layerId = ruleItem.getAttribute('data-layer-id');
            
            // Get form values
            const ruleName = ruleItem.querySelector('.edit-rule-name').value.trim();
            const ruleType = ruleItem.querySelector('.edit-rule-type').value;
            const fileCategory = ruleItem.querySelector('.edit-file-category').value;
            const action = ruleItem.querySelector('.edit-action').value;
            const businessJustification = ruleItem.querySelector('.edit-business-justification').value.trim();
            
            // Get User/Group SID
            const userGroupSid = ruleItem.querySelector('.edit-user-group-sid').value.trim() || 'S-1-1-0';
            if (userGroupSid && !validateSID(userGroupSid)) {
                alert('Invalid SID format. SID must start with S-1- and contain only numbers and hyphens.');
                return;
            }
            
            if (!ruleName || !businessJustification) {
                alert('Rule name and business justification are required');
                return;
            }
            
            // Build updated rule object
            const updatedRule = {
                rule_id: ruleId,
                rule_name: ruleName,
                rule_type: ruleType,
                file_category: fileCategory,
                action: action,
                business_justification: businessJustification,
                user_or_group_sid: userGroupSid
            };
            
            // Add type-specific fields
            if (ruleType === 'PATH') {
                const path = ruleItem.querySelector('.edit-path').value.trim();
                if (!path) {
                    alert('Path is required for PATH rules');
                    return;
                }
                updatedRule.path = path;
                
                // Collect exceptions
                const exceptionsList = document.getElementById(`path-exceptions-${ruleId}`);
                if (exceptionsList) {
                    const exceptionInputs = exceptionsList.querySelectorAll('.exception-path');
                    const exceptions = [];
                    exceptionInputs.forEach(input => {
                        const exceptionPath = input.value.trim();
                        if (exceptionPath) {
                            exceptions.push({ path: exceptionPath });
                        }
                    });
                    if (exceptions.length > 0) {
                        updatedRule.exceptions = exceptions;
                    }
                }
            } else if (ruleType === 'PUBLISHER') {
                const publisherName = ruleItem.querySelector('.edit-publisher-name').value.trim();
                if (!publisherName) {
                    alert('Publisher name is required for PUBLISHER rules');
                    return;
                }
                updatedRule.publisher_name = publisherName;
                updatedRule.publisher_product = ruleItem.querySelector('.edit-publisher-product').value.trim() || null;
                updatedRule.publisher_file = ruleItem.querySelector('.edit-publisher-file').value.trim() || '*.exe';
                updatedRule.version_low = ruleItem.querySelector('.edit-version-low').value.trim() || null;
                updatedRule.version_high = ruleItem.querySelector('.edit-version-high').value.trim() || '*';
            } else if (ruleType === 'HASH') {
                const hash = ruleItem.querySelector('.edit-hash-sha256').value.trim();
                if (!hash) {
                    alert('SHA-256 hash is required for HASH rules');
                    return;
                }
                updatedRule.hash_sha256 = hash;
                updatedRule.hash_type = ruleItem.querySelector('.edit-hash-type').value || 'SHA256';
                const fileLength = parseInt(ruleItem.querySelector('.edit-hash-filelength').value) || 0;
                updatedRule.hash_file_length = fileLength;
                updatedRule.source_file_length = fileLength; // Also store as source_file_length for compatibility
                updatedRule.hash_filename = ruleItem.querySelector('.edit-hash-filename').value.trim() || null;
                updatedRule.hash_file_version = ruleItem.querySelector('.edit-hash-version').value.trim() || null;
            }
            
            // Find and update rule in policy
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }
            
            const layer = policy.layers.find(l => l.layer_id === layerId);
            if (!layer) {
                alert('Layer not found');
                return;
            }
            
            const ruleIndex = layer.rules.findIndex(r => r.rule_id === ruleId);
            if (ruleIndex === -1) {
                alert('Rule not found');
                return;
            }
            
            // Update rule
            layer.rules[ruleIndex] = updatedRule;
            
            // Save policies
            savePolicies();
            
            // Refresh view
            viewPolicy(currentPolicyId);
            
            // Show success message
            alert('Rule updated successfully');
        }

        // Cancel rule edit
        function cancelRuleEdit(button, event) {
            if (event) {
                event.stopPropagation();
            }
            
            const ruleItem = button.closest('.rule-item');
            ruleItem.classList.remove('editing');
            
            // Reset edit button text
            const editButton = ruleItem.querySelector('.rule-actions button');
            if (editButton) {
                editButton.textContent = '‚úèÔ∏è Edit';
            }
        }

        // Add event listener for rule type change
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('edit-rule-type')) {
                const ruleItem = e.target.closest('.rule-item');
                updateRuleTypeSections(ruleItem);
            }
        });

        // Export to Intune JSON
        function exportToIntuneJSON(policy, enforcementMode = 'Enabled', preserveLayers = true) {
            const intunePolicy = {
                "@odata.type": "#microsoft.graph.appLockerApplicationControlPolicy",
                "displayName": policy.policy_name,
                "description": policy.description || "",
                "policy": exportToGroupPolicyXML(policy, enforcementMode, preserveLayers)
            };
            return JSON.stringify(intunePolicy, null, 2);
        }

        // Export to text
        function exportToText(policy) {
            let text = `AppLocker Policy: ${policy.policy_name}\n`;
            text += `Generated: ${new Date().toISOString()}\n`;
            text += `System Classes: ${policy.system_classes ? policy.system_classes.join(', ') : 'N/A'}\n`;
            text += `\n${'='.repeat(80)}\n\n`;
            
            const sortedLayers = [...policy.layers].sort((a, b) => a.layer_precedence - b.layer_precedence);
            
            sortedLayers.forEach(layer => {
                text += `Layer: ${layer.layer_name}\n`;
                text += `Type: ${layer.layer_type}\n`;
                text += `Precedence: ${layer.layer_precedence}\n`;
                if (layer.app_name) {
                    text += `Application: ${layer.app_name}\n`;
                    text += `Vendor: ${layer.app_vendor}\n`;
                }
                text += `Business Justification: ${layer.business_justification}\n`;
                if (layer.deviates_from_baseline) {
                    text += `‚ö† DEVIATION: ${layer.deviation_reason}\n`;
                    text += `Risk Level: ${layer.deviation_risk_level}\n`;
                    text += `Mitigation: ${layer.deviation_mitigation}\n`;
                }
                text += `\nRules (${layer.rules ? layer.rules.length : 0}):\n`;
                
                if (layer.rules && layer.rules.length > 0) {
                    layer.rules.forEach(rule => {
                        text += `  - ${rule.rule_name} [${rule.rule_type}] ${rule.action}\n`;
                        if (rule.path) text += `    Path: ${rule.path}\n`;
                        if (rule.publisher_name) text += `    Publisher: ${rule.publisher_name}\n`;
                        text += `    Justification: ${rule.business_justification}\n`;
                    });
                }
                
                text += `\n${'-'.repeat(80)}\n\n`;
            });
            
            return text;
        }

        // Download file
        function downloadFile(filename, content, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Store current layer ID for export
        let currentLayerIdForExport = null;

        // Export a single layer (show modal)
        function exportLayer(layerId) {
            if (!currentPolicyId) return;

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }

            const layer = policy.layers.find(l => l.layer_id === layerId);
            if (!layer) {
                alert('Layer not found');
                return;
            }

            // Store layer ID
            currentLayerIdForExport = layerId;

            // Show layer info in modal
            document.getElementById('layer-export-info').innerHTML = `
                <div class="alert alert-info">
                    <strong>Layer:</strong> ${escapeHtml(layer.layer_name)}<br>
                    <strong>Type:</strong> ${layer.layer_type}<br>
                    <strong>Rules:</strong> ${layer.rules ? layer.rules.length : 0}
                </div>
            `;

            // Show modal
            document.getElementById('layer-export-modal').style.display = 'block';
        }

        // Export layer from modal
        function exportLayerFromModal() {
            if (!currentPolicyId || !currentLayerIdForExport) return;

            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }

            const layer = policy.layers.find(l => l.layer_id === currentLayerIdForExport);
            if (!layer) {
                alert('Layer not found');
                return;
            }

            const format = document.getElementById('layer-export-format').value;
            const enforcementMode = document.getElementById('layer-export-enforcement-mode').value || 'Enabled';
            let content = '';
            let filename = '';
            let mimeType = '';

            if (format === 'group_policy') {
                content = exportLayerToGroupPolicyXML(layer, policy, enforcementMode);
                filename = `AppLockerLayer-${layer.layer_name.replace(/[^a-z0-9]/gi, '_')}.xml`;
                mimeType = 'application/xml';
            } else if (format === 'intune') {
                content = exportLayerToIntuneJSON(layer, policy, enforcementMode);
                filename = `AppLockerLayer-${layer.layer_name.replace(/[^a-z0-9]/gi, '_')}.json`;
                mimeType = 'application/json';
            } else if (format === 'text') {
                content = exportLayerToText(layer, policy);
                filename = `AppLockerLayer-${layer.layer_name.replace(/[^a-z0-9]/gi, '_')}.txt`;
                mimeType = 'text/plain';
            }

            downloadFile(filename, content, mimeType);
            closeModal('layer-export-modal');
            currentLayerIdForExport = null;
        }

        // Export layer to Group Policy XML
        function exportLayerToGroupPolicyXML(layer, policy, enforcementMode = 'Enabled', preserveLayers = true) {
            // Validate EnforcementMode - AppLocker accepts "Enabled", "AuditOnly", or "NotConfigured"
            const validEnforcementMode = (enforcementMode === 'Enabled' || enforcementMode === 'AuditOnly' || enforcementMode === 'NotConfigured') 
                ? enforcementMode 
                : 'Enabled';
            
            let xml = '<?xml version="1.0" encoding="utf-8"?>\n';
            xml += '<AppLockerPolicy Version="1">\n';
            
            // Add layer metadata as comment if preserving
            if (preserveLayers) {
                const layerMetadata = {
                    layer_id: layer.layer_id,
                    layer_name: layer.layer_name,
                    layer_type: layer.layer_type,
                    layer_precedence: layer.layer_precedence,
                    business_justification: layer.business_justification,
                    deviates_from_baseline: layer.deviates_from_baseline,
                    deviation_reason: layer.deviation_reason || null,
                    deviation_risk_level: layer.deviation_risk_level || null,
                    deviation_mitigation: layer.deviation_mitigation || null
                };
                xml += `  <!-- Layer:${escapeXml(JSON.stringify(layerMetadata))} -->\n`;
            }
            
            // Group rules by file category
            const rulesByCategory = {
                'EXE': [],
                'DLL': [],
                'SCRIPT': [],
                'MSI': [],
                'APPX': [],
                'CHM': [],
                'HTA': []
            };

            if (layer.rules) {
                layer.rules.forEach(rule => {
                    if (rulesByCategory[rule.file_category]) {
                        rulesByCategory[rule.file_category].push(rule);
                    }
                });
            }

            // Generate RuleCollections for each category that has rules
            // Note: CHM and HTA are controlled via Exe RuleCollection in AppLocker
            const categoryMap = {
                'EXE': 'Exe',
                'DLL': 'Dll',
                'SCRIPT': 'Script',
                'MSI': 'Msi',
                'APPX': 'Appx',
                'CHM': 'Exe',  // CHM files use Exe RuleCollection
                'HTA': 'Exe'   // HTA files use Exe RuleCollection
            };
            
            // Group CHM and HTA with EXE for the same RuleCollection
            const collectionGroups = {
                'Exe': ['EXE', 'CHM', 'HTA'],
                'Dll': ['DLL'],
                'Script': ['SCRIPT'],
                'Msi': ['MSI'],
                'Appx': ['APPX']
            };

            // Generate RuleCollections, grouping EXE/CHM/HTA together
            const processedCollections = new Set();
            
            Object.keys(collectionGroups).forEach(collectionType => {
                const categories = collectionGroups[collectionType];
                let hasRules = false;
                let collectionRules = [];
                
                categories.forEach(category => {
                    if (rulesByCategory[category] && rulesByCategory[category].length > 0) {
                        hasRules = true;
                        collectionRules = collectionRules.concat(rulesByCategory[category]);
                    }
                });
                
                if (hasRules && !processedCollections.has(collectionType)) {
                    processedCollections.add(collectionType);
                    xml += `  <RuleCollection Type="${collectionType}" EnforcementMode="${validEnforcementMode}">\n`;
                    collectionRules.forEach(rule => {
                        xml += generateRuleXML(rule, layer);
                    });
                    xml += '  </RuleCollection>\n';
                }
            });
            
            xml += '</AppLockerPolicy>\n';
            return xml;
        }

        // Export layer to Intune JSON
        function exportLayerToIntuneJSON(layer, policy, enforcementMode = 'Enabled') {
            const intunePolicy = {
                "@odata.type": "#microsoft.graph.appLockerApplicationControlPolicy",
                "displayName": `${policy.policy_name} - ${layer.layer_name}`,
                "description": layer.business_justification || "",
                "policy": exportLayerToGroupPolicyXML(layer, policy, enforcementMode)
            };
            return JSON.stringify(intunePolicy, null, 2);
        }

        // Export layer to text
        function exportLayerToText(layer, policy) {
            let text = `AppLocker Layer Export\n`;
            text += `Policy: ${policy.policy_name}\n`;
            text += `Layer: ${layer.layer_name}\n`;
            text += `Generated: ${new Date().toISOString()}\n`;
            text += `\n${'='.repeat(80)}\n\n`;
            
            text += `Layer Information:\n`;
            text += `  Type: ${layer.layer_type}\n`;
            text += `  Precedence: ${layer.layer_precedence}\n`;
            if (layer.app_name) {
                text += `  Application: ${layer.app_name}\n`;
                text += `  Vendor: ${layer.app_vendor}\n`;
            }
            text += `  Business Justification: ${layer.business_justification}\n`;
            if (layer.deviates_from_baseline) {
                text += `  ‚ö† DEVIATION: ${layer.deviation_reason}\n`;
                text += `  Risk Level: ${layer.deviation_risk_level}\n`;
                text += `  Mitigation: ${layer.deviation_mitigation}\n`;
            }
            
            text += `\n${'='.repeat(80)}\n\n`;
            text += `Rules (${layer.rules ? layer.rules.length : 0}):\n\n`;
            
            if (layer.rules && layer.rules.length > 0) {
                layer.rules.forEach((rule, index) => {
                    text += `${index + 1}. ${rule.rule_name}\n`;
                    text += `   Type: ${rule.rule_type} - ${rule.file_category}\n`;
                    text += `   Action: ${rule.action}\n`;
                    if (rule.path) text += `   Path: ${rule.path}\n`;
                    if (rule.publisher_name) text += `   Publisher: ${rule.publisher_name}\n`;
                    if (rule.publisher_product) text += `   Product: ${rule.publisher_product}\n`;
                    if (rule.publisher_file) text += `   File: ${rule.publisher_file}\n`;
                    if (rule.version_low || rule.version_high) {
                        text += `   Version: ${rule.version_low || '*'} - ${rule.version_high || '*'}\n`;
                    }
                    if (rule.hash_sha256) {
                        text += `   Hash: ${rule.hash_sha256}\n`;
                        if (rule.hash_filename) text += `   File Name: ${rule.hash_filename}\n`;
                    }
                    text += `   Justification: ${rule.business_justification}\n`;
                    text += `\n`;
                });
            } else {
                text += `No rules in this layer.\n`;
            }
            
            return text;
        }

        // Delete policy
        function deletePolicy(policyId) {
            if (!confirm('Are you sure you want to delete this policy?')) return;
            policies = policies.filter(p => p.policy_id !== policyId);
            savePolicies();
            loadPolicies();
        }

        // Delete layer
        function deleteLayer(layerId) {
            if (!currentPolicyId) return;
            if (!confirm('Are you sure you want to delete this layer?')) return;
            
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) return;
            
            policy.layers = policy.layers.filter(l => l.layer_id !== layerId);
            savePolicies();
            viewPolicy(currentPolicyId);
        }

        // Edit layer details (unified function for all fields)
        function editLayerDetails(layerId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // Show edit form
            document.getElementById(`layer-details-edit-${layerId}`).style.display = 'block';
            
            // Focus the first input
            const input = document.getElementById(`layer-name-input-${layerId}`);
            if (input) {
                input.focus();
                input.select();
            }
        }

        // Save layer details (unified function for all fields)
        function saveLayerDetails(layerId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (!currentPolicyId) return;
            
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }
            
            const layer = policy.layers.find(l => l.layer_id === layerId);
            if (!layer) {
                alert('Layer not found');
                return;
            }
            
            // Get all values
            const newName = document.getElementById(`layer-name-input-${layerId}`).value.trim();
            const newDescription = document.getElementById(`layer-justification-input-${layerId}`).value.trim();
            
            // Validate required fields
            if (!newName) {
                alert('Layer name cannot be empty');
                return;
            }
            
            if (!newDescription) {
                alert('Business justification cannot be empty');
                return;
            }
            
            // Update layer name
            layer.layer_name = newName;
            
            // Update business justification
            layer.business_justification = newDescription;
            
            // Update application and vendor if not baseline
            const isBaseline = layer.layer_type === 'BASELINE';
            if (!isBaseline) {
                const appNameInput = document.getElementById(`layer-app-name-input-${layerId}`);
                const appVendorInput = document.getElementById(`layer-app-vendor-input-${layerId}`);
                if (appNameInput) {
                    layer.app_name = appNameInput.value.trim() || null;
                }
                if (appVendorInput) {
                    layer.app_vendor = appVendorInput.value.trim() || null;
                }
            }
            
            // Save policies
            savePolicies();
            
            // Refresh view
            viewPolicy(currentPolicyId);
        }

        // Cancel editing layer details
        function cancelEditLayerDetails(layerId, event) {
            if (event) {
                event.stopPropagation();
            }
            
            // Restore original values
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (policy) {
                const layer = policy.layers.find(l => l.layer_id === layerId);
                if (layer) {
                    document.getElementById(`layer-name-input-${layerId}`).value = layer.layer_name;
                    document.getElementById(`layer-justification-input-${layerId}`).value = layer.business_justification;
                    
                    const isBaseline = layer.layer_type === 'BASELINE';
                    if (!isBaseline) {
                        const appNameInput = document.getElementById(`layer-app-name-input-${layerId}`);
                        const appVendorInput = document.getElementById(`layer-app-vendor-input-${layerId}`);
                        if (appNameInput) {
                            appNameInput.value = layer.app_name || '';
                        }
                        if (appVendorInput) {
                            appVendorInput.value = layer.app_vendor || '';
                        }
                    }
                }
            }
            
            // Hide edit form
            document.getElementById(`layer-details-edit-${layerId}`).style.display = 'none';
        }

        // Delete a rule from a layer
        function deleteRule(ruleId, layerId, isBaselineLayer, event) {
            if (event) {
                event.stopPropagation();
            }
            
            if (!currentPolicyId) return;
            
            // Warn if trying to delete from baseline
            if (isBaselineLayer) {
                if (!confirm('Warning: You are about to delete a rule from the BASELINE layer. This may affect policy compliance. Are you sure?')) {
                    return;
                }
            } else {
                if (!confirm('Are you sure you want to delete this rule?')) {
                    return;
                }
            }
            
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) {
                alert('Policy not found');
                return;
            }
            
            const layer = policy.layers.find(l => l.layer_id === layerId);
            if (!layer) {
                alert('Layer not found');
                return;
            }
            
            if (!layer.rules) {
                alert('No rules found in layer');
                return;
            }
            
            // Remove the rule
            const initialRuleCount = layer.rules.length;
            layer.rules = layer.rules.filter(r => r.rule_id !== ruleId);
            
            if (layer.rules.length === initialRuleCount) {
                alert('Rule not found');
                return;
            }
            
            // Save policies
            savePolicies();
            
            // Refresh view
            viewPolicy(currentPolicyId);
        }

        // Drag and Drop Handlers for Rules
        let draggedRuleId = null;
        let draggedLayerId = null;
        let draggedRuleElement = null;
        let expandedContainersDuringDrag = new Set(); // Track containers expanded during drag
        let collapseTimeout = null; // Timeout for delayed collapse

        function handleRuleDragStart(event, ruleId, layerId) {
            event.stopPropagation();
            draggedRuleId = ruleId;
            draggedLayerId = layerId;
            draggedRuleElement = event.currentTarget;
            
            // Add dragging class
            event.currentTarget.classList.add('dragging');
            
            // Set drag data
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', ruleId);
            
            // Store rule data in dataTransfer for cross-layer moves
            const ruleData = event.currentTarget.getAttribute('data-rule-data');
            event.dataTransfer.setData('application/json', ruleData);
        }

        function handleRuleDragEnd(event) {
            event.stopPropagation();
            if (draggedRuleElement) {
                draggedRuleElement.classList.remove('dragging');
            }
            
            // Clear all drag-over classes
            document.querySelectorAll('.rule-drop-zone.drag-over').forEach(zone => {
                zone.classList.remove('drag-over');
            });
            document.querySelectorAll('.rules-list.drag-over').forEach(list => {
                list.classList.remove('drag-over');
            });
            document.querySelectorAll('.layer-card.drag-over').forEach(card => {
                card.classList.remove('drag-over');
            });
            
            // Clear any pending collapse timeout
            if (collapseTimeout) {
                clearTimeout(collapseTimeout);
                collapseTimeout = null;
            }
            
            // Keep containers expanded for a short time after drag ends (unless drop occurred)
            // This gives visual feedback that the drag completed
            // The drop handler will handle collapsing if needed
            
            draggedRuleId = null;
            draggedLayerId = null;
            draggedRuleElement = null;
        }

        function handleRuleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            
            // Only allow drop if it's a rule item being dragged
            if (draggedRuleId) {
                event.dataTransfer.dropEffect = 'move';
                
                // Add visual feedback
                const target = event.currentTarget;
                let container = null;
                let header = null;
                let layerCard = null;
                let layerId = null;
                
                // Check if dragging over layer card directly
                if (target.classList.contains('layer-card') || target.closest('.layer-card') === target) {
                    layerCard = target.classList.contains('layer-card') ? target : target.closest('.layer-card');
                    if (layerCard) {
                        layerCard.classList.add('drag-over');
                        // Find the layer ID from the card
                        const rulesHeader = layerCard.querySelector('.rules-list-header');
                        if (rulesHeader) {
                            layerId = rulesHeader.getAttribute('data-layer-id');
                            container = document.getElementById(`rules-list-${layerId}`);
                            header = rulesHeader;
                            // Expand the container if it's collapsed
                            if (container && !container.classList.contains('expanded')) {
                                container.classList.add('expanded');
                                if (header) {
                                    header.classList.add('expanded');
                                }
                                expandedContainersDuringDrag.add(container.id);
                            }
                        }
                    }
                } else if (target.classList.contains('rule-drop-zone')) {
                    target.classList.add('drag-over');
                    // Find the rules-list-container and expand it
                    container = target.closest('.rules-list-container');
                    if (container) {
                        layerId = container.id.replace('rules-list-', '');
                        header = document.querySelector(`.rules-list-header[data-layer-id="${layerId}"]`);
                        if (!container.classList.contains('expanded')) {
                            container.classList.add('expanded');
                            if (header) {
                                header.classList.add('expanded');
                            }
                            expandedContainersDuringDrag.add(container.id);
                        }
                    }
                    // Also highlight the parent layer card
                    layerCard = target.closest('.layer-card');
                    if (layerCard) {
                        layerCard.classList.add('drag-over');
                    }
                } else if (target.classList.contains('rules-list')) {
                    target.classList.add('drag-over');
                    // Find the rules-list-container and expand it
                    container = target.closest('.rules-list-container');
                    if (container) {
                        layerId = container.id.replace('rules-list-', '');
                        header = document.querySelector(`.rules-list-header[data-layer-id="${layerId}"]`);
                        if (!container.classList.contains('expanded')) {
                            container.classList.add('expanded');
                            if (header) {
                                header.classList.add('expanded');
                            }
                            expandedContainersDuringDrag.add(container.id);
                        }
                    }
                    // Also highlight the parent layer card
                    layerCard = target.closest('.layer-card');
                    if (layerCard) {
                        layerCard.classList.add('drag-over');
                    }
                }
            }
        }

        function handleRuleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const target = event.currentTarget;
            const relatedTarget = event.relatedTarget;
            
            // Check if dragging over layer card directly
            if (target.classList.contains('layer-card') || target.closest('.layer-card') === target) {
                const layerCard = target.classList.contains('layer-card') ? target : target.closest('.layer-card');
                // Only remove drag-over if we're actually leaving the layer card
                // Check if we're moving to a child element within the same layer
                if (!relatedTarget || !layerCard || !layerCard.contains(relatedTarget)) {
                    if (layerCard) {
                        layerCard.classList.remove('drag-over');
                    }
                }
            } else if (target.classList.contains('rule-drop-zone')) {
                // Only remove drag-over if we're actually leaving the drop zone
                // Check if we're moving to a child element (like another drop zone)
                if (!relatedTarget || (!target.contains(relatedTarget) && !relatedTarget.closest('.rule-drop-zone'))) {
                    target.classList.remove('drag-over');
                    // Check if we're leaving the entire layer area
                    const layerCard = target.closest('.layer-card');
                    if (layerCard && (!relatedTarget || !layerCard.contains(relatedTarget))) {
                        layerCard.classList.remove('drag-over');
                    }
                }
            } else if (target.classList.contains('rules-list')) {
                // Only remove drag-over if we're actually leaving the list
                // Check if we're moving to a child element (like a drop zone)
                if (!relatedTarget || (!target.contains(relatedTarget) && !relatedTarget.closest('.rules-list'))) {
                    target.classList.remove('drag-over');
                    // Check if we're leaving the entire layer area
                    const layerCard = target.closest('.layer-card');
                    if (layerCard && (!relatedTarget || !layerCard.contains(relatedTarget))) {
                        layerCard.classList.remove('drag-over');
                    }
                }
            }
        }

        function handleRuleDrop(event, targetLayerId, dropIndex) {
            event.preventDefault();
            event.stopPropagation();
            
            if (!draggedRuleId || !currentPolicyId) return;
            
            // Remove drag-over classes
            document.querySelectorAll('.rule-drop-zone.drag-over').forEach(zone => {
                zone.classList.remove('drag-over');
            });
            document.querySelectorAll('.rules-list.drag-over').forEach(list => {
                list.classList.remove('drag-over');
            });
            document.querySelectorAll('.layer-card.drag-over').forEach(card => {
                card.classList.remove('drag-over');
            });
            
            // Clear any pending collapse timeout
            if (collapseTimeout) {
                clearTimeout(collapseTimeout);
                collapseTimeout = null;
            }
            
            // Ensure target container is expanded so user can see the drop
            const targetContainer = document.getElementById(`rules-list-${targetLayerId}`);
            if (targetContainer) {
                targetContainer.classList.add('expanded');
                const header = document.querySelector(`.rules-list-header[data-layer-id="${targetLayerId}"]`);
                if (header) {
                    header.classList.add('expanded');
                }
                // Keep it expanded for a bit after drop
                expandedContainersDuringDrag.add(targetContainer.id);
            }
            
            const policy = policies.find(p => p.policy_id === currentPolicyId);
            if (!policy) return;
            
            const sourceLayer = policy.layers.find(l => l.layer_id === draggedLayerId);
            const targetLayer = policy.layers.find(l => l.layer_id === targetLayerId);
            
            if (!sourceLayer || !targetLayer || !sourceLayer.rules) return;
            
            // Find the rule being moved
            const ruleIndex = sourceLayer.rules.findIndex(r => r.rule_id === draggedRuleId);
            if (ruleIndex === -1) return;
            
            const rule = sourceLayer.rules[ruleIndex];
            
            // Determine target index
            let targetIndex = dropIndex;
            if (targetIndex === undefined || targetIndex === null) {
                // Dropped on the list itself, append to end
                targetIndex = targetLayer.rules ? targetLayer.rules.length : 0;
            }
            
            // Check if moving within same layer to same position (no-op)
            if (draggedLayerId === targetLayerId) {
                // If dropping at the same index or right after itself, it's a no-op
                if (ruleIndex === targetIndex || ruleIndex + 1 === targetIndex) {
                    // Same position, no change needed
                    return;
                }
            }
            
            // Check if moving to baseline (warn)
            const isTargetBaseline = targetLayer.layer_type === 'BASELINE';
            if (isTargetBaseline && !targetLayer.is_locked) {
                if (!confirm('Warning: You are about to move a rule to the BASELINE layer. This may affect policy compliance. Continue?')) {
                    return;
                }
            }
            
            // Ensure target layer has rules array
            if (!targetLayer.rules) {
                targetLayer.rules = [];
            }
            
            // Handle reordering within same layer
            if (draggedLayerId === targetLayerId) {
                // Moving within the same layer - remove and reinsert
                // Remove rule from source position
                sourceLayer.rules.splice(ruleIndex, 1);
                
                // Adjust target index if we removed an item before the target position
                if (ruleIndex < targetIndex) {
                    targetIndex--; // Adjust for removed item
                }
                
                // Insert rule at target position
                targetLayer.rules.splice(targetIndex, 0, rule);
            } else {
                // Moving between different layers
                // Remove rule from source layer
                sourceLayer.rules.splice(ruleIndex, 1);
                
                // Insert rule at target position
                targetLayer.rules.splice(targetIndex, 0, rule);
            }
            
            // Save policies
            savePolicies();
            
            // Refresh view
            viewPolicy(currentPolicyId);
            
            // After refresh, keep the target container expanded for a bit so user can see the result
            setTimeout(() => {
                const targetContainer = document.getElementById(`rules-list-${targetLayerId}`);
                if (targetContainer) {
                    targetContainer.classList.add('expanded');
                    const header = document.querySelector(`.rules-list-header[data-layer-id="${targetLayerId}"]`);
                    if (header) {
                        header.classList.add('expanded');
                    }
                    
                    // Collapse after 2 seconds (unless user manually expands/collapses)
                    collapseTimeout = setTimeout(() => {
                        // Only collapse if it's still expanded (user hasn't interacted)
                        if (targetContainer.classList.contains('expanded')) {
                            // Check if user is hovering over the container
                            const isHovered = targetContainer.matches(':hover') || 
                                             targetContainer.querySelector(':hover');
                            if (!isHovered) {
                                targetContainer.classList.remove('expanded');
                                if (header) {
                                    header.classList.remove('expanded');
                                }
                            }
                        }
                        expandedContainersDuringDrag.clear();
                    }, 2000);
                }
            }, 100);
            
            // Show success message
            const movedWithin = draggedLayerId === targetLayerId ? 'reordered' : 'moved';
            console.log(`Rule ${movedWithin} successfully`);
        }

        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            // Clear dashboard import flag when closing import modal
            if (modalId === 'import-modal') {
                window.importFromDashboard = false;
            }
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape XML
        function escapeXml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = document.querySelectorAll('.modal');
            modals.forEach(modal => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        };

        // Initialize on load
        init();
    </script>
</body>
</html>
